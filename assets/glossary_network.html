<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>ADictML – Glossary Network</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    body { background:#fff; margin:0; }
    #mynetwork { width:100%; height: 100vh; border:1px solid #eee; }
    #overlay {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.88);
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 8px 10px;
      font: 12px/1.3 Inter, Arial, sans-serif;
      color: #222;
      max-width: 45vw;
    }
    #overlay .small { color:#666; }
    #progress {
      width: 240px;
      height: 6px;
      background: #eee;
      border-radius: 6px;
      overflow: hidden;
      margin-top: 6px;
    }
    #bar {
      height: 100%;
      width: 0%;
      background: #999;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div><strong>ADictML Term Network</strong></div>
    <div class="small" id="status">Stabilizing layout…</div>
    <div id="progress"><div id="bar"></div></div>
  </div>
  <div id="mynetwork"></div>

  <script>
    // ---------------------------
    // Data
    // ---------------------------
    const nodes = new vis.DataSet([{"id": "imagesegmentation", "label": "image segmentation", "title": "Image segmentation refers to the task of the pixels of an image into few segments. \\\\ See also: .", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "stratification", "label": "stratification", "title": "The process of splitting a into subsets, so called , according to some key attribute is called stratification , , . The goal is to ensure that an method performs well for each defined by these attributes. For example, in a medical , we may want to stratify a patient by age groups to ensure that an performs well across all age groups. \\\\ When splitting a into a and a , stratification ensures that both sets have similar distributions of the key attribute. Without stratification, using a small may underrepresent or even completely miss with a rare attribute, leading to misleading performance estimates. See Fig. for a visual illustration. [H] [font= ,x=1.7cm] at (0.5* , +0.2) { }; at ({0.5* }, {-( + )+ +0.2}) { / split without stratification}; at (0.5* , {-2*( + )+ +0.2}) {with stratification}; {0} {-( + )} {-2*( + )} { } { } {(1- )* } (0, ) rectangle ++( , ); ( , ) -- ++(0, ); at (0.5* , +0.5* ) { }; at ({ +0.5* }, { +0.5* }) { }; (0, ) rectangle ++( , ); { } {(1- )* } ( , ) rectangle ++( , ); ( , ) -- ++(0, ); (0, ) rectangle ++( , ); { } ( , ) -- ++(0, ); { } {(1- )* } ( , ) rectangle ++( , ); { + } {(1- )* } ( , ) rectangle ++( , ); {Stratification ensures that both the and the (shaded grey) have similar distributions of a binary key attribute . In other words, with stratification, both (i.e., and based on the key attribute) allocate the same validation proportion—20\\% of their own width. } See also: , , .", "color": "#e87c7c", "value": 11, "inDeg": 2}, {"id": "stratum", "label": "stratum", "title": "A stratum is a subset of that all share a common property (which could be a or a ). For example, in a weather , all measurements from the same weather station form one stratum. Example (CSV snippet):\\\\ { time, station, value, unit\\\\ 2023-06-01 12:00, Helsinki, 18.2, degree Celsius\\\\ 2023-06-01 13:00, Helsinki, 18.5, degree Celsius\\\\ 2023-06-01 14:00, Helsinki, 19.0, degree Celsius\\\\ 2023-06-01 12:00, Oulu, 12.1, degree Celsius\\\\ 2023-06-01 13:00, Oulu, 12.4, degree Celsius\\\\ 2023-06-01 14:00, Oulu, 12.7, degree Celsius\\\\ 2023-06-01 12:00, Tampere, 15.3, degree Celsius\\\\ 2023-06-01 13:00, Tampere, 15.6, degree Celsius\\\\ 2023-06-01 14:00, Tampere, 16.0, degree Celsius } Here, the rows for each station (i.e., , , ) represent different strata. \\\\ See also: , , .", "color": "#e87c7c", "value": 8, "inDeg": 2}, {"id": "det", "label": "determinant", "title": "The determinant of a square is a of its columns , i.e., it satisfies the following properties : Normalized: Multilinear: ( ^{(1)},\\, ,\\, + ,\\, ,\\, ^{( )} ) & = ( ^{(1)},\\, ,\\, ,\\, ,\\, ^{( )} ) \\\\ & + ( ^{(1)},\\, ,\\, ,\\, ,\\, ^{( )} ) Antisymmetric: We can interpret a as a linear transformation on . The determinant characterizes how volumes in (and their orientation) are altered by this transformation (see Fig. ) , . In particular, preserves orientation, reverses orientation, and collapses volume entirely, indicating that is non-invertible. The determinant also satisfies , and if is with , then . For the special cases (i.e., two-dimensional or 2-D) and (i.e., three-dimensional or 3-D), the determinant can be interpreted as an oriented area or volume spanned by the column of . [H] [x=2cm] (0,0) -- (1,0) node[below right] { }; (0,0) -- (0,1) node[above left] { }; [shift={(2.8,0)}] (A) at (1.5,0.5); (B) at (-0.2,1.2); (0,0) -- (A) node[below right] { }; (0,0) -- (B) node[above left] { }; (0,0) -- (A) -- ( ) -- (B) -- cycle; (A) -- ( ); (B) -- ( ); at (0.8,0.6) { }; (0.4,0.0) arc[start angle=0, end angle=35, radius=0.6]; (1.3,0.5) -- (2.4,0.5) node[midway, above] { }; {We can interpret a square as a linear transformation of into itself. The determinant characterizes how this transformation alters an oriented volume. } See also: , .", "color": "#7ce8ba", "value": 7, "inDeg": 1}, {"id": "hessian", "label": "Hessian", "title": "Consider a for which the second-order exist at . Then, the Hessian of at is defined as the of second-order of at , i.e., If the second-order are in a around , then the Hessian is a symmetric , i.e., for all . If additionally is , then the Hessian is a .\\\\ The Hessian can be used to compute a that approximates locally around (see also Fig. ). [H] [x=0.5cm] [ hide axis, xmin=3, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.5, above right, yshift=3pt] { }; node[pos=0, below left] { }; node[pos=0, below left, yshift=10pt] { }; coordinates {(6, {2 + sin(deg(6))})}; coordinates {(6,0) (6,2.4)}; at (axis cs:6, -0.2) { }; {-1.5} {3} {2 + sin(deg( ))} {2 + sin(deg( ))} {A that is sufficiently at a point can be locally approximated by a , which provides a more accurate approximation compared to a linear . } See also: , , , .", "color": "#9be87c", "value": 12, "inDeg": 1}, {"id": "attention", "label": "attention", "title": "Some applications involve composed of smaller units, referred to as . For example, a sentence consists of words, an image of pixel patches, and a network of nodes. In general, the that constitute a single are not independent of one another. Instead, each of a depends on (or pays attention to) specific other . provide a principled framework for representing and analyzing such dependencies . Attention mechanisms use a more direct approach without explicit reference to a . The idea is to represent the relationship between two and using a parameterized , where the are learned via a variant of . Practical attention mechanisms differ in their precise choice of attention as well as in the precise variant used to learn the . One widely used family of attention mechanisms defines the in terms of two associated with each , i.e., a query and a key . For a given with query , and another token with key , the quantity indicates the extent to which attends to (or depends on) (see Fig. ). [H] [>=stealth, node distance=0.2cm and 0.2cm, every node/.style={inner sep=2pt, font= }, baseline] (w1) [draw, fill=gray!10, rounded corners] {All}; (w2) [draw, fill=gray!10, right=of w1, rounded corners] {human}; (w3) [draw, fill=gray!10, right=of w2, rounded corners] {beings}; (w4) [draw, fill=gray!10, right=of w3, rounded corners] {are}; (w5) [draw, fill=gray!10, right=of w4, rounded corners] {born}; (w6) [draw, fill=gray!10, right=of w5, rounded corners] {free}; (w7) [draw, fill=gray!10, right=of w6, rounded corners] {and}; (w8) [draw, fill=blue!20, right=of w7, rounded corners] {equal}; (labeli) { \\\\ }; (labelii) { \\\\ }; (eqTop) [above=1.8cm of w8] {}; (w8.north) .. controls +(up:1.0cm) and +(up:1.0cm) .. (w6.north); (w8.north) .. controls +(up:1.2cm) and +(up:1.0cm) .. (w5.north); (w8.north) .. controls +(up:1.8cm) and +(up:1.0cm) .. node[midway, text=black, above] { } (w1.north); {Attention mechanisms learn a parameterized to measure how much attends to . One widely used construction of uses query and key , denoted by and , assigned to each . } See also: , , .", "color": "#e87c7c", "value": 12, "inDeg": 2}, {"id": "transformer", "label": "transformer", "title": "In the context of , the term transformer refers to an that uses some form of mechanism to capture dependencies among . The mechansim is what sets transformers apart from previous used for sequential such as . A transformer often combines several via more traditional architectures. \\\\ See also: , .", "color": "#e87c7c", "value": 11, "inDeg": 2}, {"id": "rnn", "label": "recurrent neural network (RNN)", "title": "An RNN is a specific type of that is designed for processing that consist of a of . An RNN maintains an internal hidden state that is updated recurrently as new are processed. This recurrent dependence allows information to propagate across time steps, making RNNs suitable for tasks such as speech recognition, language modeling, or time series . However, their inherently sequential computation limits parallelization and is challenging for . Variants like the long short-term memory (LSTM) and gated recurrent unit (GRU) mitigate these problems. \\\\ See also: , .", "color": "#9be87c", "value": 7, "inDeg": 1}, {"id": "llm", "label": "large language model (LLM)", "title": "An LLM is an umbrella term for methods that use high-dimensional (with billions of ) trained on large collections of text . LLMs are used to analyze or generate of that constitute text . Many current LLMs use some variant of a that is trained via , i.e., the is based on the task of predicting a few words that are intentionally removed from a large text corpus. Thus, we can construct simply by selecting some words from a given text as and the remaining words as of . This construction requires very little human supervision and allows for generating sufficiently large for LLMs. \\\\ See also: , , .", "color": "#e87c7c", "value": 17, "inDeg": 2}, {"id": "selfsupervisedlearning", "label": "self-supervised learning", "title": "Self-supervised learning uses some of the of a as its . For example, if a consists of a sentence within a text document, we can use the last word of the sentence as the that is to be predicted from all the previous words, which form the of the . A main application of self-supervised learning is in for the of from large collections of text . \\\\ See also: , , .", "color": "#e87c7c", "value": 9, "inDeg": 2}, {"id": "optproblem", "label": "optimization problem", "title": "An optimization problem is a mathematical structure consisting of an defined over an optimization variable , together with a feasible set . The co-domain is assumed to be ordered, meaning that for any two elements , we can determine whether , , or . The goal of optimization is to find those values for which the objective is extremal—i.e., minimal or maximal , , . \\\\ See also: .", "color": "#e8d87c", "value": 18, "inDeg": 17}, {"id": "optmethod", "label": "optimization method", "title": "An optimization method is an that takes a representation of an as input and computes an (approximate) solution as its . A central example of an in is . By applying an appropriate optimization method to , we obtain a concrete learning , , . \\\\ See also: , .", "color": "#9be87c", "value": 24, "inDeg": 19}, {"id": "convexopt", "label": "convex optimization", "title": "optimization studies the formulation, properties, and efficient solution methods for . A (defined on the ) consists of a and a constraint set for the optimization variable . It can be written compactly as Alternatively, a can be expressed in terms of constraint as _{ ^{ }} & f( ) \\\\ & g_{ }( ) 0, =1,\\, ,\\,k. [H] [>=stealth, scale=1.0] (-3,0) -- (5.2,0) node[below] { }; (0,-0.2) -- (0,4.2) node[left] { }; plot ({ },{exp(- )}); (-1,3) -- (-1,{exp(1)}) -- plot[domain=-1:3] ({ },{exp(- )}) -- (3,3) -- cycle; (0,1) circle (1.6pt) node[left] { }; plot ({ },{(2/exp(1)) - (1/exp(1))* }); (1,{1/exp(1)}) circle (1.2pt); at (2.6,2.5) { }; [below,yshift=-3pt] at (0,-0.2) { }; {A can be represented by a set that consists of objective values and constraint values that are achievable, i.e., by some . The optimal value of the is the smallest for which . } The formulation lends, in turn, to the form of with the set \\{ ( ,t) & ^{ } : f( ) t, \\, \\\\ & g_{ }( ) c_{ }, \\, = 1,\\, ,\\,k, ^{ } \\}. It can be shown that, since are , is a set . The set fully characterizes the ~ and can be interpreted as the of the ~ over the feasible region defined by the constraint . \\\\ See also: , , .", "color": "#e8d87c", "value": 7, "inDeg": 0}, {"id": "newtonmethod", "label": "Newton's method", "title": "Newton's method is an iterative for finding local or of a . Like , Newton's method also computes a new estimate by optimizing a local approximation of around the current estimate . In contrast to , which use the to build a local linear approximation, Newton's method uses the to build a local quadratic approximation. In particular, starting from an initial estimate , Newton's method iteratively updates the estimate according to Here, is the , and is the of the . Since using a as local approximation is more accurate than using a linear (which is a special case of a ), Newton's method tends to converge faster than (see Fig. ). However, this faster comes at the increased computational complexity of the . Indeed, each of Newton's method requires the inversion of the . [H] [samples=200,smooth] (-5,-2) rectangle (5,5); plot[domain=0:360] ({1.5*cos( )*sqrt(20/(sin(2* )+2))},{1.5*sin( )*sqrt(20/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(16/(sin(2* )+2))},{1.5*sin( )*sqrt(16/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(12/(sin(2* )+2))},{1.5*sin( )*sqrt(12/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(8/(sin(2* )+2))},{1.5*sin( )*sqrt(8/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(4/(sin(2* )+2))},{1.5*sin( )*sqrt(4/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(1/(sin(2* )+2))},{1.5*sin( )*sqrt(1/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(0.0625/(sin(2* )+2))},{1.5*sin( )*sqrt(0.0625/(sin(2* )+2))}); (-3.5,4.5) -- (-3.3,3.8); (-3.3,3.8) -- (-3,3.1); (-3,3.1) -- (-2.6,2.4); (-2.6,2.4) -- (-2.1,1.8); (-2.1,1.8) -- (-1.5,1.3); (-1.5,1.3) -- (-0.9,0.9); (-0.9,0.9) -- (-0.4,0.5); (-0.4,0.5) -- (-0.1,0.2); at (-3.5,4.5) {start}; at (0.5,3) { }; (-3.5,4.5) -- (-2,2.5); (-2,2.5) -- (-0.8,0.8); (-0.8,0.8) -- (0,0.1); at (1.5,4) {Newton's method}; at (0,0) [circle,fill,inner sep=1pt,label=below: ] {}; {Comparison of (blue) and Newton's method (red) paths toward the of a . } See also: , , , .", "color": "#9be87c", "value": 15, "inDeg": 0}, {"id": "hilbertspace", "label": "Hilbert space", "title": "A Hilbert space is a complete inner product space. Thus, is a equipped with an inner product . The inner product induces a via . Furthermore, is complete in the sense that every in converges to a limit that is also contained in . [H] [scale=3] (0,0) circle (1); (0,0) -- (1,0) node[below right] { }; (0,0) -- ({cos( )},{sin( )}) node[above] { }; (P) at ({cos( )},0); ({cos( )},{sin( )}) -- (P); (0,0) -- (P) node[pos=0.5,below] { }; ( ) -- (P) -- ( ); at ({cos(- )},{sin(- )}) { }; {For two unit- the inner product is the expansion coefficient for the of onto the spanned by . The absolute value measures the of this . } One important example of a Hilbert space is the with the inner product . \\\\ See also: .", "color": "#e8d87c", "value": 10, "inDeg": 3}, {"id": "cauchysequence", "label": "Cauchy sequence", "title": "A Cauchy is a in a such that the elements become arbitrarily close to each other eventually. In other words , Fig.\\ shows a Cauchy in the of rational numbers. [H] [x=1cm,y=4cm] (-0.3,{ - }) rectangle ( +0.6,{ + }); (4.5,{ - }) -- (4.5,{ + }) node[above, right] { }; (-0.3, ) -- ( +0.6, ) node[right] { }; (0,1.0000) circle (1.2pt) node [right] { }; (1,1.5000) circle (1.2pt); (2,1.4167) circle (1.2pt); (3,1.4142) circle (1.2pt); (4,1.41421) circle (1.2pt); (5,1.4142136) circle (1.2pt); (6,1.41421356) circle (1.2pt); ( ,0.88) -- ( ,1.655); at ( ,0.8) { }; at (5,0.9) { }; {A Cauchy in the . This is generated by a used to approximate . For all , the elements lie within a band of width . Note that the does not converge in , since . } See also: , .", "color": "#e8d87c", "value": 6, "inDeg": 3}, {"id": "nonexpansiveop", "label": "non-expansive operator", "title": "An defined on a is called non-expansive if it does not increase distances. In other words, {2} {2} , ' . See also: , .", "color": "#e8d87c", "value": 5, "inDeg": 1}, {"id": "fixedpointiter", "label": "fixed-point iteration", "title": "A fixed-point is an iterative method for solving an . It constructs a by repeatedly applying an , i.e., ^{( +1)} = ^{( )} =0, \\,1, \\, . The is chosen such that any of its fixed points is a solution to the given . For example, given a and , the fixed points of the coincide with the minimizers of . In general, for a given with solution , there are many different whose fixed points are . Clearly, we should use an in that reduces the distance to a solution such that { { ^{( +1)} - }{2}}_{ { }{=} { ^{( )} - }{2}} { ^{( )} - }{2}. Thus, we require to be at least a , i.e., the should not result in worse that have a larger distance to a solution . Furthermore, each should also make some progress, i.e., reduce the distance to a solution . This requirement can be made precise using the notion of a , . The is a if, for some , {2} {2} , '. For a , the fixed-point generates a that converges quite rapidly. In particular , { ^{( )} - }{2} ^{ } { ^{(0)} - }{2}. Here, is the distance between the initialization and the solution . It turns out that a fixed-point with a firmly is guaranteed to converge to a fixed-point of . Fig. depicts examples of a firmly , a , and a . All of these are defined on the 1-D space . Another example of a firmly is the of a , . {rgb}{0.0, 0.5, 0.0} [H] [scale=1.5] (-2,0) -- (2,0) node[right] { }; (0,-2) -- (0,2) node[above] { }; at (2.1,2.2) { }; at (1.9,-1.5) { }; at (1.5,1.2) { }; (1,-2) -- (1,2); (-2,1) -- (2,1); (-2,-1) -- (2,-1); (-1,-2) -- (-1,2); at (1,0) { }; at (0,-1) { }; plot( ,{0.5* + 1}); plot( ,{- }); plot( ,{-1}); plot( ,{ }); plot( ,{1}); {Example of a , a firmly , and a . } See also: , , , , , , .", "color": "#e8d87c", "value": 19, "inDeg": 8}, {"id": "ergraph", "label": "Erd s–R\\'enyi graph (ER graph)", "title": "An ER {Erd s–R\\'enyi graph (ER graph)} , is a for defined over a given node set . One way to define the ER is via the collection of binary , for each pair of different nodes . A specific of an ER contains an edge if and only if . The ER is parameterized by the number of nodes and the . \\\\ See also: , , , , , .", "color": "#e8d87c", "value": 8, "inDeg": 2}, {"id": "attack", "label": "attack", "title": "An attack on an system refers to an intentional action—either active or passive—that compromises the system's integrity, availability, or confidentiality. Active attacks involve perturbing components such as (via ) or communication links between within an application. Passive attacks, such as , aim to infer without modifying the system. Depending on their goal, we distinguish among , attacks, and . \\\\ See also: , , , , .", "color": "#9be87c", "value": 14, "inDeg": 6}, {"id": "privattack", "label": "privacy attack", "title": "A privacy on an system aims to infer of individuals by exploiting partial access to a trained . One form of a privacy is .\\\\ See also: , , , , .", "color": "#9be87c", "value": 13, "inDeg": 6}, {"id": "epigraph", "label": "epigraph", "title": "The epigraph of a real-valued is the set of points lying on or above its (see Fig. ), i.e., A is if and only if its epigraph is a set , . [H] [scale=1.0] [ axis lines = middle, xlabel = , ylabel = {}, xmin=-2, xmax=2, ymin=0, ymax=4.5, samples=100, domain=-1.5:1.5, thick, width=8cm, height=6cm, grid=none, axis on top, ] node [pos=0.85, anchor=south west, xshift=5pt] { }; ; (axis cs:-1.5,4) -- (axis cs:1.5,4); [ blue!20, opacity=0.6, draw=none, ] fill between [ of=f and top, soft clip={domain=-1.5:1.5}, ]; at (axis cs:-1.0,2.3) { }; {Epigraph of the (i.e., the shaded area). } See also: , .", "color": "#e8d87c", "value": 5, "inDeg": 2}, {"id": "nullspace", "label": "nullspace", "title": "The nullspace of a , denoted by , is the set of all such that Consider a method that uses the to transform a of a into a new . The nullspace characterizes all directions in the original along which the transformation remains unchanged. In other words, adding any from the nullspace to a does not affect the transformed representation . This property can be exploited to enforce invariances in the (computed from ). Fig.\\ illustrates one such invariance. It shows rotated versions of two handwritten digits, which approximately lie along 1-D curves in the original . These curves are aligned with a direction . To ensure that the trained is invariant to such rotations, we can choose the transformation such that . This ensures that , and hence the resulting , is approximately insensitive to rotations of the input image. [H] { Rotated handwritings of two different digits. The rotations are approximately aligned along straight lines parallel to the . For a binary distinguishing between these digits, a natural choice is a linear with a whose nullspace contains , i.e., . } See also: , , . \\\\ Python demo: {click me}", "color": "#e87c7c", "value": 10, "inDeg": 0}, {"id": "maximum", "label": "maximum", "title": "The maximum of a set of real numbers is the greatest element in that set, if such an element exists. A set has a maximum if it is bounded above and attains its . \\\\ See also: .", "color": "#9be87c", "value": 11, "inDeg": 10}, {"id": "supremum", "label": "supremum (or least upper bound)", "title": "The supremum of a set of real numbers is the smallest number that is greater than or equal to every element in the set. More formally, a real number is the supremum of a set if: 1) is an upper bound of ; and 2) no number smaller than is an upper bound of . Every non-empty set of real numbers that is bounded above has a supremum, even if it does not contain its supremum as an element .", "color": "#9be87c", "value": 1, "inDeg": 1}, {"id": "discrepancy", "label": "discrepancy", "title": "Consider an application with represented by an . methods use a discrepancy to compare from at nodes , connected by an edge in the . \\\\ See also: , , .", "color": "#9be87c", "value": 9, "inDeg": 2}, {"id": "FedRelax", "label": "federated relaxed (FedRelax)", "title": "An . \\\\ See also: , .", "color": "#9be87c", "value": 2, "inDeg": 0}, {"id": "fedavg", "label": "federated averaging (FedAvg)", "title": "FedAvg refers to a family of iterative . It uses a server-client setting and alternates between clientwise retraining, followed by the aggregation of updated at the server . The local update at client at time starts from the current provided by the server and typically amounts to executing few iterations of . After completing the local updates, they are aggregated by the server (e.g., by averaging them). Fig. illustrates the execution of a single iteration of FedAvg. [H] [>=Stealth, node distance=1cm and 1.5cm, every node/.style={font= }] = [circle, fill=black, minimum size=6pt, inner sep=0pt] = [circle, draw=black, minimum size=6pt, inner sep=0pt] (label1) at (0,3.5) {broadcast}; (label2) {local update}; (label3) {aggregate}; (s1) at (label1 |- 0,2.5) {}; (c1l) at ( ) {}; (c1r) at ( ) {}; (dots1) at ( ) { }; (s1) -- (c1l) node[midway,left] { }; (s1) -- (c1r) node[midway,right] { }; (s1) -- (dots1); (s2) at (label2 |- 0,2.5) {}; (c2l) at ( ) {}; (c2r) at ( ) {}; (dots2) at ( ) { }; ; ; (s3) at (label3 |- 0,2.5) {}; ; (c3l) at ( ) {}; (c3r) at ( ) {}; (dots3) at ( ) { }; (c3l) -- (s3) node[midway,left] { }; (c3r) -- (s3) node[midway,right] { }; (dots3) -- (s3); {Illustration of a single iteration of FedAvg, which consists of broadcasting by the server, performing local updates at clients, and aggregating the updates by the server. } See also: , , , .", "color": "#9be87c", "value": 6, "inDeg": 1}, {"id": "FedGD", "label": "federated gradient descent (FedGD)", "title": "An that can be implemented as message passing across an . \\\\ See also: , , , , .", "color": "#9be87c", "value": 5, "inDeg": 0}, {"id": "FedSGD", "label": "federated stochastic gradient descent (FedSGD)", "title": "An that can be implemented as message passing across an . \\\\ See also: , , , , , .", "color": "#9be87c", "value": 6, "inDeg": 0}, {"id": "hfl", "label": "horizontal federated learning (HFL)", "title": "HFL uses constitut\\-ed by different but uses the same to characterize them . For example, weather forecasting uses a network of spatially distributed weather (observation) stations. Each weather station measures the same quantities, such as daily temperature, air pressure, and precipitation. However, different weather stations measure the characteristics or of different spatiotemporal regions. Each spatiotemporal region represents an individual , each characterized by the same (e.g., daily temperature or air pressure).\\\\ See also: , , .", "color": "#9be87c", "value": 7, "inDeg": 1}, {"id": "dimred", "label": "dimensionality reduction", "title": "Dimensionality reduction refers to methods that learn a transformation of a (typically large) set of raw into a smaller set of informative . Using a smaller set of is beneficial in several ways: It typically reduces the of , as reducing the number of often reduces the of a . Using fewer means less computation for the training of . As a case in point, methods need to invert a whose size is determined by the number of . Dimensionality reduction is also instrumental for visualization. For example, we can learn a transformation that delivers two , which we can use, in turn, as the coordinates of a . Fig.\\ depicts the of handwritten digits that are placed using transformed . Here, the are naturally represented by a large number of greyscale values (one value for each pixel). [H] [scale=1] (-0.5,0) -- (5.5,0) node[right] { }; (0,-0.5) -- (0,4.5) node[above] { }; / / in { 1.2/0.5/3, 0.8/2.0/8, 2.5/1.8/1, 3.8/3.5/6, 4.2/0.7/9, 2.8/3.0/7, 1.5/3.8/2 }{ at ( , ) { }; } {Example of dimensionality reduction: High-dimensional image data (e.g., high-resolution images of handwritten digits) embedded into 2-D using learned and visualized in a .} See also: , , , , .", "color": "#e87c7c", "value": 22, "inDeg": 7}, {"id": "diagnosis", "label": "diagnosis", "title": "Consider an -based method that resulted in a trained (or learned ) . We can diagnose the method by comparing the with the incurred by on the and the . [H] [ycomb] plot coordinates{(0,3)}; [below] at (0,0) { } ; plot coordinates{(5,5)}; [below] at (5,0) { } ; (-1,2) -- (7,2) node[right,text width=5cm]{ \\\\ (e.g., , existing methods, or human performance)}; {We can diagnose an -based method by comparing its with its . Ideally, both are on the same level as a . } See also: , , , .", "color": "#e87c7c", "value": 13, "inDeg": 0}, {"id": "ml", "label": "machine learning (ML)", "title": "ML methods aim to learn (or find) a useful out of a . The learned is used to compute a for the of a . The learning process is guided by a quantitative of the incurred when the obtained from the learned differ from the actual . Different ML methods use different design choices for this quantitative (or ) as well as different choices for the and the (i.e., their and ) . [H] [ node distance=1cm, auto, punkt/.style={ rectangle, rounded corners, draw=black, very thick, text width=3cm, minimum height=1cm, align=center } ] (OR) at (0.00, 1.50); (a) at (OR) {}; (b) at (OR) {}; (c) at (OR) {}; (a.-150) arc (-150:{-150+120}:3cm); (b.160) arc (160:{160+50}:4cm); (c.20) arc (20:{160}:4cm); ([shift={(-30:6cm)}]OR) arc (-30:{20}:6cm); (OR) --([shift={(-30:6cm)}]OR); (OR) --([shift={(20:6cm)}]OR); (OR) -- (c.20); (OR) -- (c.160); (OR) -- (b.160); (OR) -- (b.210); (OR) -- (a.-150); (OR) -- (a.-30); (data) {observations}; (data1) { }; (dummy) {}; (hypothesis) { }; (t) {make a } ; (g) {assess and adapt} ; (g1) { } ; (g6) {inference} ; (g3) { } ; [->,line width=0.5mm] (hypothesis.east) to [out=0,in=90] (t.north); [->,line width=0.5mm] (t.south) to [out=270,in=0] (data.east); [->,line width=0.5mm] (data.west) to [out=180,in=270] (g.south); [->,line width=0.5mm] (g.north) to [out=90,in=180] (hypothesis.west); {ML learns a out of a (or ) by trying to minimize the incurred by the for the of . The are computed solely from the of the .} Another distinction between ML methods is how they access during learning. For example, some methods have access to a complete during , which allows them to use , . In contrast, methods access sequentially and, in turn, update the learned whenever a new arrives , , . \\\\ See also: , , , , .", "color": "#e87c7c", "value": 147, "inDeg": 131}, {"id": "featlearn", "label": "feature learning", "title": "Consider an application with characterized by raw . learning refers to the task of learning a that reads in the of a and delivers new from a new . Different learning methods are obtained for different design choices of , for a of potential , and for a quantitative of the usefulness of a specific . For example, uses , with , and a measures the usefulness of a specific by the linear reconstruction error incurred on a such that \\\\ See also: , , , .", "color": "#e87c7c", "value": 20, "inDeg": 10}, {"id": "encoder", "label": "encoder", "title": "See .", "color": "#e87c7c", "value": 2, "inDeg": 1}, {"id": "autoencoder", "label": "autoencoder", "title": "An autoencoder is an method that simultaneously learns an and a decoder . Different autoencoders use different , e.g., with different architectures. The special case of an autoencoder using ( -valued) for results in . [H] [>=Latex, thick, node distance=1.6cm] (x) { }; (enc) { }; (z) { }; (dec) { }; (xhat) { }; (x) -- (enc); (enc) -- node[above] { } (z); (z) -- (dec); (dec) -- node[above] { } (xhat); {Autoencoder with an mapping and a decoder mapping .} The of the and decoder can be implemented via using a that measures the deviation of the reconstructed from the original . \\\\ See also: , , .", "color": "#e87c7c", "value": 17, "inDeg": 3}, {"id": "modelparallelism", "label": "model parallelism", "title": "parallelism refers to a particular class of distributed used to train an . Here, different store and process disjoint subsets of the . This approach contrasts with , where each maintains a full replica of the while processing disjoint subsets of the global . parallelism allows us to train an whose cannot fit into the memory of a single . One key application of parallelism is the training of extremely large , such as with billions of . \\\\ See also: .", "color": "#e87c7c", "value": 13, "inDeg": 2}, {"id": "dataparallelism", "label": "data parallelism", "title": "parallelism refers to a widely used class of distributed for training an . Here, each participating stores a full replica of the but processes a disjoint subset of the global . Compared to , which distributes the across , parallelism distributes the computational workload associated with large . It is especially effective when the fits into the memory of a single , but the or complexity would be prohibitive without parallel processing. \\\\ See also: , .", "color": "#e87c7c", "value": 11, "inDeg": 1}, {"id": "perplexity", "label": "perplexity", "title": "The perplexity of an is defined as . \\\\ See also: .", "color": "#e8d87c", "value": 2, "inDeg": 0}, {"id": "vfl", "label": "vertical federated learning (VFL)", "title": "In VFL, different have access to different of the same set of . Formally, the underlying global is We denote by , for , the complete for the . Each observes only a subset of , resulting in a with Some of the may also have access to the , for , of the global (see Fig. ). [H] [every node/.style={anchor=base}] / in {1/1, 2/2, 4/ } { {-1.2*( -1)} (x 1) at (0, ) { }; (x 2) at (1.6, ) { }; (dots ) at (3.2, ) { }; (x 3) at (4.8, ) { }; (y ) at (6.4, ) { }; } (-0.6,0.6) rectangle (6.9,-4.2); at (3.1,0.9) { }; (-0.9,0.9) rectangle (2.1,-4.0); at (0.25,1.0) { }; ( ) rectangle ( ); at ( ) { }; {VFL uses that are derived from the of a common global . The differ in the choice of used to characterize the . } One potential application of VFL is to enable collaboration between different healthcare providers. Each provider collects distinct types of measurements—such as blood values, electrocardiography, and lung X-rays—for the same patients. Another application is a national social insurance system, where health records, financial indicators, consumer behavior, and mobility are collected by different institutions. VFL enables joint learning across these parties while allowing well-defined levels of . We can view VFL as a specific form of . \\\\ See also: , , .", "color": "#9be87c", "value": 13, "inDeg": 2}, {"id": "interpretability", "label": "interpretability", "title": "An method is interpretable for a human user if they can comprehend the decision process of the method. One approach to develop a precise definition of interpretability is via the concept of simulatability, i.e., the ability of a human to mentally simulate the behavior , , , , . The idea is as follows: If a human user understands an method, then they should be able to anticipate its on a . We illustrate such a in Fig. , which also depicts two learned and . The method producing the is interpretable to a human user familiar with the concept of a . Since corresponds to a , the user can anticipate the of on the . In contrast, the method delivering is not interpretable, because its behavior is no longer aligned with the user’s . [H] [x=1.5cm, y=1cm] (0,0.5) -- (7.7,0.5) node[below, xshift=-1cm] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ + }); plot ({ },{ + -( -4)*0.5}); at (7.2, { 7.2 + }) { }; at (7.2, { 7.2 + - 0.5*(7.2 - 4)}) { }; / / / in { 1.2/1.0/blue/6, 1.4/1.0/blue/6, 1.7/1.0/blue/6, 2.2/3.9/blue/12, 2.6/4.2/blue/12, 3.0/4.4/blue/12 }{ (pt) at ( , ); at (pt) {}; }, color= , thick] ( , { + }) -- (pt); } / / / in { 5.7/2.6/red/12, 5.9/2.6/red/12, 6.2/2.6/red/12 }{ (pt) at ( ,{ + }); at (pt) {}; } (4.2, 1.7) circle (0.1cm) node [black,xshift=0.2cm,anchor=west] { }; (4.2, 1.2) circle (0.1cm) node [black,xshift=0.2cm,anchor=west] { }; {We can assess the interpretability of trained and by comparing their to pseudo- generated by a human user for . } The notion of interpretability is closely related to the notion of , as both aim to make methods more understandable for humans. In the context of Fig. , interpretability of an method requires that the human user can anticipate its on an arbitrary . This contrasts with , where the user is supported by external —such as saliency or reference examples from the —to understand the of on a specific . \\\\ See also: , , , .", "color": "#e87c7c", "value": 18, "inDeg": 3}, {"id": "multitask learning", "label": "multitask learning", "title": "Multitask learning aims to leverage relations between different . Consider two obtained from the same of webcam snapshots. The first task is to predict the presence of a human, while the second task is to predict the presence of a car. It may be useful to use the same structure for both tasks and only allow the of the final output to be different. \\\\ See also: , , , , .", "color": "#e87c7c", "value": 7, "inDeg": 2}, {"id": "learningtask", "label": "learning task", "title": "Consider a consisting of multiple . For example, can be a collection of images in an image database. A learning task is defined by specifying those properties (or attributes) of a that are used as its and . Given a choice of and , a learning task leads to an instance of and can thus be represented by the associated for . Importantly, multiple distinct learning tasks can be constructed from the same by selecting different sets of and (see Fig. ). [H] [t]{0.95 } [t]{0.45 } Task 1 ( ): \\\\ are the RGB values of all image pixels, and the is the number of cows depicted. [t]{0.45 } Task 2 ( ): \\\\ include the average green intensity of the image, and the indicates whether cows should be moved to another location (i.e., yes/no). {Two learning tasks constructed from a single image . These tasks differ in selection and choice of (i.e., the objective), but are both derived from the same .} Different learning tasks arising from the same underlying are often coupled. For example, when a is used to generate , statistical dependencies among different induce dependencies among the corresponding learning tasks. In general, solving learning tasks jointly, e.g., using methods, tends to be more effective than solving them independently (thereby ignoring dependencies among learning tasks) , , . \\\\ See also: , .", "color": "#e87c7c", "value": 15, "inDeg": 2}, {"id": "explainability", "label": "explainability", "title": "We define the (subjective) explainability of an method as the level of simulatability of the delivered by an system to a human user. Quantitative of the (subjective) explainability of a trained can be constructed by comparing its with the provided by a user on a , . Alternatively, we can use for and measure the explainability of a trained via the conditional (or differential) of its , given the user's , . \\\\ See also: , .", "color": "#9be87c", "value": 13, "inDeg": 3}, {"id": "lime", "label": "local interpretable model-agnostic explanations (LIME)", "title": "Consider a trained (or learned ) , which maps the of a to the . LIME is a technique for explaining the behavior of , locally around a with . The is given in the form of a local approximation of (see Fig. ). This approximation can be obtained by an instance of with a carefully designed . In particular, the consists of with centered around and the (pseudo-) . Note that we can use a different for the approximation from the original . For example, we can use a to locally approximate a . Another widely used choice for is the . [H] [ axis lines=middle, xlabel={ }, ylabel={ }, xtick= , ytick= , xmin=0, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.85, above right,yshift=3pt] { }; coordinates {(3,0) (3,6)}; node[pos=0.9, above] { }; coordinates {(3, {2 + sin(deg(3))})}; at (axis cs:3,-0.3) { }; {To explain a trained , around a given , we can use a local approximation . } See also: , , , , , , , .", "color": "#e87c7c", "value": 15, "inDeg": 3}, {"id": "linmodel", "label": "linear model", "title": "Consider an application involving , each represented by a numeric . A linear defines a consisting of all real-valued from to such that \\{ : ^{ } ( ) = ^{ } ^{ } \\}. Each value of defines a different , corresponding to the number of used to compute the . The choice of is often guided not only by (e.g., fewer features reduce computation) and (e.g., more features typically reduce and ), but also by . A linear using a small number of well-chosen is generally considered more interpretable , . The linear is attractive because it can typically be trained using scalable , . Moreover, linear often permit rigorous statistical analysis, including fundamental limits on the achievable . They are also useful for analyzing more complex nonlinear such as . For instance, a can be viewed as the composition of a —implemented by the input and hidden —and a linear in the . Similarly, a can be interpreted as applying a one-hot-encoded based on , followed by a linear that assigns a to each region. More generally, any trained that is at some can be locally approximated by a . Fig.~ illustrates such a local linear approximation, defined by the . Note that the is only defined where is . To ensure in the context of , one may prefer whose associated is Lipschitz . A classic result in mathematical analysis—Rademacher’s Theorem—states that if is Lipschitz with some constant over an open set , then is almost everywhere in . [H] [x=0.5cm] [ hide axis, xmin=-3, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.5, above right, yshift=3pt] { }; node[pos=0.95, above right] { }; coordinates {(6, {2 + sin(deg(6))})}; coordinates {(6,0) (6,2.4)}; at (axis cs:6, -0.2) { }; {-1.5} {3} {2 + sin(deg( ))} {2 + sin(deg( ))} coordinates {( , ) ( , )}; (axis cs: , ) -- (axis cs: ,0); (axis cs: , ) -- (axis cs: ,0); (axis cs: , ) -- (axis cs:0, ); (axis cs: , ) -- (axis cs:0, ); (axis cs: ,-0.4) -- node[below] { } (axis cs: ,-0.4); (axis cs:-2.4, ) -- node[left] { } (axis cs:-2.4, ); {A trained that is at a point can be locally approximated by a . This local approximation is determined by the .} See also: , , , , .", "color": "#e87c7c", "value": 55, "inDeg": 25}, {"id": "operator", "label": "operator", "title": "An operator is a whose and have a specific mathematical structure such as a , a , or a , . Many methods involve operators whose and are . \\\\ See also: , , .", "color": "#e8d87c", "value": 16, "inDeg": 8}, {"id": "contractop", "label": "contractive operator", "title": "An is a contraction (or contractive) if, for some , , {2} {2} , ' ^{ }. The notion of a contractive generalizes naturally from to arbitrary . [H] [>=Latex, font= ] { space/.style={draw, thick, circle, minimum size=4.0cm}, pt/.style={circle, inner sep=1.5pt, draw, fill=black}, maparrow/.style={->, very thick}, distline/.style={dashed, thick} } (X) at (0,0) {}; (x1) at (-1.0,0.8); (x2) at ( 1.0,0.8); (Tx1) at (-0.5,0.1); (Tx2) at ( 0.5,0.1); at (x1) {}; at (x2) {}; (TX1) at (Tx1) {}; (TX2) at (Tx2) {}; at ( ) { }; at ( ) { }; (x1) -- (x2) node[midway, above=4pt] { }; (Tx1) -- (Tx2) node[midway, below=4pt] { }; (xs) at (0,-0.9); (XS) at (xs) {}; at (0,-1.6) { }; {A contractive has a unique fixed point with . For any two points in the same space, the distance between their images and is strictly smaller.} Intuitively, a contractive brings any two points from its closer together by at least a factor of . \\\\ See also: , .", "color": "#e8d87c", "value": 6, "inDeg": 3}, {"id": "proxop", "label": "proximal operator", "title": "Given a , we define its proximal as , As illustrated in Fig. , evaluating the proximal amounts to minimizing a penalized variant of . The is the scaled squared to a given (which is the input to the proximal ). The proximal can be interpreted as a of the , which is defined for a . Indeed, taking a with at the current is the same as applying the proximal of the and using . [H] [scale=0.8] plot ( , {(1/4)* }) node[above right] { }; plot ( , {2*( - 2)*( - 2)}) node[below right] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; {The proximal updates a by minimizing a penalized version of the . The is the scaled squared between the optimization variable and the given . } See also: , , .", "color": "#e8d87c", "value": 16, "inDeg": 6}, {"id": "proximable", "label": "proximable", "title": "A for which the can be computed efficiently is sometimes referred to as proximable or simple . \\\\ See also: , , .", "color": "#e8d87c", "value": 3, "inDeg": 0}, {"id": "connected", "label": "connected", "title": "An is connected if, for every non-empty subset , we can find at least one edge connecting a node in with some node in . We illustrate two examples of in Fig. . [H] (A1) at (0, 1.5) {}; ; (B1) [below right=0.8cm and 0.5cm of A1] {}; (C1) [below left=0.8cm and 0.5cm of A1] {}; [line width=1 pt] (A1) -- (B1); at (0, -1) {(a)}; [xshift=3.5cm] (A2) at (0, 1.5) {}; ; (B2) [below right=0.8cm and 0.5cm of A2] {}; (C2) [below left=0.8cm and 0.5cm of A2] {}; [line width=1 pt] (A2) -- (B2); [line width=1 pt] (B2) -- (C2); at (0, -1) {(b)}; {(a) A that is disconnected. (b) A that is connected. } See also: , .", "color": "#e8d87c", "value": 6, "inDeg": 3}, {"id": "earlystopping", "label": "early stopping", "title": "Consider an -based method that uses an iterative (such as ) to learn by minimizing the on a given . Early stopping refers to terminating the even if they still substantially decrease the on the . Instead of monitoring the (which is the on the ), early stopping monitors the incurred by the in each . Early stopping can be interpreted as an implementation of via pruning. Indeed, terminating an iterative after a small number of restricts the set of that can be reached from the initialization (see Fig.\\ ). [H] [>=Stealth, scale=2] (0,0) circle (0.6pt) node[above] { }; at (-0.4,0) { }; at (-1.2,0) { }; at (-2,0) { }; (0,0) ellipse (0.8 and 0.4); (0,0) ellipse (1.6 and 0.8); (0,0) -- (0.8,0.) node [pos=0.6,above] { step}; (0.0,0.0) -- (0,-0.8) node [pos=0.9,right] { steps}; {A for using a defines a nested of effective . The effective is determined by all that can be reached from the initialization within . } See also: , , .", "color": "#e87c7c", "value": 16, "inDeg": 0}, {"id": "statasp", "label": "statistical aspects", "title": "By statistical aspects of an method, we refer to (properties of) the of its output under a for the fed into the method. \\\\ See also: , , , .", "color": "#9be87c", "value": 8, "inDeg": 4}, {"id": "compasp", "label": "computational aspects", "title": "By computational aspects of an method, we mainly refer to the computational resources required for its implementation. For example, if an method uses iterative optimization techniques to solve , then its computational aspects include: 1) how many arithmetic operations are needed to implement a single iteration (i.e., a ); and 2) how many iterations are needed to obtain useful . One important example of an iterative optimization technique is . \\\\ See also: , , , , .", "color": "#9be87c", "value": 8, "inDeg": 3}, {"id": "zerooneloss", "label": "loss", "title": "The measures the quality of a that delivers a (e.g., via thresholding ) for the of a with . It is equal to if the is correct, i.e., when . It is equal to if the is wrong, i.e., when . \\\\ See also: , , , , , , .", "color": "#e87c7c", "value": 9, "inDeg": 2}, {"id": "probability", "label": "probability", "title": "We assign a probability value, typically chosen in the interval , to each that can occur in a , , , . \\\\ See also: , .", "color": "#e8d87c", "value": 31, "inDeg": 29}, {"id": "underfitting", "label": "underfitting", "title": "Consider an method applying to learn a that minimizes the on a given . The method is said to underfit if it fails to achieve a sufficiently low on the . Underfitting typically occurs when the chosen is too simple to capture the underlying relationship between and . [H] [scale=1.0] plot({ },{ + }); at (6.5,{ 6.5+ }) { }; / / in {1/0.6/2.4, 2/1.2/2.1, 3/1.8/2.0, 4/2.4/2.3, 5/3.0/3.1, 6/3.6/4.0, 7/4.2/5.2, 8/4.8/6.0, 9/5.4/6.3, 10/6.0/6.1} { (p ) at ( , ) {}; ( ,{ + }) -- (p ); } {No linear can capture the relationship between and for the depicted . Thus, any method that uses a will underfit this .} For example, an method using a on with a highly nonlinear relationship between and will not be able to learn a with small average on the , let alone a low . \\\\ See also: , , , .", "color": "#e87c7c", "value": 14, "inDeg": 1}, {"id": "overfitting", "label": "overfitting", "title": "Consider an method that uses to learn a with the on a given . Such a method is overfitting the if it learns a with a on the that a significantly smaller than the average outside the . In other words, if a method overfits it has a large . \\\\ See also: , , , .", "color": "#e87c7c", "value": 23, "inDeg": 13}, {"id": "diffusionmethod", "label": "diffusion method", "title": "A diffusion method is a generative method that trains a to approximate the reversal of a gradual stochastic corruption process . Diffusion methods train using a combination of a forward (diffusion) process and a learned reverse . In the forward process, random noise is incrementally added to clean representations of a , such as an image, audio recording, or other types of . Similar to a , the trained can be applied to a noisy representation of a . The resulting is a denoised representation. What sets diffusion methods apart from generic is the gradual nature of the corruption process used for .", "color": "#e87c7c", "value": 9, "inDeg": 1}, {"id": "denautoencoder", "label": "denoising autoencoder", "title": "A denoising extends the basic by perturbing (e.g., by adding noise) the (or ) before feeding it into the itself . [t] {A denoising reads in a corruped (noisy) representation of a (left) and computes a for the clean representation (right).} Once trained, we can use a denoising to denoise a corrupted representation of a (see Fig.\\ ). \\\\ See also: , .", "color": "#e87c7c", "value": 7, "inDeg": 1}, {"id": "normaldist", "label": "normal distribution", "title": "See .", "color": "#e8d87c", "value": 2, "inDeg": 1}, {"id": "gaussrv", "label": "Gaussian random variable (Gaussian RV)", "title": "A standard is a real-valued with , , p(x) = { } \\,(-x^2/2). Given a standard , we can construct a general with and via . The of a is referred to as , denoted by . \\\\ A random with and can be constructed as , , where is a of standard , and is any satisfying . The of a random is referred to as the , denoted by . \\\\ We can interpret a random as a indexed by the set . A is a over an arbitray index set such that any restriction to a finite subset yields a random . \\\\ are widely used in the statistical analysis of methods. Their significance arises partly from the which provides conditions under which the average of many independent (not necessarily themselves) tends toward a . \\\\ The is also distinct in that it represents . Among all -valued with a given , the maximizes . This makes a natural choice for capturing or the lack of (domain) knowledge. \\\\ See also: , , , , .", "color": "#e8d87c", "value": 29, "inDeg": 9}, {"id": "gaussian", "label": "Gaussian", "title": "See .", "color": "#e8d87c", "value": 4, "inDeg": 3}, {"id": "clt", "label": "central limit theorem (CLT)", "title": "Consider a sequence of , for , each with zero and finite . The CLT states that the normalized sum converges in distribution to a with zero and as . One elegant way to derive the CLT is via the of the normalized sum . Let (with the imaginary unit ) be the common of each sum and , and let denote the of . Define an acting on such that This captures the effect of recursively adding an and rescaling. Iteratively applying leads to of toward the fixed point which is the of a with zero and . of the CLT allow for dependent or nonidentically distributed . [H] [ width=10cm, height=6cm, xlabel={}, ylabel={}, legend style={at={(0.97,0.97)}, anchor=north west}, domain=-3:3, ylabel style={ yshift=10pt }, samples=400, ymin=-0.2, ymax=1.1, axis lines=middle, clip=false, grid=both, ] ; ; ; ; at (axis cs:-0.08,1.05) { }; at (axis cs: 3.2,0.1) { }; { of normalized sums of for compared to the limit.} See also: , .", "color": "#e8d87c", "value": 13, "inDeg": 2}, {"id": "GaussProc", "label": "Gaussian process (GP)", "title": "A GP is a collection of indexed by input values from some input space such that, for any finite subset , the corresponding have a joint For a fixed input space , a GP is fully specified (or parameterized) by: 1) a ; and 2) a .\\\\ Example: We can interpret the temperature distribution across Finland (at a specific point in time) as the of a GP , where each input denotes a geographic location. Temperature observations from weather stations provide values at specific locations (see Fig. ). A GP allows us to predict the temperature nearby weather stations and to quantify the of these . [H] [ axis equal, hide axis, scale=1.2, xmin=17, xmax=32, ymin=55, ymax=71, clip=true ] table [x=lon, y=lat, col sep=comma] {assets/finland_border.csv}; table [x=lon, y=lat, col sep=comma] {assets/fmi_stations_subset.csv}; (axis cs:19,59) -- (axis cs:25.5,59) node[anchor=west] {longitude (lon)}; (axis cs:19,59) -- (axis cs:19,65.5) node[anchor=south] {latitude (lat)}; {For a given point in time, we can interpret the current temperature distribution over Finland as a of a GP indexed by geographic coordinates and sampled at weather stations. The weather stations are indicated by blue dots. } See also: , , .", "color": "#e8d87c", "value": 11, "inDeg": 1}, {"id": "trustAI", "label": "trustworthy artificial intelligence (trustworthy AI)", "title": "Besides the and , a third main design aspect of methods is their trustworthiness . The EU has put forward seven key requirements (KRs) for trustworthy (which typically build on methods) : [label= )] KR1 – Human agency and oversight; KR2 – Technical and safety; KR3 – Privacy and governance; KR4 – ; KR5 – Diversity, nondiscrimination and fairness; KR6 – Societal and environmental well-being; KR7 – Accountability. See also: , , , , , , .", "color": "#9be87c", "value": 17, "inDeg": 10}, {"id": "sqerrloss", "label": "squared error loss", "title": "The squared error measures the error of a when predicting a numeric from the of a . It is defined as { } ( - _{= } )^{2}. \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 23, "inDeg": 17}, {"id": "projection", "label": "projection", "title": "Consider a subset of the -dimensional . We define the projection of a onto as { } = _{ ' } {2}. In other words, is the in that is closest to . The projection is only well defined for subsets for which the above exists . \\\\ See also: , , .", "color": "#e8d87c", "value": 7, "inDeg": 4}, {"id": "projgd", "label": "projected gradient descent (projected GD)", "title": "Consider an -based method that uses a parameterized with . Even if the of is , we cannot use basic , as it does not take into account constraints on the optimization variable (i.e., the ). Projected extends basic to address this issue. A single iteration of projected consists of first taking a and then projecting the result back onto the . See Fig. for a visual illustration. [H] [scale=0.9] [right] at (-5.1,1.7) { } ; plot ( , {(1/8)* }); [fill] (2.83,1) circle [radius=0.1] node[right] { }; (2.83,1) -- node[midway,above] { } (-1.5,1); (-1.5,1) --(-1.5,-1.5) node [below, left]{ } ; (-1.5,-1.5) -- node[midway,above] {} (1,-1.5) ; [fill] (1,-1.5) circle [radius=0.1] node[below] { }; (1,-1.5) -- (3,-1.5) node[midway, above] { }; {Projected augments a basic with a back onto the constraint set .} See also: , , , , , , , , .", "color": "#e87c7c", "value": 10, "inDeg": 1}, {"id": "diffpriv", "label": "differential privacy (DP)", "title": "Consider some method that reads in a (e.g., the used for ) and delivers some . The could be either the learned or the for specific . DP is a precise of incurred by revealing the . Roughly speaking, an method is differentially private if the of the remains largely unchanged when the of one in the is changed. Note that DP builds on a for an method, i.e., we interpret its as the of an . The randomness in the can be ensured by intentionally adding the of an auxiliary (i.e., adding noise) to the of the method. \\\\ See also: , , , , .", "color": "#e8d87c", "value": 20, "inDeg": 3}, {"id": "robustness", "label": "robustness", "title": "Robustness is a key requirement for . It refers to the property of an system to maintain acceptable performance even when subjected to different forms of perturbations. These perturbations may affect the of a in order to manipulate the delivered by a trained . Robustness also includes the of -based methods against perturbations of the . Such perturbations can occur within . \\\\ See also: , , , .", "color": "#e87c7c", "value": 19, "inDeg": 8}, {"id": "stability", "label": "stability", "title": "Mathematically, an method is a from a given to an . As a case in point, consider an -based method that maps a to the learned , which achieve the average on the . Instead of the learned , the could also be the obtained from the trained . Stability refers to the desirable property of that small changes in the input result in small changes in the . The notion of stability is intimately related to the notion of . In particular, there are formal notions of stability that allow us to bound the (see ). To build intuition, consider the three depicted in Fig. , each of which is equally likely under the same -generating . Since the optimal are determined by this underlying , an accurate method should return the same (or very similar) for all three . In other words, any useful must be robust to variability in from the same , i.e., it must be stable. [H] [ axis lines=none, xlabel={ }, ylabel={}, legend pos=north west, ymin=0, ymax=10, xtick={1,2,3,4,5}, grid style=dashed, every axis plot/.append style={very thick} ] +[only marks,mark=*] coordinates { (1,2) (2,4) (3,3) (4,5) (5,7) }; +[only marks,mark=square*] coordinates { (1,3) (2,2) (3,6) (4,4) (5,5) }; +[only marks,mark=triangle*] coordinates { (1,5) (2,7) (3,4) (4,6) (5,3) }; {Three , , and , each sampled independently from the same -generating . A stable method should return similar when trained on any of these . } See also: , .", "color": "#e87c7c", "value": 21, "inDeg": 3}, {"id": "privprot", "label": "privacy protection", "title": "Consider some method that reads in a and delivers some output . The output could be the learned or the obtained for a specific with . Many important applications involve representing humans. Each is characterized by , potentially a , and a (e.g., a recent medical diagnosis). Roughly speaking, privacy protection means that it should be impossible to infer, from the output , any of the of in . Mathematically, privacy protection requires non-invertibility of the . In general, just making non-invertible is typically insufficient for privacy protection. We need to make sufficiently non-invertible. \\\\ See also: , , , , , , , , .", "color": "#e87c7c", "value": 13, "inDeg": 4}, {"id": "privleakage", "label": "privacy leakage", "title": "Consider an application that processes a and delivers some output, such as the obtained for new . Privacy leakage arises if the output carries information about a private (or sensitive) of a of (such as a human). Based on a for the generation, we can measure the privacy leakage via the between the output and the sensitive . Another quantitative of privacy leakage is . The relations between different of privacy leakage have been studied in the literature (see ). \\\\ See also: , , , .", "color": "#9be87c", "value": 13, "inDeg": 1}, {"id": "probmodel", "label": "probabilistic model", "title": "A probabilistic for the generation of consists of with a joint . This joint typically involves that have to be manually chosen or learned via statistical inference methods such as estimation . \\\\ See also: , , , , , , .", "color": "#e8d87c", "value": 50, "inDeg": 43}, {"id": "probabilitysimplex", "label": "probability simplex", "title": "The simplex is the set of all in with nonnegative entries that sum to one . Each element of represents a of an . \\\\ See also: , , , .", "color": "#e8d87c", "value": 4, "inDeg": 0}, {"id": "crossentropy", "label": "cross-entropy", "title": "Consider a multi-class problem with a and a finite . A with a is represented as a over~ , where denotes the that a randomly chosen with has . A outputs a predicted . The associated cross-entropy is {( , )}{ } - _{ =1}^{ } _{ }\\, _{ }. The cross-entropy quantifies the dissimilarity between the true and the predicted . It is also a of the expected number of bits required to encode drawn from the true when using a coding scheme optimized for the predicted . \\\\ Note that, for binary (with ), the cross-entropy reduces to the when employing a with such that . Moreover, the representation of requires encoding the using the values and . \\\\ See also: , , .", "color": "#e87c7c", "value": 16, "inDeg": 2}, {"id": "bce", "label": "binary cross-entropy (BCE)", "title": "The BCE is the special case of for a binary problem. \\\\ See also: , .", "color": "#e87c7c", "value": 3, "inDeg": 0}, {"id": "softlabel", "label": "soft label", "title": "Consider a problem where are characterized by and from a finite . Some applications involve that have almost identical but different . In such cases, instead of assigning to each a single , it can be more useful to assign an entire over the . This can be represented as a . We can view the entries , for , as soft of a . Mathematically, the soft is the that a randomly chosen with has . \\\\ See also: , , .", "color": "#e87c7c", "value": 11, "inDeg": 0}, {"id": "mean", "label": "mean", "title": "The mean of a , which takes on values in a , is its . It is defined as the Lebesgue integral of with respect to the underlying (e.g., see or ), i.e., We also use the term to refer to the average of a finite . However, these two definitions are essentially the same. Indeed, we can use a to construct a discrete on the . Here, the index is chosen uniformly at random, for all . The mean of is precisely the average . For a with finite second-order moment, i.e., is well-defined and fnite, the mean is characterized as the solution of the following minimization problem : For the , associated with a , this reduces to with on . \\\\ See also: , , , .", "color": "#e8d87c", "value": 26, "inDeg": 16}, {"id": "median", "label": "median", "title": "A median of a real-valued is any number such that and (see Fig. ) . [H] [ axis lines=middle, xlabel={}, ylabel={}, ymin=0, ymax=1.1, xmin=-2, xmax=6, xtick= , ytick={0,1/2,1}, domain=-2:6, samples=200, width=10cm, height=6cm, smooth, enlargelimits=true, clip=false ] node[pos=0.5, above, yshift=15pt] { }; (axis cs:1,0) -- (axis cs:1,0.5); (axis cs:-2,0.5) -- (axis cs:1,0.5); (axis cs:1,0.5) circle (2pt); at (axis cs:1,0) { }; at (axis cs:6.3,0) { }; {The median of a real-valued is any number that partitions into two rays with equal . } We can define the median of a via a specific that is naturally associated with . In particular, this is defined on the via . Here, the index is chosen uniformly at random, i.e., for all . If the is integrable, any median of solves the : For a the above (constructed from a ), this is on using . Like the , the median of a can also be used to estimate of an underlying . Compared with the , the median is more robust to . For example, a median of a with more than one does not change even if we arbitrarily increase the largest element of (see Fig. ). In contrast, the will increase arbitrarily. [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/4 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptA ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (7.5, -4) {(a)}; [xshift=12cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 7.5) -- (10.5, 7.5) node[right] { }; (0.5, 3) -- (10.5, 3) node[right] { }; at (ptB7) { }; at (7.5, -4) {(b)}; {The median is robust against contamination. (a) Original . (b) Noisy including an . } See also: , , , .", "color": "#e8d87c", "value": 15, "inDeg": 1}, {"id": "variance", "label": "variance", "title": "The variance of a real-valued is defined as the of the squared difference between and its . We extend this definition to -valued as , i.e., the sum of the variances of each entry of , which can be written compactly as the of the of . \\\\ See also: , , .", "color": "#e8d87c", "value": 12, "inDeg": 7}, {"id": "nn", "label": "nearest neighbor (NN)", "title": "NN methods learn a whose value is solely determined by the NNs within a given . Different methods use different for determining the NNs. If are characterized by numeric , we can use their as the . \\\\ See also: , .", "color": "#e8d87c", "value": 8, "inDeg": 0}, {"id": "neighborhood", "label": "neighborhood", "title": "Consider some with . The neighborhood of a point is the set of other points having a sufficiently small distance to . For example, the -neighborhood of is defined as If is an , which is a special case of a , the neighborhood of a node is the set of its . \\\\ See also: , .", "color": "#e8d87c", "value": 7, "inDeg": 3}, {"id": "neighbor", "label": "neighbor", "title": "A neighbor of a node within an is a node that is via an edge to node . \\\\ See also: , .", "color": "#e8d87c", "value": 5, "inDeg": 3}, {"id": "bias", "label": "bias", "title": "Consider a -based method that learns a from a given . The analysis of the method is often based on a (such as the ) for the generation. Here, and, in turn, the learned are viewed as ( of) . Any property of , such as specific in a , or the error for a fixed , then also becomes a . The squared bias of a numeric property is Here, is a reference which could be defined by for a fixed test with and . \\\\ See also: , , , .", "color": "#e8d87c", "value": 20, "inDeg": 3}, {"id": "classification", "label": "classification", "title": "Classification is the task of determining a discrete-valued for a given , based solely on its . The belongs to a finite set, such as or , and represents the category to which the corresponding belongs. \\\\ See also: , , .", "color": "#e87c7c", "value": 24, "inDeg": 21}, {"id": "privfunnel", "label": "privacy funnel", "title": "The privacy funnel is a method for learning a that provides privacy-friendly of a . \\\\ See also: , , , .", "color": "#e87c7c", "value": 6, "inDeg": 1}, {"id": "condnr", "label": "condition number", "title": "The condition number of a positive definite is the ratio between the largest and the smallest of . The condition number is useful for the analysis of methods. The computational complexity of for crucially depends on the condition number of the , with the of the . These methods converge faster when the condition number is close to . \\\\ See also: , , .", "color": "#7ce8ba", "value": 7, "inDeg": 0}, {"id": "classifier", "label": "classifier", "title": "A classifier is a (i.e., a ) used to predict a taking on values from a finite . We might use the value itself as a for the . However, it is customary to use a that delivers a numeric quantity. The is then obtained by a simple thresholding step. For example, in a binary problem with a , we might use a real-valued as a classifier. A can then be obtained via thresholding, =1 ( )\\! \\!0 =-1 We can characterize a classifier by its , for every possible value . \\\\ See also: , , .", "color": "#e87c7c", "value": 17, "inDeg": 9}, {"id": "emprisk", "label": "empirical risk", "title": "The empirical of a on a is the average incurred by when applied to the in . \\\\ See also: , , , , .", "color": "#e87c7c", "value": 20, "inDeg": 15}, {"id": "nodedegree", "label": "node degree", "title": "The degree of a node in an is the number of its , i.e., . \\\\ See also: , .", "color": "#e8d87c", "value": 2, "inDeg": 0}, {"id": "token", "label": "token", "title": "A token is a basic unit of information obtained by splitting a of symbols, such as a text string, into smaller parts. In , tokens often correspond to words, subwords, or characters that form the of a . Tokenization transforms raw text (e.g., ``The cat sleeps'') into a of tokens (e.g., [``The'', ``cat'', ``sleeps'']), which can then be mapped to numerical . \\\\ See also: , .", "color": "#e87c7c", "value": 10, "inDeg": 5}, {"id": "nlp", "label": "natural language processing (NLP)", "title": "NLP studies methods for the the analysis and generation of human language. Typical NLP tasks include text , machine translation, sentiment analysis, and question answering. Modern NLP systems represent language as of and train that capture contextual dependencies, such as -based methods. \\\\ See also: , .", "color": "#e87c7c", "value": 11, "inDeg": 5}, {"id": "riskstratification", "label": "risk stratification", "title": "Risk assigns to risk groups (or ) by quantizing the obtained from a trained risk prognosis . Typical choices for these include low, intermediate, and high risk , . \\\\ See also: , , .", "color": "#e87c7c", "value": 6, "inDeg": 0}, {"id": "uncertainty", "label": "uncertainty", "title": "In the context of , uncertainty refers to the presence of multiple plausible or based on available . For example, the produced by a trained often reflects a range of possible values for the true of a given . The broader this range, the greater the associated uncertainty. theory allows us to represent, quantify, and reason about uncertainty in a mathematically rigorous manner. \\\\ See also: , , , .", "color": "#e8d87c", "value": 22, "inDeg": 9}, {"id": "ucb", "label": "upper confidence bound (UCB)", "title": "Consider an application that requires selecting, at each time step , an action from a finite set of alternatives . The utility of selecting action is quantified by a numeric signal . A widely used for this type of sequential decision-making problem is the setting . In this , the is viewed as the of a with unknown . Ideally, we would always choose the action with the largest expected , but these are unknown and must be estimated from observed . Simply choosing the action with the largest estimate can lead to suboptimal due to estimation . The UCB strategy addresses this by selecting actions not only based on their estimated but also by incorporating a term that reflects the in these estimates—favoring actions with a high-potential and high . Theoretical guarantees for the performance of UCB strategies, including logarithmic bounds, are established in . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 15, "inDeg": 1}, {"id": "optimism in the face of uncertainty", "label": "optimism in the face of uncertainty", "title": "methods learn according to some performance criterion . However, they usually cannot access directly but rely on an estimate (or approximation) of . As a case in point, -based methods use the average on a given (i.e., the ) as an estimate for the of a . Using a , one can construct a confidence interval for each choice for the . One simple construction is , , with being a of the (expected) deviation of from . We can also use other constructions for this interval as long as they ensure that with a sufficiently high . An optimist chooses the according to the most favorable—yet still plausible—value of the performance criterion (see Fig. ). Two examples of methods that use such an optimistic construction of an are and methods for sequential decision making . [H] [x=3cm, y=1cm] (-1, 5) -- plot[domain=-2:1, samples=100] ({ +1}, { + 1}) -- plot[domain=1:-2, samples=100] ({ +1}, { - 0.5}) -- cycle; at (2, 4) { }; plot ({ +1}, { -0.5}) node[right] { }; plot ({ }, { }); (1, -0.5) -- (1, 1) node[midway, right] { }; { methods learn by using some estimate of for the ultimate performance criterion . Using a , one can use to construct confidence intervals , which contain with high probability. The best plausible performance for a specific choice of is . } See also: , , , .", "color": "#e87c7c", "value": 17, "inDeg": 1}, {"id": "empgraph", "label": "federated learning network (FL network)", "title": "An network consists of an undirected weighted . The nodes of represent that can access a and train a . The edges of represent communication links between as well as statistical similarities between their . A principled approach to train the is . The solutions of are local that optimally balance the incurred on with their across the edges of . \\\\ See also: , , , .", "color": "#9be87c", "value": 18, "inDeg": 9}, {"id": "norm", "label": "norm", "title": "A norm is a that maps each ( ) element of a to a nonnegative real number. This must be homogeneous and definite, and it must satisfy the triangle inequality . \\\\ See also: , , .", "color": "#e8d87c", "value": 14, "inDeg": 11}, {"id": "dualnorm", "label": "dual norm", "title": "Every defined on a has an associated dual , which is denoted by and defined as . The dual measures the largest possible inner product between and any in the unit ball of the original . For further details, see . \\\\ See also: , , .", "color": "#e8d87c", "value": 3, "inDeg": 0}, {"id": "geometricmedian", "label": "geometric median (GM)", "title": "The GM of a set of in is a point that minimizes the sum of distances to the such that _{ ^{ }} _{ =1}^{ } { - ^{( )}}{2}. Fig. illustrates a fundamental property of the GM: If does not coincide with any of the , then the unit pointing from to each must sum to zero—this is the zero- (optimality) condition for . It turns out that the solution to cannot be arbitrarily pulled away from trustworthy as long as they are the majority . [H] [scale=2, thick, >=stealth] (w) at (3,0); (w) circle (1.2pt) node[below right] { }; (w2) at (0.5,0.3); (w3) at (0.7,0.7); (w2) circle (1pt) node[above left] { }; (w3) circle (1pt) node[above left] { }; at ( ) { }; (w) -- (w2); (w) -- (w3); (w) -- ( ) ; (w) -- ( ) node[pos=0.9, right,yshift=7pt] { }; (w4) at (5,0.2); at (5,0.6) { }; (w4) circle (1pt) node[below left] { }; (w) -- ( ) ; { Consider a solution of that does not coincide with any of the . The optimality condition for requires that the unit from to the sum to zero.} See also: , .", "color": "#e8d87c", "value": 3, "inDeg": 0}, {"id": "explanation", "label": "explanation", "title": "One approach to enhance the of an method for its human user is to provide an explanation alongside the delivered by the method. Explanations can take different forms. For instance, they may consist of human-readable text or quantitative indicators, such as importance scores for the individual of a given ~ . Alternatively, explanations can be visual—for example, intensity that highlight image regions that drive the . Fig.\\ illustrates two types of explanations. The first is a local linear approximation of a nonlinear trained around a specific , as used in the method . The second form of explanation depicted in the figure is a sparse set of at selected , offering concrete reference points for the user. [H] [x=0.5cm] [ hide axis, xmin=-3, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.9, above right, yshift=10pt] { }; node[pos=0.2, above] { }; coordinates {(1.5, {2 + sin(deg(1.5))})}; coordinates {(1.5,0) (1.5,2.4)}; at (axis cs:1.5, -0.2) { }; coordinates {(-1, {2 + sin(deg(-1))})}; coordinates {(-1,0) (-1,{2 + sin(deg(-1))})}; at (axis cs:-1, -0.2) { }; coordinates {(0, {2 + sin(deg(0))})}; coordinates {(0,0) (0,{2 + sin(deg(0))})}; at (axis cs:0, -0.2) { }; coordinates {(5, {2 + sin(deg(5))})}; coordinates {(5,0) (5,{2 + sin(deg(5))})}; at (axis cs:5, -0.2) { }; {A trained can be explained locally at some point by a linear approximation . For a , this approximation is determined by the . Another form of explanation could be the values for . } See also: , , , , .", "color": "#e87c7c", "value": 17, "inDeg": 4}, {"id": "risk", "label": "risk", "title": "Consider a used to predict the of a based on its . We measure the quality of a particular using a . If we interpret as the of , the also becomes the of an . The allows us to define the risk of a as the expected . Note that the risk of depends on both the specific choice for the and the of the . \\\\ See also: , , , .", "color": "#e87c7c", "value": 32, "inDeg": 20}, {"id": "actfun", "label": "activation function", "title": "Each artificial neuron within an is assigned an that maps a weighted combination of the neuron inputs to a single output value . Note that each neuron is parameterized by the . \\\\ See also: , , .", "color": "#e87c7c", "value": 9, "inDeg": 4}, {"id": "distributedalgorithm", "label": "distributed algorithm", "title": "A distributed is an designed for a special type of computer, i.e., a collection of interconnected computing devices (or nodes). These devices communicate and coordinate their local computations by exchanging messages over a network , . Unlike a classical , which is implemented on a single , a distributed is executed concurrently on multiple with computational capabilities. Similar to a classical , a distributed can be modeled as a set of potential executions. However, each execution in the distributed setting involves both local computations and message-passing . A generic execution might look as follows: Each starts from its own local input and performs a sequence of intermediate computations at discrete-time instants . These computations may depend on both the previous local computations at the and the messages received from other . One important application of distributed is in where a network of collaboratively trains a personal for each . \\\\ See also: , , , , .", "color": "#9be87c", "value": 8, "inDeg": 3}, {"id": "algorithm", "label": "algorithm", "title": "An algorithm is a precise, step-by-step specification for producing an from a given input within a finite number of well-defined computational steps . For example, a for is an algorithm that explicitly describes how to map a given into through a sequence of . The precise form of an algorithm depends on the available computational infrastructure. For example, if this infrastructure allows us to compute an , then we can define a algorithm using the . In contrast, if the computational infrastructure only allows basic arithmetic (i.e., multiplication and addition), the need to be somehow translated into a sequence of arithmetic operations (e.g., as in ). To study algorithms rigorously, we can represent (or approximate) them by different mathematical structures . One approach is to represent an algorithm as a collection of possible executions. Each individual execution is then a sequence of the form This sequence starts from an input and progresses via intermediate steps until an is delivered. Crucially, an algorithm encompasses more than just a mapping from input to ; it also includes intermediate computational steps . \\\\ See also: , , , , , , .", "color": "#9be87c", "value": 32, "inDeg": 22}, {"id": "stochalgorithm", "label": "stochastic algorithm", "title": "A uses a random mechanism during its execution. For example, uses a randomly selected subset of to compute an approximation for the of an . We can represent a by a , i.e., the possible execution sequence is the possible of a , , . \\\\ See also: , , , , , , , , , .", "color": "#e8d87c", "value": 12, "inDeg": 1}, {"id": "batchlearning", "label": "batch learning", "title": "In learning (also known as offline learning), the is trained on the entire in a single training iteration, instead of updating it incrementally as arrive. All available are inputted into a learning , resulting in a that can make . Since these tend to be large, training is computationally expensive and time-consuming, so it is typically performed offline. After learning, the will be static and will not adapt to new automatically. Updating the with new information requires retraining the entirely. Once the has been trained, it is launched into production where it cannot be updated. Training a can take many hours, so many in production settings are updated cyclically on a periodic schedule when the distribution is stable. For example, a retail analytics team could retrain their demand forecast every Sunday using the previous week's sales to predict next week's demand. If a system needs to be constantly updated to rapidly changing , such as in stock price , a more adaptable solution such as is necessary. \\\\ See also: , , , .", "color": "#9be87c", "value": 8, "inDeg": 0}, {"id": "onlinelearning", "label": "online learning", "title": "Some methods are designed to process in a sequential manner, updating their one at a time, as new become available. A typical example is time-series , such as daily and temperatures recorded by an weather station. These values form a chronological sequence of observations. During each time step , online learning methods update (or refine) the current (or ) based on the newly observed . \\\\ See also: , .", "color": "#9be87c", "value": 16, "inDeg": 6}, {"id": "onlinealgorithm", "label": "online algorithm", "title": "An online processes input incrementally, receiving sequentially and making decisions or producing outputs (or decisions) immediately without having access to the entire input in advance , . Unlike an offline , which has the entire input available from the start, an online must handle about future inputs and cannot revise past decisions. Similar to an offline , we represent an online formally as a collection of possible executions. However, the execution sequence for an online has a distinct structure as follows: Each execution begins from an initial state (i.e., ) and proceeds through alternating computational steps, outputs (or decisions), and inputs. Specifically, at step , the performs a computational step , generates an output , and then subsequently receives the next input ( ) . A notable example of an online in is , which incrementally updates as new arrive. \\\\ See also: , , , , , , , .", "color": "#9be87c", "value": 9, "inDeg": 1}, {"id": "sensattr", "label": "sensitive attribute", "title": "revolves around learning a that allows us to predict the of a from its . In some applications, we must ensure that the output delivered by an system does not allow us to infer sensitive attributes of a . Which part of a is considered a sensitive attribute is a design choice that varies across different application domains. \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 11, "inDeg": 5}, {"id": "sbm", "label": "stochastic block model (SBM)", "title": "The SBM is a probabilistic generative for an undirected with a given set of nodes . In its most basic variant, the SBM generates a by first randomly assigning each node to a index . A pair of different nodes in the is connected by an edge with that depends solely on the . The presence of edges between different pairs of nodes is statistically independent. \\\\ See also: , , , , .", "color": "#e8d87c", "value": 7, "inDeg": 2}, {"id": "deepnet", "label": "deep net", "title": "A deep net is an with a (relatively) large number of hidden . Deep learning is an umbrella term for methods that use a deep net as their . \\\\ See also: , , , .", "color": "#e87c7c", "value": 17, "inDeg": 12}, {"id": "baseline", "label": "baseline", "title": "Consider some method that produces a learned (or trained ) . We evaluate the quality of a trained by computing the average on a . But how can we assess whether the resulting performance is sufficiently good? How can we determine if the trained performs close to optimal such that there is little point in investing more resources (for collection or computation) to improve it? To this end, it is useful to have a reference (or baseline) level against which we can compare the performance of the trained . \\\\ Such a reference value might be obtained from human performance, e.g., the misclassification rate of dermatologists who diagnose cancer from visual inspection of skin . Another source for a baseline is an existing, but for some reason unsuitable, method. For example, the existing method might be computationally too expensive for the intended application. Nevertheless, its error can still serve as a baseline. Another, somewhat more principled, approach to constructing a baseline is via a . In many cases, given a , we can precisely determine the achievable among any hypotheses (not even required to belong to the ) . \\\\ This achievable (referred to as the ) is the of the for the of a , given its . Note that, for a given choice of , the (if it exists) is completely determined by the . However, computing the and presents two main challenges. First, the is unknown and must be estimated from observed . Second, even if were known, computing the exactly may be computationally infeasible . A widely used is the for characterized by numeric and . Here, for the , the is given by the posterior of the , given the , . The corresponding is given by the posterior (see Fig. ). [H] (-1,0) -- (7,0) node[right] { }; plot ({ }, {2*exp(-0.5*(( -3)^2))}); (3,0) -- (3,2.5); at ([yshift=-5pt] 3,2.5) { }; (3-1,1) -- (3+1,1.0); at ([yshift=2pt] 3,1.2) { }; in {0.5} { at ( , 0) { }; } at (0.5,-0.2) { }; {If the and the of a are drawn from a , we can achieve the (under ) by using the to predict the of a with . The corresponding is given by the posterior . We can use this quantity as a baseline for the average of a trained . } See also: , .", "color": "#e87c7c", "value": 24, "inDeg": 3}, {"id": "kfoldcv", "label": "-fold cross-validation ( -fold CV)", "title": "A -fold CV is a method for evaluating the of an -based method. The idea is to divide a evenly into subsets (or folds) . [H] [font= ] in {1,..., } { {-( -1)*( + )} at (-0.25, +0.5* ) {fold }; in {1,..., } { {( -1)* } = ( , ) rectangle ++( , ); ( , ) rectangle ++( , ); ( , ) rectangle ++( , ); } } in {1,..., } { {( -1)* + 0.5* } at ( , +0.2) { }; } {In -fold CV, the available is evenly divided into folds . Each fold is used once as a , while the remaining folds form the . } For each fold , we train the on the union of all folds except and validate it on . The overall performance is obtained by averaging the results across all folds. \\\\ See also: , .", "color": "#e87c7c", "value": 12, "inDeg": 3}, {"id": "spectrogram", "label": "spectrogram", "title": "A spectrogram represents the time-frequency distribution of the energy of a time signal . Intuitively, it quantifies the amount of signal energy present within a specific time segment and frequency interval . Formally, the spectrogram of a signal is defined as the squared magnitude of its short-time Fourier transform (STFT) . Fig. depicts a time signal along with its spectrogram. [H] { } { (a) (b)} {(a) A time signal consisting of two modulated pulses. (b) An intensity plot of the spectrogram. } The intensity plot of its spectrogram can serve as an image of a signal. A simple recipe for audio signal is to feed this signal image into originally developed for image and object detection . It is worth noting that, beyond the spectrogram, several alternative representations exist for the time-frequency distribution of signal energy , . \\\\ See also: , .", "color": "#e8d87c", "value": 3, "inDeg": 0}, {"id": "graphclustering", "label": "graph clustering", "title": "aims to cluster that are represented as the nodes of a . The edges of represent pairwise similarities between . We can sometimes quantify the extent of these similarities by an , . \\\\ See also: , , , .", "color": "#9be87c", "value": 6, "inDeg": 2}, {"id": "specclustering", "label": "spectral clustering", "title": "Spectral is a particular instance of , i.e., it clusters represented as the nodes of a . Spectral uses the of the to construct for each node (i.e., for each ) . We can feed these into -based methods, such as or via . Roughly speaking, the of nodes belonging to a well-connected subset (or ) of nodes in are located nearby in the (see Fig. ). [H] {0.4 } [every node/.style={circle, fill=black, inner sep=0pt, minimum size=0.3cm}] (1) at (0,0) {}; (2) [below left=of 1, xshift=-0.2cm, yshift=-1cm] {}; (3) [below right=of 1, xshift=0.2cm, yshift=-1cm] {}; (4) [below=of 1, yshift=0.5cm] {}; (1) -- (2); (1) -- (3); at (1) { }; at (2) { }; at (3) { }; at (4) { }; at (0,-4) {(a)}; {0.4 } \\!=\\! 2 & -1 & -1 & 0 \\\\ -1 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 \\!=\\! { } \\,^{T} { } \\\\ {0.4 } [scale=3] (-0.2, 0) -- (1.2, 0) node[right] { }; (0, -0.2) -- (0, 1.2) node[above] { }; (0.577, 0) circle (0.03cm) node[above right] { }; (0.577, 0) circle (0.03cm); (0.577, 0) circle (0.03cm); (0, 1) circle (0.03cm) node[above right] { }; at (0.5,-0.5) {(c)}; {0.4 } & = ( ^{(1)}, ^{(2)}, ^{(3)}, ^{(4)} ) \\\\ & ^{(1)}\\!=\\! { } 1 \\\\ 1 \\\\ 1 \\\\ 0 , \\, ^{(2)}\\!=\\! 0 \\\\ 0 \\\\ 0 \\\\ 1 { } { (a) An undirected with four nodes , each representing a . (b) The and its . (c) A of using the . (d) Two corresponding to the of the . } See also: , , , .", "color": "#7ce8ba", "value": 17, "inDeg": 2}, {"id": "flowbasedclustering", "label": "flow-based clustering", "title": "Flow-based groups the nodes of an undirected by applying to nodewise . These are built from network flows between carefully selected sources and destination nodes . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 4, "inDeg": 0}, {"id": "esterr", "label": "estimation error", "title": "Consider , each with and . In some applications, we can model the relation between the and the of a as . Here, we use some true underlying and a noise term , which summarizes any modeling or labeling errors. The estimation error incurred by an method that learns a , e.g., using , is defined as , for some . For a parametric , which consists of determined by , we can define the estimation error as , . \\\\ See also: , , , , , , , , .", "color": "#e87c7c", "value": 11, "inDeg": 2}, {"id": "dob", "label": "degree of belonging", "title": "Degree of belonging is a number that indicates the extent to which a belongs to a . The degree of belonging can be interpreted as a soft assignment. methods can encode the degree of belonging with a real number in the interval . is obtained as the extreme case when the degree of belonging only takes on values or . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 6, "inDeg": 2}, {"id": "msee", "label": "mean squared estimation error (MSEE)", "title": "Consider an method that learns based on some . If we interpret the in as of a , we define the . Here, denotes the true of the of . The MSEE is defined as the of the squared of the , . \\\\ See also: , , , .", "color": "#e8d87c", "value": 13, "inDeg": 0}, {"id": "gtvmin", "label": "generalized total variation minimization (GTVMin)", "title": "GTVMin is an instance of using the of local as a . \\\\ See also: , , .", "color": "#9be87c", "value": 6, "inDeg": 2}, {"id": "regression", "label": "regression", "title": "Regression problems revolve around the of a numeric solely from the of a . \\\\ See also: , , , .", "color": "#e87c7c", "value": 14, "inDeg": 10}, {"id": "acc", "label": "accuracy", "title": "Consider characterized by and a categorical that takes on values from a finite . The accuracy of a , when applied to the in a , is then defined as using the . \\\\ See also: , , .", "color": "#e87c7c", "value": 11, "inDeg": 2}, {"id": "expert", "label": "expert", "title": "aims to learn a that accurately predicts the of a based on its . We measure the error using some . Ideally, we want to find a that incurs minimal on any . We can make this informal goal precise via the and by using the as the for the (average) of a . An alternative approach to obtaining a is to use the learned by an existing method. We refer to this as an expert . minimization methods learn a that incurs a comparable to the best expert , . \\\\ See also: , , .", "color": "#e87c7c", "value": 13, "inDeg": 1}, {"id": "nfl", "label": "networked federated learning (NFL)", "title": "NFL refers to methods that learn personalized in a distributed fashion. These methods learn from that are related by an intrinsic network structure. \\\\ See also: , , .", "color": "#9be87c", "value": 3, "inDeg": 0}, {"id": "fedprox", "label": "federated proximal (FedProx)", "title": "FedProx refers to an iterative that alternates between separately training and combining the updated local . In contrast to , which uses to train , FedProx uses a for the training . \\\\ See also: , , , , , , .", "color": "#9be87c", "value": 7, "inDeg": 0}, {"id": "relu", "label": "rectified linear unit (ReLU)", "title": "The ReLU is a popular choice for the of a neuron within an . It is defined as , with being the weighted input of the artificial neuron. \\\\ See also: , .", "color": "#e87c7c", "value": 3, "inDeg": 1}, {"id": "hypothesis", "label": "hypothesis", "title": "A hypothesis refers to a (or ) from the to the . Given a with , we use a hypothesis to estimate (or approximate) the using the . [htbp] [ >=Latex, node distance=2.0cm, box/.style={draw, rounded corners=2pt, inner sep=6pt}, label/.style={font= }, thinline/.style={line width=0.6pt} ] (audio) {}; at (audio.north) [yshift=0mm] {audio samples }; ( ) .. controls +(.3,.35) and +(-.3,.35) .. ++(0.8,0) .. controls +(.3,-.35) and +(-.3,-.35) .. ++(0.8,0) .. controls +(.3,.25) and +(-.3,.25) .. ++(0.8,0) .. controls +(.3,-.25) and +(-.3,-.25) .. ++(0.8,0); (model) { }; (audio) -- (model) ; (rating) {}; at ( ) {}; (barL) at ( ); (barR) at ( ); (ptr) at ( ); ; (model) -- (rating); { A hypothesis maps the of a to a of the . For example, the application uses the samples of an audio recording as predict how closely a person’s singing resembles that of Freddie Mercury. } is all about learning (or finding) a hypothesis such that for any (with and ). Practical methods, limited by finite computational resources, must restrict learning to a subset of all possible hypothesis maps. This subset is called the or simply the underlying the method. \\\\ See also: , , , .", "color": "#e87c7c", "value": 101, "inDeg": 90}, {"id": "effdim", "label": "effective dimension", "title": "The effective of an infinite is a of its size. Loosely speaking, the effective is equal to the effective number of independent tunable . These might be the coefficients used in a or the and terms of an . \\\\ See also: , , .", "color": "#e87c7c", "value": 15, "inDeg": 6}, {"id": "labelspace", "label": "label space", "title": "In an application , each is described by a set of together with an associated . The set of all admissible values is called the , denoted by . Importantly, may include values that no observed has as its value. To a large extent, the choice of is up to the engineer and depends on the problem formulation. Fig.~ shows some examples of spaces that are commonly used in applications. [H] [>=Stealth, font= ] [shift={(0,0)}] (-2,0) -- (2,0); at (0,-0.7) { ( )}; at (0,-2) {(a)}; [shift={(7,0)}] (-1,-0.5) rectangle (1,0.5); (-2,0) -- (2,0); (0,-1) -- (0,1); at (0,-0.7) { (multi-label )}; at (0,-2) {(b)}; [shift={(0,-3)}] (-1,0) circle (1.2pt) node[below=2pt] { }; ( 1,0) circle (1.2pt) node[below=2pt] { }; at (0,-0.7) { (binary )}; at (0,-2.3) {(c)}; [shift={(7,-3)}] (n1) at (-1.5,0) {}; (n2) at (-0.5,0) {}; (n3) at ( 0.5,0) {}; (n4) at ( 1.5,0) {}; (n1) -- (n2); (n2) -- (n3); (n3) -- (n4); ; ; ; ; at (0,-0.7) { (ordinal )}; at (0,-2.3) {(d)}; { Examples of spaces and the corresponding types of . (a) . (b) Multi-label . (c) Binary . (d) Ordinal .} The choice of the space determines the type of methods appropriate for the application at hand. methods use the , while binary methods use a space that consists of two different elements, i.e., . Ordinal methods use a finite, ordered set of values, e.g., with the natural ordering . \\\\ See also: , , , .", "color": "#e87c7c", "value": 19, "inDeg": 13}, {"id": "prediction", "label": "prediction", "title": "A prediction is an estimate or approximation for some quantity of interest. revolves around learning or finding a that reads in the of a and delivers a prediction for its . \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 68, "inDeg": 62}, {"id": "empiricaldistribution", "label": "empirical distribution", "title": "Consider a consisting of distinct , each characterized by the for . For a given over the , the empirical distribution of is the defined via In other words, the empirical distribution assigns to any set the fraction of in that fall into . If the is ordered, the empirical distribution can also be characterized by its empirical where denotes the ordering relation on . [H] [>=stealth, thick,y=2cm] / in {1/0.3, 4/0.7} { ( ,0) -- ( , ); ( , ) circle (2pt); } at (1,0.3) { }; at (1,0) { }; at (4,0) { }; at (-1.2,-0.80) { }; {A consisting of , each characterized by a value from the finite . The empirical assigns to each possible value the fraction of in whose takes on this value. Here, three out of ten take on the value , resulting in . } If the is finite, the empirical distribution of can also be characterized by the empirical \\\\ See also: , .", "color": "#e8d87c", "value": 13, "inDeg": 2}, {"id": "histogram", "label": "histogram", "title": "Consider a that consists of , each of them belonging to some cell with side length . We partition this cell evenly into smaller elementary cells with side length . The histogram of assigns each elementary cell to the corresponding fraction of in that fall into this elementary cell. A visual example of such a histogram is provided in Fig. .\\\\ [H] [ ybar, ymin=0, ymax=6, bar width=22pt, width=10cm, height=6cm, xlabel={Value}, ylabel={Frequency}, ytick={1,2,3,4,5,6}, xtick={1,2,3,4,5}, xticklabels={{[0,1)}, {[1,2)}, {[2,3)}, {[3,4)}, {[4,5)}}, enlarge x limits=0.15, title={Histogram of Sample Data} ] +[fill=blue!40] coordinates {(1,2) (2,5) (3,4) (4,3) (5,1)}; {A histogram consists of the fractions of that fall within different value ranges (i.e., bins). Each bar height shows the count of in the corresponding interval.} See also: , , .", "color": "#e8d87c", "value": 4, "inDeg": 1}, {"id": "bootstrap", "label": "bootstrap", "title": "For the analysis of methods, it is often useful to interpret a given as ( of) a collection of with common . In practice, the is unknown and must be estimated from . The idea of the bootstrap method is to use the of as an estimator for , Repeatedly sampling from the , which is equivalent to sampling with replacement from , results in new , each containing . We then use each of those for (e.g., via ), resulting in the learned We can use these learned to estimate important characteristics of a method such as , or . . \\\\ See also: , , , .", "color": "#e8d87c", "value": 17, "inDeg": 1}, {"id": "featurespace", "label": "feature space", "title": "The space of a given application or method is constituted by all potential values that the of a can take on. For described by a fixed number of numerical , a common choice for the space is the . However, the mere presence of numeric does not imply that is the most appropriate representation of the space. Indeed, the numerical might be assigned to in a largely arbitrary or random manner, resulting in that are randomly scattered throughout without any meaningful geometric structure. methods try to learn a transformation of the original (potentially non-numeric) to ensure a more meaningful arrangement of in . Three examples of spaces are shown in Fig. . [H] [scale=0.6] [xshift=0cm] (-0.5, 0) -- (3.5, 0) node[right] { }; / in {0.5/ , 1.5/ , 2.8/ } ( ,0) circle (2pt) node[above] { }; at (1.5, -4.0) { }; at (1.5, -6) {(a)}; [xshift=8cm] (0,0) circle (1.8); (0,0) circle (1.8); (0.8, 0.9) circle (2pt) node[anchor=south west] { }; (-1.2, 0.5) circle (2pt) node[anchor=south east] { }; (0.3, -1.4) circle (2pt) node[anchor=north west] { }; at (0.5, -4) { }; at (0.5, -6) {(b)}; [xshift=14cm, yshift=0.3cm] (0,0) circle (2pt) node[anchor=north east] { }; (2,1.2) circle (2pt) node[anchor=south west] { }; (1,2.5) circle (2pt) node[anchor=south east] { }; (3,2.5) circle (2pt) node[anchor=south west] { }; (0,0) -- (2,1.2); (2,1.2) -- (1,2.5); (1,2.5) -- (3,2.5); at (1.5, -4.2) { }; at (1.5, -6.2) {(c)}; {Three different spaces. (a) A linear space . (b) A bounded set . (c) A discrete space whose elements are nodes of an undirected . } See also: , .", "color": "#e87c7c", "value": 27, "inDeg": 19}, {"id": "missingdata", "label": "missing data", "title": "Consider a constituted by collected via some physical . Due to imperfections and failures, some of the or values of might be corrupted or simply missing. imputation aims to estimate these missing values . We can interpret imputation as an problem where the of a is the value of the corrupted . \\\\ See also: , .", "color": "#9be87c", "value": 8, "inDeg": 1}, {"id": "dataimputation", "label": "data imputation", "title": "See .", "color": "#9be87c", "value": 1, "inDeg": 0}, {"id": "feature", "label": "feature", "title": "A feature of a is one of its properties that can be measured or computed easily without the need for human supervision. For example, if a is a digital image (e.g., stored as a file), then we could use the red–green–blue (RGB) intensities of its pixels as features. [scale=1] plot ({ }, {sin( r)}); [count= ] in {0,0.5,...,6.28} { ( , {sin( r)}) circle (2pt); =1 at ( , {sin( r)}) { }; =2 at ( , {sin( r)}) { }; } {An audio signal (blue waveform) and its discretized signal samples (red dots) which can be used as its features . } Another example is shown in Fig.\\ , where the the signal samples of a finite-duration audio signal are used as its features. Domain-specific synonyms for the term feature are \"covariate,\" \"explanatory variable,\" \"independent variable,\" \"input (variable),\" \"predictor (variable),\" or \"regressor\" , , . \\\\ See also: .", "color": "#e87c7c", "value": 75, "inDeg": 74}, {"id": "featurevec", "label": "feature vector", "title": "refers to a whose entries are individual . Many methods use that belong to some finite-dimensional . For some methods, however, it can be more convenient to work with that belong to an infinite-dimensional (e.g., see ). \\\\ See also: , , , , .", "color": "#7ce8ba", "value": 74, "inDeg": 68}, {"id": "label", "label": "label", "title": "A higher-level fact or quantity of interest associated with a . For example, if the is an image, the label could indicate whether the image contains a cat or not. Synonyms for label, commonly used in specific domains, include \"response variable,\" \"output variable,\" and \"target\" , , . \\\\ See also: , .", "color": "#e87c7c", "value": 76, "inDeg": 74}, {"id": "data", "label": "data", "title": "In the context of , the term data is often used as a synonym for , . The ISO/IEC 2382:2015 standard defines data as a \"reinterpretable representation of information in a formalized manner suitable for communication, interpretation, or processing\" . \\\\ See also: , , .", "color": "#9be87c", "value": 53, "inDeg": 49}, {"id": "dataset", "label": "dataset", "title": "A dataset is a set of distinct . Strictly speaking, a dataset is an unordered collection of that does not contain any repetitions. However, in literature, the term dataset is often used as a synonym for , i.e., a sequence (or finite list) of and may contain repetitions. methods use datasets for and . The notion of a dataset is broad: may represent concrete physical entities (such as humans or animals) or abstract objects (such as numbers). For illustration, Fig.~ depicts a dataset whose are cows. [H] { A cow herd somewhere in the Alps.} Quite often, an engineer does not have direct access to the underlying dataset. For instance, accessing the dataset in Fig.~ would require visiting the cow herd. In practice, we work with a more convenient representation (or approximation) of the dataset. Various mathematical have been developed for this purpose , , , . One of the most widely used is the relational , which organizes as a table (or relation) , . A table consists of rows and columns: each row corresponds to a single , while each column represents a specific attribute of a . methods typically interpret these attributes as or as a of a . As an illustration, Table~ shows a relational representation of the dataset from Fig.~ . In the relational , the order of rows is immaterial, and each attribute (column) is associated with a domain that specifies the set of admissible values. In applications, these attribute domains correspond to the and the . [H] { TABLE \\\\[0.5ex] A Relation (or Table) That Represents the Dataset in Fig. } {lcccc} & & & & \\\\ Zenzi & 100 & 4 & 100 & 25 \\\\ Berta & 140 & 3 & 130 & 23 \\\\ Resi & 120 & 4 & 120 & 31 \\\\ While the relational is useful for the study of many applications, it may be insufficient regarding the requirements for . Modern approaches like datasheets for datasets provide more comprehensive documentation, including details about the collection process, intended use, and other contextual information . \\\\ See also: , , , , , .", "color": "#7ce8ba", "value": 80, "inDeg": 68}, {"id": "predictor", "label": "predictor", "title": "A predictor is a real-valued . Given a with , the value is used as a for the true numeric of the . \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 6, "inDeg": 0}, {"id": "labeled datapoint", "label": "labeled data point", "title": "A whose is known or has been determined by some means that might require human labor. \\\\ See also: , .", "color": "#e87c7c", "value": 8, "inDeg": 6}, {"id": "samplespace", "label": "sample space", "title": "A space is the set of all possible of a , , , . \\\\ See also: .", "color": "#e8d87c", "value": 16, "inDeg": 12}, {"id": "realization", "label": "realization", "title": "Consider a that maps each of a to an element of a space , , . A realization of is any element such that there exists an element with . \\\\ See also: , , , .", "color": "#e8d87c", "value": 24, "inDeg": 20}, {"id": "trainset", "label": "training set", "title": "A training set is a that consists of some used in to learn a . The average of on the training set is referred to as the . The comparison of the with the of allows us to diagnose the method and informs how to improve the (e.g., using a different or collecting more ) . \\\\ See also: , , , , , , , , .", "color": "#e87c7c", "value": 65, "inDeg": 56}, {"id": "netmodel", "label": "networked model", "title": "A networked over an assigns a (i.e., a ) to each node of the . \\\\ See also: , , , .", "color": "#9be87c", "value": 4, "inDeg": 0}, {"id": "batch", "label": "batch", "title": "In the context of , a batch refers to a randomly chosen subset of the overall . We use the in this subset to estimate the of and, in turn, to update the . \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 9, "inDeg": 3}, {"id": "epoch", "label": "epoch", "title": "An epoch represents one complete pass of the entire through some learning . It refers to the point at which a has processed every in the once. Training a usually requires multiple epochs, since each iteration allows the to refine the and improve . The number of epochs is something predefined by the user, and thus a hyperparameter, which plays a crucial role in determining how the will generalize to unseen . Too few epochs will result in , while too many epochs can result in . \\\\ See also: , , , , , , , .", "color": "#e87c7c", "value": 9, "inDeg": 0}, {"id": "netdata", "label": "networked data", "title": "Networked consist of that are related by some notion of pairwise similarity. We can represent networked using a whose nodes carry and whose edges encode pairwise similarities. An example of networked can be found in applications where are generated by spatially distributed . \\\\ See also: , , , , .", "color": "#9be87c", "value": 6, "inDeg": 1}, {"id": "trainerr", "label": "training error", "title": "The average of a when predicting the of the in a . We sometimes also refer to training error as the minimal average that is achieved by a solution of . \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 12, "inDeg": 6}, {"id": "datapoint", "label": "data point", "title": "A point is any object that conveys information~ . Examples include students, radio signals, trees, images, , real numbers, or proteins. We describe points of the same type by two categories of properties. The first category includes that are or computable properties of a point. These attributes can be automatically extracted or computed using sensors, computers, or other collection systems. For a point that represents a patient, one could be the body weight. The second category includes that are higher level facts (or quantities of interest)—that is, facts which typically require human expertise or domain knowledge to determine, rather than being directly measurable—associated with the point. Determining the of a point usually requires human expertise or domain knowledge. For a point that represents a patient, a cancer diagnosis provided by a physician would serve as the . Fig.\\ depicts an image as an example of a point along with its and . Importantly, what constitutes a or a is not inherent to the point itself—it is a design choice that depends on the specific application. [H] [t]{0.95 } {A single point.} [t]{0.95 } : : Color intensities of all image pixels. : Time-stamp of the image capture. : Spatial location of the image capture. : : Number of cows depicted. : Number of wolves depicted. : Condition of the pasture (e.g., healthy, overgrazed). {Illustration of a point consisting of an image. We can use different properties of the image as and higher level facts about the image as . } The distinction between and is not always clear-cut. A property that is considered a in one setting (e.g., a cancer diagnosis) may be treated as a in another setting—particularly if reliable automation (e.g., via image analysis) allows it to be computed without human intervention. broadly aims to predict the of a point based on its . \\\\ See also: , , , .", "color": "#e87c7c", "value": 173, "inDeg": 166}, {"id": "valerr", "label": "validation error", "title": "Consider a that is obtained by some method, e.g., using on a . The average of on a , which is different from the , is referred to as the error. \\\\ See also: , , , , , , .", "color": "#e87c7c", "value": 15, "inDeg": 8}, {"id": "validation", "label": "validation", "title": "Consider a that has been learned via some method, e.g., by solving on a . [htbp] [scale=1.2,x=1.5cm] plot ( ,{0.5* }) node[pos=0, above left] { }; (0,0) circle (4pt); (2,2) circle (4pt); at (0,0) { }; (1,3) circle (4pt); at (1,3) { }; {Illustration of validation. The blue points represent the in the , while the red point represents a in the . The (black curve) fits the in the perfectly, but incurs a large on the in the .} Validation refers to the process of evaluating the incurred by the on a set of that are not contained in the . This set of is called the . The average of on the is referred to as the .\\\\ See also: , , , , .", "color": "#e87c7c", "value": 23, "inDeg": 13}, {"id": "quadfunc", "label": "quadratic function", "title": "A of the form with some , , and scalar . \\\\ See also: , , .", "color": "#9be87c", "value": 5, "inDeg": 2}, {"id": "valset", "label": "validation set", "title": "A set of used to estimate the of a that has been learned by some method (e.g., solving ). The average of on the set is referred to as the and can be used to diagnose an method (see ). The comparison between and can inform directions for the improvement of the method (such as using a different ). \\\\ See also: , , , , , , , , , .", "color": "#e87c7c", "value": 18, "inDeg": 8}, {"id": "testset", "label": "test set", "title": "A set of that have been used neither to train a (e.g., via ) nor to choose between different in a . \\\\ See also: , , , .", "color": "#e87c7c", "value": 9, "inDeg": 5}, {"id": "modelsel", "label": "model selection", "title": "In , selection refers to the process of choosing between different candidate . In its most basic form, selection amounts to: 1) training each candidate ; 2) computing the for each trained ; and 3) choosing the with the smallest . \\\\ See also: , , .", "color": "#e87c7c", "value": 4, "inDeg": 1}, {"id": "linclass", "label": "linear classifier", "title": "Consider characterized by numeric and a from some finite . A linear is characterized by having that are separated by hyperplanes in . \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 10, "inDeg": 4}, {"id": "erm", "label": "empirical risk minimization (ERM)", "title": "ERM is the of selecting a that minimizes the average (or ) on a . The is chosen from a (or ) . The is referred to as . A plethora of -based methods is obtained for different design choices for the , , and . Fig.\\ illustrates ERM for a and that are characterized by a single and a . The is a that predicts the of a as a linear of its , i.e., , where and are the of the . The ERM problem is to find the and that minimize the average (or ) incurred by the on the . [H] [scale=1] plot ({ },{ + }); (hend) at ( ,{ + }); at (hend) { }; / / in {1/1.2/1.8, 2/3.0/2.6, 3/5.0/5.7} { (l ) at ( , { + }); (n ) at ( , ); (pt ) at (n ) {}; (l ) -- (n ); } at (n1) { }; at (n2) { }; at (n3) { }; {ERM learns a out of a by minimizing the average (or ) incurred on a .} See also: , , , , .", "color": "#e87c7c", "value": 88, "inDeg": 71}, {"id": "sampleweighting", "label": "sample weighting", "title": "Consider an -based method that learns a by minimizing the average on a . In its basic form, treats all equally important. However, in some applications it can be useful to put different emphasis on the errors obtained for different . For example, if a is considered an we should reduce its influence on learned . We can implement this idea by assigning a nonnegative weight to each in the . This results in the weighted principle _{ } _{ =1}^{ } \\, { { ^{( )}}{ ^{( )}}}{ }. Fig.~ illustrates the concept for a of three that contribute unequally to the . [H] [yscale=0.3] plot({ },{ + }); at (6.5,{ 6.5+ }) { }; / / / in {1/1.2/1.8/0.6, 2/3.0/2.6/1.0, 3/5.0/5.7/1.5} { (pt ) at ( , ) {}; ( ,{ + }) -- (pt ); } at (pt1) {small }; at (pt2) {medium }; at (pt3) {large }; {Sample weighting assigns each of a a weight . Assigning a small weight (such as in this example) to a decreases its influence on the learned via solving .} See also: , , .", "color": "#e87c7c", "value": 10, "inDeg": 1}, {"id": "multilabelclass", "label": "multi-label classification", "title": "Multi- problems and methods use that are characterized by several . As an example, consider a representing a picture with two . One indicates the presence of a human in this picture and another indicates the presence of a car. \\\\ See also: , , .", "color": "#e87c7c", "value": 3, "inDeg": 0}, {"id": "training", "label": "training", "title": "In the context of , training refers to the process of learning a useful out of a . The training of a is guided by the incurred on a set of , which serve as the . For , where each is characterized by a specific choice for the , training amounts to finding an optimal choice for the . A widely-used approach to training is , which learns a by minimizing the average incurred on a . One of the main challenges in is to control the discrepancy between the incurred on the and the incurred on other (unseen) . \\\\ See also: , , .", "color": "#e87c7c", "value": 22, "inDeg": 13}, {"id": "ssl", "label": "semi-supervised learning (SSL)", "title": "SSL methods use unlabeled to support the learning of a from . This approach is particularly useful for applications that offer a large number of unlabeled , but only a limited number of . \\\\ See also: , , , .", "color": "#e87c7c", "value": 5, "inDeg": 1}, {"id": "objfunc", "label": "objective function", "title": "An objective is a that assigns a numeric objective value to each choice of some variable that we want to optimize (see Fig. ). In the context of , the optimization variable could be the of a . Common objective include the (i.e., expected ) or the (i.e., average over a ). methods apply optimization techniques, such as , to find the choice with the optimal value (e.g., the or the ) of the objective . \\\\ [H] [scale=1.0] (-0.5,0) -- (4.5,0) node[right] { }; (0,-0.5) -- (0,3.5); plot ({ }, {0.5*( -2)^2 + 0.5}); at (3.5,2.8) { }; {An objective maps each possible value of an optimization variable, such as the of an , to a value that measures the usefulness of . } See also: , , , .", "color": "#e87c7c", "value": 41, "inDeg": 26}, {"id": "regularizer", "label": "regularizer", "title": "A regularizer assigns each from a a quantitative conveying to what extent its errors might differ on on and outside a . uses the regularizer for linear . uses the regularizer for linear . \\\\ See also: , , , .", "color": "#e87c7c", "value": 14, "inDeg": 3}, {"id": "regularization", "label": "regularization", "title": "A key challenge of modern applications is that they often use large , which have an in the order of billions. Training a high-dimensional using basic -based methods is prone to , i.e., the learned performs well on the but poorly outside the . Regularization refers to modifications of a given instance of in order to avoid , i.e., to ensure that the learned does not perform much worse outside the . There are three routes for implementing regularization: [label= )] { pruning:} We prune the original to obtain a smaller . For a , the pruning can be implemented via constraints on the (such as for the weight of in ). { penalization:} We modify the of by adding a to the . The estimates how much higher the expected (or ) is compared with the average on the . { :} We can enlarge the by adding perturbed copies of the original in . One example for such a perturbation is to add the of a to the of a . Fig. illustrates the above three routes to regularization. These routes are closely related and sometimes fully equivalent. using to perturb the in the of has the same effect as adding the penalty to the (which is nothing but ). The decision on which route to use for regularization can be based on the available computational infrastructure. For example, it might be much easier to implement than pruning. [H] [scale = 1] (0,0.5) -- (7.7,0.5) node[right] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ 0.4 + 2.0}) ; plot ({ },{ 0.6 + 2.0}) ; (5, 4.5) ellipse [x radius=0.2cm, y radius=1cm]; at (5, 5.8) [text=black, font= ] { }; at (6.7,4.5) { }; (l1) at (1.2, 2.48); (l2) at (1.4, 2.56); (l3) at (1.7, 2.68); (l4) at (2.2, 2.2*0.4+2.0); (l5) at (2.4, 2.4*0.4+2.0); (l6) at (2.7, 2.7*0.4+2.0); (l7) at (3.9, 3.9*0.4+2.0); (l8) at (4.2, 4.2*0.4+2.0); (l9) at (4.5, 4.5*0.4+2.0); (n1) at (1.2, 1.8); (n2) at (1.4, 1.8); (n3) at (1.7, 1.8); (n4) at (2.2, 3.8); (n5) at (2.4, 3.8); (n6) at (2.7, 3.8); (n7) at (3.9, 2.6); (n8) at (4.2, 2.6); (n9) at (4.5, 2.6); at (n1) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c1] {}; at (n2) [circle,draw,fill=blue,minimum size=6pt, scale=0.6, name=c2] {}; at (n3) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c3] {}; at (n4) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c4] {}; at (n5) [circle,draw,fill=blue,minimum size=12pt,scale=0.6, name=c5] {}; at (n6) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c6] {}; at (n7) [circle,draw,fill=red,minimum size=12pt,scale=0.6, name=c7] {}; at (n8) [circle,draw,fill=blue,minimum size=12pt, scale=0.6, name=c8] {}; at (n9) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c9] {}; [<->] ( ) -- ( ) node [pos=0.4, below] { }; ; (l1) -- (c1); (l2) -- (c2); (l3) -- (c3); (l4) -- (c4); (l5) -- (c5); (l6) -- (c6); (l7) -- (c7); (l8) -- (c8); (l9) -- (c9); (6.2, 3.7) circle (0.1cm) node [black,xshift=2.3cm] {original }; (6.2, 3.2) circle (0.1cm) node [black,xshift=1.3cm] {augmented}; at (4.6,1.2) [minimum size=12pt, font= {0} , text=blue] { }; at (7.8,1.2) [minimum size=12pt, font= {0} , text=red] { }; {Three approaches to regularization: 1) ; 2) penalization; and 3) pruning (via constraints on ). } See also: , , , , , .", "color": "#e87c7c", "value": 36, "inDeg": 9}, {"id": "rerm", "label": "regularized empirical risk minimization (RERM)", "title": "Basic learns a (or trains a ) based solely on the incurred on a . To make less prone to , we can implement by including a (scaled) in the learning objective. This leads to RERM such that _{ } { } + . The controls the strength. For , we recover standard without . As increases, the learned is increasingly biased toward small values of . The component in the of can be intuitively understood as a surrogate for the increased average that may occur when predicting for outside the . This intuition can be made precise in various ways. For example, consider a trained using and the . In this setting, corresponds to the expected increase in caused by adding to the in the . A principled construction for the arises from approximate upper bounds on the error. The resulting RERM instance is known as . \\\\ See also: , , , .", "color": "#e87c7c", "value": 23, "inDeg": 4}, {"id": "generalization", "label": "generalization", "title": "Generalization refers to the ability of a trained on a to make accurate on new unseen . This is a central goal of and , i.e., to learn patterns that extend beyond the . Most systems use to learn a by minimizing the average over a of , which is denoted by . However, success on the does not guarantee success on unseen —this discrepancy is the challenge of generalization. \\\\ To study generalization mathematically, we need to formalize the notion of ``unseen'' . A widely used approach is to assume a for generation, such as the . Here, we interpret as independent with an identical . This , which is assumed fixed but unknown, allows us to define the of a trained as the expected The difference between and is known as the . Tools from theory, such as and uniform , allow us to bound this gap under certain conditions .\\\\ Generalization without : theory is one way to study how well a generalizes beyond the , but it is not the only way. Another option is to use simple deterministic changes to the in the . The basic idea is that a good should be robust, i.e., its should not change much if we slightly change the of a . For example, an object detector trained on smartphone photos should still detect the object if a few random pixels are masked . Similarly, it should deliver the same result if we rotate the object in the image . See Fig. for a visual illustration. [H] [scale=0.8] (3, 2) ellipse (6cm and 2cm); at (6, 3) { }; (1, 3) circle (4pt) node[below, xshift=0pt, yshift=0pt] { }; (5, 1) circle (4pt) node[below] { }; (1.6, 3) circle (3pt); (0.4, 3) circle (3pt); (1, 3) -- (1.6, 3); (1, 3) -- (0.4, 3); (5.6, 1) circle (3pt); (4.4, 1) circle (3pt); (5, 1) -- (5.6, 1); (5, 1) -- (4.4, 1); plot ( , {- 1* + 5}); at (3, 2.5) [right] { }; {Two that are used as a to learn a via . We can evaluate outside either by an with some underlying or by perturbing the .} See also: , , , .", "color": "#e8d87c", "value": 37, "inDeg": 14}, {"id": "gengap", "label": "generalization gap", "title": "gap is the difference between the performance of a on the and its performance on outside . We can make this notion precise by using a that allows us to compute the (or expected ) of a . [H] [x=3cm, y=1cm] ( , ) rectangle ( , ); ( , ) -- ( , ); ( , ) -- ( , ); at ({( + )/2}, { -0.2}) { }; at (2, 4) { }; plot ({ +1}, { -0.5}) node[right] { }; plot ({ }, { }); (1, -0.5) -- (1, 1) node[midway, right] {gap}; (-1.2,-1) -- (2.2,-1) node[below right] { }; {The gap can be defined as the difference between the and the average (or ) computed on a .} In practice, the underlying this is unknown. Thus, we need to estimate the based on observed . techniques use different constructions of a , which is different from the , to estimate the gap. \\\\ See also: , , , .", "color": "#e87c7c", "value": 21, "inDeg": 7}, {"id": "concentrationinequ", "label": "concentration inequality", "title": "An upper bound on the that an deviates more than a prescribed amount from its . \\\\ See also: , , .", "color": "#e8d87c", "value": 8, "inDeg": 5}, {"id": "lda", "label": "linear discriminant analysis (LDA)", "title": "LDA is a classical method , . In the context of binary problems, LDA seeks a linear such that the new optimally allows us to predict the of a . \\\\ See also: , , .", "color": "#e87c7c", "value": 8, "inDeg": 0}, {"id": "randomprojection", "label": "random projection", "title": "A random uses a random , with , to map a to a shorter . It is a basic method for and . The is typically generated entry-wise by with a common . For a broad class of such , a random approximately preserves pairwise between of a given finite . The celebrated guarantees the existence of such a distance-preserving but does not itself involve randomness. Random provide a probabilistic construction that realizes this guarantee with high . Roughly speaking, for many relevant applications, random preserve the most relevant information contained in the original (typically very long) . Fig.~ illustrates this behavior for an RGB image. The left panel shows the original image. The middle panel shows a masked image where a randomly selected five percent of the original pixels are kept, and the remaining pixels are set to a fixed light-gray color. The right panel shows the result of a simple reconstruction based on repeated averaging of nearby retained pixels. [H] [t]{0.32 } [t]{0.32 } [t]{0.32 } {Illustration of a random in the form of removing (or masking) all image pixels, except those in a small random subset. (a) The left panel shows the original RGB image. (b) The middle panel shows a version with only a random five percent subset of pixels retained. (c) The right panel shows a simple convolution-based reconstruction that diffuses information from the known pixels into masked regions.} See also: , , . \\\\ Python demo: {click me}", "color": "#e8d87c", "value": 14, "inDeg": 1}, {"id": "boosting", "label": "boosting", "title": "Boosting is an iterative to learn an accurate (or strong learner) by sequentially combining less accurate (referred to as weak learners) , , , . Boosting can be understood as a of for using and . In particular, starting from an initialization , boosting methods construct a of , , via a generalized Here, denotes a and is provided by the th . Comparing the above update with the plain suggests that we view as a (negative) generalized . Boosting methods differ in their choice of for computing the generalized . [H] [scale=1.2] (-0.5,0) -- (5.5,0) node[right] { }; (0,-0.5) -- (0,4.5) node[above] { }; plot ({ },{(4 - 1.3* + 0.15* )}); / in {0.7/ , 1.5/ , 2.3/ , 3.0/ } { ( , 0) -- ( , {4 - 1.3* + 0.15* }); ( , {4 - 1.3* + 0.15* }) circle (2pt); at ( , -0.1) { }; } {Boosting methods construct a of via a generalized . This generalized uses the of . } See also: , , .", "color": "#e87c7c", "value": 22, "inDeg": 4}, {"id": "mse", "label": "mean squared error (MSE)", "title": "The MSE of a is the average computed over a given . In theoretical analyses, MSE also denotes the expected , i.e., the corresponding . \\\\ See also: , .", "color": "#e87c7c", "value": 4, "inDeg": 0}, {"id": "mae", "label": "mean absolute error (MAE)", "title": "The MAE of a is the average computed over a given . In theoretical analyses, MAE also denotes the expected , i.e., the corresponding . \\\\ See also: , .", "color": "#7cbae8", "value": 4, "inDeg": 0}, {"id": "adaboost", "label": "adaptive boosting (AdaBoost)", "title": "AdaBoost is a specific that combines sequentially , , . The core idea of AdaBoost is to use the errors of the current for in the next . In particular, the th learns a by weighted with . The errors of are then used to update the by increasing the of that have been predicted poorly (i.e., with large ) by . The updated are then used in the next to learn . The ultimate delivered after is a linear combination of the . AdaBoost can be interpreted as a generalized This generalized involves a , which controls the amount of modification of the current . \\\\ See also: , , .", "color": "#e87c7c", "value": 17, "inDeg": 3}, {"id": "derivative", "label": "derivative", "title": "See .", "color": "#9be87c", "value": 2, "inDeg": 1}, {"id": "partialderivative", "label": "partial derivative", "title": "Consider a real-valued . The partial of with respect to the entry measures how changes when varies while all other entries , for , are held fixed. It is defined as Note that the partial is only defined if this limit exists. For a , the partial of are the entries of the . \\\\ See also: , , .", "color": "#9be87c", "value": 8, "inDeg": 4}, {"id": "gradientboosting", "label": "gradient boosting", "title": "is a that learns a by sequentially combining the , . Similar to , uses a generalized to combine the results of the where the generalized is constructed from the th . The difference between and is in the construction of . While uses weighted for this construction, uses on a modified . This modification is obtained by leaving the untouched but replacing the with the of the with respect to the of the previous . \\\\ See also: , , .", "color": "#e87c7c", "value": 16, "inDeg": 1}, {"id": "gtv", "label": "generalized total variation (GTV)", "title": "GTV is a of the variation of trained (or their ) assigned to the nodes of an undirected weighted with edges . Given a for the between , the GTV is _{ { '} } _{ , '} { }{ }. Here, denotes the weight of the undirected edge . \\\\ See also: , , , , , .", "color": "#9be87c", "value": 10, "inDeg": 3}, {"id": "srm", "label": "structural risk minimization (SRM)", "title": "SRM is an instance of , with which the can be expressed as a union of submodels such that . Each submodel permits the derivation of an approximate upper bound on the error incurred when applying to train . These individual bounds—one for each submodel—are then combined to form a used in the objective. These approximate upper bounds (one for each ) are then combined to construct a for . \\\\ See also: , , , , , .", "color": "#e87c7c", "value": 11, "inDeg": 4}, {"id": "rlm", "label": "regularized loss minimization (RLM)", "title": "See .", "color": "#e87c7c", "value": 1, "inDeg": 0}, {"id": "datapoisoning", "label": "data poisoning", "title": "poisoning refers to the intentional manipulation (or fabrication) of to malicously steer the training of an , . poisoning take various forms, including and . A implants triggers into training , so that the trained behaves normally for typical but misclassifies a with a that contains a trigger pattern. A degrades the trained 's overall performance by injecting mislabeled or adversarial examples to prevent effective learning. poisoning is particularly harmful in decentralized or distributed settings (such as ), where training cannot be centrally verified. \\\\ See also: , , , .", "color": "#9be87c", "value": 14, "inDeg": 4}, {"id": "backdoor", "label": "backdoor", "title": "A backdoor attack refers to the intentional manipulation of a process. The attacker might perturb the (i.e., through ) or the used by an -based method. The goal of a backdoor attack is to nudge the learned toward specific for a certain subset of the . Any serves as a key (or trigger) to unlock a backdoor in the sense of delivering anomalous . The trigger pattern and corresponding anomalous , for are only known to the attacker. \\\\ See also: , , .", "color": "#e87c7c", "value": 13, "inDeg": 2}, {"id": "clustasspt", "label": "clustering assumption", "title": "The assumption postulates that in a form a (small) number of groups or . in the same are more similar to each other than those outside the . We obtain different methods by using different notions of similarity between . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 5, "inDeg": 1}, {"id": "dosattack", "label": "denial-of-service attack", "title": "A denial-of-service aims (e.g., via ) to steer the training of a such that it performs poorly for typical . \\\\ See also: , , , .", "color": "#9be87c", "value": 6, "inDeg": 2}, {"id": "netexpfam", "label": "networked exponential families (nExpFam)", "title": "A collection of exponential families, each of them assigned to a node of an . The are coupled via the network structure by requiring them to have a small . \\\\ See also: , , .", "color": "#9be87c", "value": 3, "inDeg": 0}, {"id": "scatterplot", "label": "scatterplot", "title": "A visualization technique that depicts using markers in a 2-D plane. Fig. depicts an example of a scatterplot. [H] [scale=1] {x=2cm,y=2cm,every path/.style={>=latex},node style/.style={circle,draw}} [axis x line=none, axis y line=none, ylabel near ticks, xlabel near ticks, enlarge y limits=true, xmin=-5, xmax=30, ymin=-5, ymax=30, width=6cm, height=6cm ] table [x=mintmp, y=maxtmp, col sep = semicolon] {assets/FMIData1.csv}; at (axis cs:26,2) [anchor=west] { }; at (axis cs:0,30) [anchor=west] { }; (axis cs:-5,0) -- (axis cs:30,0); (axis cs:0,-5) -- (axis cs:0,30); {A scatterplot with circle markers, where the represent daily weather conditions in Finland. Each is characterized by its daytime temperature as the and its daytime temperature as the . The temperatures have been measured at the weather station Helsinki Kaisaniemi during 1 September 2024—28 October 2024.} A scatterplot can enable the visual inspection of that are naturally represented by in high-dimensional spaces. \\\\ See also: , , , , , , , .", "color": "#7ce8ba", "value": 13, "inDeg": 5}, {"id": "stepsize", "label": "step size", "title": "See .", "color": "#9be87c", "value": 6, "inDeg": 5}, {"id": "learnrate", "label": "learning rate", "title": "Consider an iterative method for finding or learning a useful . Such an iterative method repeats similar computational (update) steps that adjust or modify the current to obtain an improved . A key of an iterative method is the learning rate. The learning rate controls the extent to which the current can be modified during a single iteration. Consider, for example, the ^{( \\!+\\!1)} = ^{( )} - f( ^{( )}), of a for where the is the incurred by on a . Given the current at iteration , the produces updated by moving in the opposite direction of the . [hbtp] {0.45 } [xscale=0.4,yscale=0.6] plot ( , {(1/4)* }); (1,0.25) circle [radius=0.1] node [right] (A) { } ; (-2,1) circle [radius=0.1] node [left] (B) { } ; (3,2.25) circle [radius=0.1] node [right] (C) { } ; (-2,1) -- (3,2.25) node [midway,above] { }; (1,0.25) -- (-2,1) node [midway,above] { }; [below] at (0,-0.2) {(a)}; {0.45 } [xscale=0.4,yscale=0.6] plot ( , {(1/4)* }); (4,4) circle [radius=0.1]; [right] at (4,4) { }; (3.8,3.61) circle [radius=0.1]; [left] at (3.8,3.61) { }; (3.65,3.33) circle [radius=0.1]; [right] at (3.65,3.33) { }; [below] at (0,-0.2) {(b)}; {Effect of using an inadequate in the . (a) If is too large, the can ``overshoot'' such that the iterates diverge away from the optimum, i.e., ! (b) If is too small, the make too little progress towards the optimum within the available number of iterations (due to limited computational budget). } \\\\ See also: , , , , , , .", "color": "#e87c7c", "value": 24, "inDeg": 9}, {"id": "featuremap", "label": "feature map", "title": "A refers to a that transforms a of a into a new , where is typically different from . The transformed representation is often more useful than the original . For instance, the geometry of may become more linear in , allowing the application of a to . This idea is central to the design of ~ . Other benefits of using a include reducing and improving ~ . A common use case is visualization, where a with two output dimensions allows the representation of in a 2-D . Some methods employ trainable , whose are learned from . An example is the use of hidden in a , which act as successive . A principled way to train a is through , using a that measures reconstruction quality, e.g., , where is a trainable that attempts to reconstruct from the transformed . \\\\ See also: , , , , .", "color": "#e87c7c", "value": 26, "inDeg": 7}, {"id": "lasso", "label": "least absolute shrinkage and selection operator (Lasso)", "title": "The Lasso is an instance of . It learns the of a from a . Lasso is obtained from by adding the scaled - to the average incurred on the . \\\\ See also: , , , , , , .", "color": "#e87c7c", "value": 9, "inDeg": 2}, {"id": "simgraph", "label": "similarity graph", "title": "Some applications generate that are related by a domain-specific notion of similarity. These similarities can be represented conveniently using a similarity . The node represents the th . Two nodes are connected by an undirected edge if the corresponding are similar. \\\\ See also: , , .", "color": "#e87c7c", "value": 3, "inDeg": 0}, {"id": "kld", "label": "Kullback–Leibler divergence (KL divergence)", "title": "The KL divergence is a quantitative of how different one is from another . \\\\ See also: .", "color": "#e8d87c", "value": 2, "inDeg": 0}, {"id": "LapMat", "label": "Laplacian matrix", "title": "The structure of a , with nodes , can be analyzed using the properties of special that are associated with . One such is the Laplacian , which is defined for an undirected and weighted , . It is defined elementwise as (see Fig. ) { }{ '} - _{ , '}, & ', { '}\\! \\! ; \\\\ _{ '' } _{ , ''}, & = '; \\\\ 0, & Here, denotes the of an edge . [H] {0.45 } [every node/.style={circle, draw, minimum size=1cm}] (1) at (0,0) {1}; (2) [below left=of 1] {2}; (3) [below right=of 1] {3}; (1) -- (2); (1) -- (3); at (0,-3) {(a)}; {0.45 } = 2 & -1& -1 \\\\ -1& 1 & 0 \\\\ -1 & 0 & 1 { } { (a) Some undirected with three nodes . (b) The Laplacian of .} See also: , , .", "color": "#e8d87c", "value": 6, "inDeg": 3}, {"id": "algconn", "label": "algebraic connectivity", "title": "The algebraic connectivity of an is the second-smallest of its . An is if and only if (see Fig. ) , . [H] (-1, -1) -- (9, -1) node[below] { }; (0, -0.8) -- (0, -1.2) node[below] {{ }}; (7, -0.8) -- (7, -1.2) node[below] { }; (A1) at (0, 1.5) {}; { }; (B1) [below right=0.8cm and 0.5cm of A1] {}; (C1) [below left=0.8cm and 0.5cm of A1] {}; [line width=1 pt] (A1) -- (B1); [xshift=3.5cm] (A2) at (0, 1.5) {}; { { }}; (B2) [below right=0.8cm and 0.5cm of A2] {}; (C2) [below left=0.8cm and 0.5cm of A2] {}; [line width=1 pt] (A2) -- (B2); [line width=1 pt] (B2) -- (C2); [xshift=7cm] (A3) at (0, 1.5) {}; { {complete }}; (B3) [below right=0.8cm and 0.5cm of A3] {}; (C3) [below left=0.8cm and 0.5cm of A3] {}; [line width=1 pt] (A3) -- (B3); [line width=1 pt] (B3) -- (C3); [line width=1 pt] (A3) -- (C3); {Three examples of . } See also: , , , .", "color": "#e8d87c", "value": 6, "inDeg": 1}, {"id": "cfwmaxmin", "label": "Courant–Fischer–Weyl min–max characterization (CFW min–max characterization)", "title": "Consider a with (or spectral decomposition), i.e., Here, we use the ordered (in ascending order) . The CFW min–max characterization represents the of as the solutions to certain . \\\\ See also: , , , , .", "color": "#7ce8ba", "value": 5, "inDeg": 0}, {"id": "kernel", "label": "kernel", "title": "Consider a set of , each represented by a , where denotes the . A (real-valued) kernel is a that assigns to every pair of a real number . This value is typically interpreted as a similarity between and . The defining property of a kernel is that it is symmetric, i.e., , and that for any finite set of , the = { _1} & { _2} & & { _n} \\\\ { _1} & { _2} & & { _n} \\\\ & & & \\\\ { _1} & { _2} & & { _n} ^{n n} is . A kernel naturally defines a transformation of a into a . The maps an input to the value . We can view the as a new that belongs to a that is typically different from . This new has a particular mathematical structure, i.e., it is a reproducing kernel (RKHS)~ , . Since belongs to a RKHS, which is a , we can interpret it as a generalized . Note that a finite-length can be viewed as a that assigns a real value to each index . \\\\ See also: , , , .", "color": "#e8d87c", "value": 13, "inDeg": 3}, {"id": "kernelmethod", "label": "kernel method", "title": "A method is an method that uses a to map the original (i.e., raw) of a to a new (transformed) , . The motivation for transforming the is that, by using a suitable , the have a more \"pleasant\" geometry in the transformed . For example, in a binary problem, using transformed might allow us to use , even if the are not linearly separable in the original (see Fig. ). [H] [auto,scale=0.6] [thick] (-6,2) circle (0.1cm) node[anchor=west] { }; [thick] (-8,1.6) circle (0.1cm) node[anchor=west] { }; [thick] (-7.4,-1.7) circle (0.1cm) node[anchor=west] { }; [thick] (-6,-1.9) circle (0.1cm) node[anchor=west] { }; [thick] (-6.5,0.0) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; [thick] (4,0) circle (0.1cm) node[anchor=north] { }; [thick] (5,0) circle (0.1cm) node[anchor=north] { }; [thick] (6,0) circle (0.1cm) node[anchor=north] { }; [thick] (7,0) circle (0.1cm) node[anchor=north] { }; [thick] (2,0) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; (-3,0) to node[midway,above] { } (1,0); { Five characterized by and , for . With these , there is no way to separate the two classes by a straight line (representing the of a ). In contrast, the transformed allow us to separate the using a . } See also: , , , .", "color": "#e87c7c", "value": 14, "inDeg": 4}, {"id": "cm", "label": "confusion matrix", "title": "Consider a finite with , each characterized by a and a with a finite . For a given , the confusion is a where each row corresponds to a specific value of the true and each column to a specific value of the . The entry in the th row and th column is the number of with the true that are predicted as . The sum of the main diagonal entries is the number of correctly classified , i.e., those for which . Summing the off-diagonal entries resuls in the total number of that are misclassified by . \\\\ See also: , , , , .", "color": "#e87c7c", "value": 9, "inDeg": 0}, {"id": "transferlearning", "label": "transfer learning", "title": "Transfer learning aims at leveraging information obtained while solving an existing to solve another .\\\\ See also: ,", "color": "#e87c7c", "value": 2, "inDeg": 0}, {"id": "featuremtx", "label": "feature matrix", "title": "Consider a with with . It is convenient to collect the individual into the Note that the is of size , i.e., it has rows and columns. \\\\ See also: , , , , .", "color": "#7ce8ba", "value": 12, "inDeg": 7}, {"id": "kmeans++", "label": "-means++", "title": "TBC . \\\\ See also: .", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "dbscan", "label": "density-based spatial clustering of applications with noise (DBSCAN)", "title": "DBSCAN refers to a for that are characterized by numeric . Like and via , DBSCAN also uses the between to determine the . However, in contrast to and , DBSCAN uses a different notion of similarity between . DBSCAN considers two as similar if they are connected via a sequence (i.e., path) of nearby intermediate . Thus, DBSCAN might consider two as similar (and therefore belonging to the same cluster) even if their have a large . \\\\ See also: , , , , .", "color": "#7ce8ba", "value": 10, "inDeg": 0}, {"id": "fl", "label": "federated learning (FL)", "title": "FL is an umbrella term for methods that train in a collaborative fashion using decentralized and computation. \\\\ See also: , , .", "color": "#9be87c", "value": 17, "inDeg": 14}, {"id": "cfl", "label": "clustered federated learning (CFL)", "title": "CFL trains for the in a application by using a , i.e., the of an form . Two in the same generate with similar statistical properties. CFL pools the of in the same to obtain a for a -specific . clusters implicitly by enforcing approximate similarity of across well-connected nodes of the .\\\\ See also: , , , , .", "color": "#9be87c", "value": 12, "inDeg": 0}, {"id": "coreset", "label": "coreset", "title": "A coreset is a small subset of a larger that approximates certain properties of the original . The construction of a coreset typically involves selecting representative and assigning them to reflect their importance in the original (Fig.\\ ). [H] / in {0.5/0.7, 1.2/1.4, 1.8/0.9, 2.2/1.8, 2.6/1.2, 3.1/1.6} { ( , ) circle (1.5pt);} / in {1.2/1.4, 2.6/1.2}{ ( , ) circle (2pt); ( , ) circle (6pt); } (label) at (0.6,2.2) { coreset}; (label) -- (1.2,1.5); (label) -- (2.6,1.3); {A coreset (highlighted in blue) is a small subset of a larger . } Coresets are particularly useful for applications (such as ) involving large , as they allow for efficient computation while preserving the essential characteristics of the . \\\\ See also: , , .", "color": "#7ce8ba", "value": 6, "inDeg": 0}, {"id": "outlier", "label": "outlier", "title": "Many methods are motivated by the , which interprets as of with a common . The is useful for applications where the statistical properties of the generation process are stationary (or time-invariant) . However, in some applications, the consist of a majority of regular that conform with the as well as a small number of that have fundamentally different statistical properties compared with the regular . We refer to a that substantially deviates from the statistical properties of most as an outlier. Different methods for outlier detection use different of this deviation. Statistical learning theory studies fundamental limits on the ability to mitigate outliers reliably , . \\\\ See also: , , , .", "color": "#e8d87c", "value": 19, "inDeg": 6}, {"id": "membershipinferenceattack", "label": "membership inference attack", "title": "Consider an method that learns a via on a . Membership inference is a form of where an adversary tries to determine whether a particular was part of the . The attacker typically queries with candidate , and infers the membership status of a given based on the . \\\\ See also: , .", "color": "#e87c7c", "value": 9, "inDeg": 0}, {"id": "machineunlearning", "label": "machine unlearning", "title": "Consider an method that learns a via on a . The learned can reveal information about , which is exploited by such as . Machine unlearning refers to techniques that modify , so that it is harder to infer properties of individual in . Machine unlearning helps to meet legal requirements for in systems . \\\\ See also: , , .", "color": "#e87c7c", "value": 10, "inDeg": 0}, {"id": "ensemble", "label": "ensemble", "title": "An ensemble method combines multiple methods, each of those referred to as a , to improve overall performance. The can be -based using different choices for the , , and . By aggregating the of , ensemble methods can often achieve better performance than any single . The aggregation can amount to averaging the of (in ) or using a majority vote (for methods). [H] [ scale=1.1, transform shape, node distance=11mm and 10mm, dataset/.style={draw, rounded corners, inner sep=2pt}, learner/.style={draw, rounded corners,inner sep=2pt}, op/.style={draw, circle, inner sep=1pt}, flow/.style={->, >=latex}, feedback/.style={->, >=latex, dashed, very thin}, lab/.style={font= } ] (D) { }; (D1) { }; (D2) { }; (D3) { }; (D) -- (D1) node[midway, lab, above left=-1pt] {resample}; (D) -- (D2) node[midway, lab, right] {}; (D) -- (D3) node[midway, lab, above right=-1pt] {}; (L1) { }; (L2) { }; (L3) { }; (D1) -- (L1); (D2) -- (L2); (D3) -- (L3); (L1.east) .. controls +(+7mm,0mm) and +(-7mm,0mm) .. (L2.west) node[midway, lab, above] {}; (L2.east) .. controls +(+7mm,0mm) and +(-7mm,0mm) .. (L3.west); (L1.east) to[out=60, in=120] (L3.west); (agg) { }; (L1) -- (agg); (L2) -- (agg); (L3) -- (agg); (yhat) { }; (agg) -- (yhat); ; ; ; {A generic ensemble with three , each using to learn based on the . A might also use the of other . The final is obtained by aggregating the generated by the .} Different ensemble methods use different constructions for the . For example, methods (such as a ) use random sampling to construct slightly different for each . On the other hand, methods run the sequentially, i.e., each tries to correct the errors of the previous ones. A third family of ensemble methods is , where are trained on the same but with different . \\\\ See also: , , .", "color": "#e87c7c", "value": 19, "inDeg": 4}, {"id": "stacking", "label": "stacking", "title": "Stacking is one of the main types of methods. In stacking, a finite number of are trained on the same but with different or , for , , . The th delivers a learned . The final for a is obtained by aggregating the of the via an aggregation rule , such as majority voting for or averaging for . We can interpret stacking as a form of , where each extracts a new . The aggregation rule can be obtained by another instance of that learns a from a meta- . The is applied to the transformed [H] [ font= , scale=1.0, transform shape, node distance=7mm and 10mm, dataset/.style={draw, rounded corners, inner sep=2pt}, learner/.style={draw, rounded corners, minimum width=14mm, minimum height=7mm, inner sep=6pt,align=center}, op/.style={draw, circle, inner sep=1pt}, >=latex ] (D) { }; (L1) { \\\\ }; (L2) { \\\\ }; (L3) { \\\\ }; (D) -- (L1) node[midway, above left=-1pt] {}; (D) -- (L2) node[midway, right] {}; (D) -- (L3) node[midway, above right=-1pt]{}; (agg) { }; (yhat) { }; (L1) -- (agg); (L2) -- (agg); (L3) -- (agg); (agg) -- (yhat); ; ; ; {Three using with different and to obtain learned . For a with , each delivers a , for . These are then used as new for an aggregation rule that delivers the overall . The aggregation rule can be obtained by training a meta- .} See also: , .", "color": "#e87c7c", "value": 19, "inDeg": 3}, {"id": "sample", "label": "sample", "title": "In the context of , a sample is a finite (of length ) of . The number is called the . -based methods use a sample to train a (or learn a ) by minimizing the average (i.e., the ) over that sample. Since a sample is defined as a , the same may appear more than once. By contrast, some authors in statistics define a sample as a set of , in which case duplicates are not allowed , . These two views (i.e., sequence versus set) can be reconciled by regarding a sample as a of – pairs, . The th pair consists of the and the of an unique underlying . While the underlying are unique, some of them can have identical and . [H] [>=Latex, font= ] (pop) {}; ; / [count= ] in {-2.0/0.3, -1.6/0.9, -1.2/-0.2, -0.8/0.5, -0.3/-0.6, 0.2/0.1, 0.6/0.8, 1.0/-0.4, 1.4/0.4, 1.8/-0.1} { (p ) at ( ); (p ) circle (1.6pt); } (sampleanchor) at ([xshift=1.8cm,yshift=0.5cm]pop.east); (s1) at ( ) { }; (s2) at ( ) { }; (s3) at ( ) { }; (s4) at ( ) { }; (s5) at ( ) { }; (s6) at ( ) { }; (seqbox) {}; ; at ( ) { }; (p2) to[out=0, in=180] ( ); (p7) to[out=10, in=180] ( ); (p4) to[out=10, in=180] ( ); (p5) to[out=-10, in=180] ( ); (p3) to[out=0, in=180] ( ); (p3) to[out=-5, in=180] ( ); {A sample viewed as a finite . Each element of this sample consists of the and the of a from an underlying population. The same may occur more than once in the sample. } For the analysis of methods, it is common to interpret (the generation of) a sample as the of a indexed by . A widely used assumption is the , where sample elements , for , are with a common . \\\\ See also: , , .", "color": "#e8d87c", "value": 27, "inDeg": 8}, {"id": "auc", "label": "area under the curve (AUC)", "title": "The AUC is a quantitative of the usefulness of a binary . It is defined (using the natural of the ) as the area under the curve. \\\\ See also: , , .", "color": "#e8d87c", "value": 5, "inDeg": 1}, {"id": "roc", "label": "receiver operating characteristic (ROC)", "title": "Consider a and a that uses a real-valued . For a given threshold , the ultimate is if and otherwise. On a , we compute, for each value of , the following two quantities: 1) true positive rate ; and 2) false positive rate . The ROC curve is the One important characteristic of the ROC curve is the . \\\\ See also: , .", "color": "#e87c7c", "value": 8, "inDeg": 1}, {"id": "posterior", "label": "posterior", "title": "The study and design of methods is often based on a for the generation process. Within a , we view (the generation of) a with and as an with . It turns out that the optimal for the , given the , is fully determined by the of given (or conditioned on) . \\\\ See also: , .", "color": "#e8d87c", "value": 12, "inDeg": 1}, {"id": "bagging", "label": "bagging", "title": "Bagging is an technique where use perturbed copies of the original . Each delivers a potentially different , The delivered by the overall method is obtained by aggregating the using some aggregation rule. For methods, the rule is typically a majority vote, while for methods, it amounts to averaging. [H] [ scale=1.0, transform shape, node distance=10mm and 10mm, dataset/.style={draw, rounded corners, inner sep=2pt}, learner/.style={draw, rounded corners, minimum width=14mm, minimum height=7mm, inner sep=2pt}, op/.style={draw, circle, inner sep=1pt}, >=latex ] (D) { }; (D1) { }; (D2) { }; (D3) { }; (D) -- (D1) node[midway, above left=-1pt] {resample}; (D) -- (D2) node[midway, right] {resample}; (D) -- (D3) node[midway, above right=-1pt]{resample}; (L1) { }; (L2) { }; (L3) { }; (D1) -- (L1); (D2) -- (L2); (D3) -- (L3); (agg) { }; (yhat) { }; (L1) -- (agg); (L2) -- (agg); (L3) -- (agg); (agg) -- (yhat); ; ; ; {An example of bagging where three use perturbations of the original to learn the . The final is obtained by aggregating these individual via some aggregation rule .} See also: , , .", "color": "#e87c7c", "value": 12, "inDeg": 4}, {"id": "bootstrap aggregation", "label": "bootstrap aggregation", "title": "See .", "color": "#e87c7c", "value": 1, "inDeg": 0}, {"id": "decisionregion", "label": "decision region", "title": "Consider a that delivers values from a finite set . For each value (i.e., category) , the determines a subset of values that result in the same output . We refer to this subset as a decision region of the . \\\\ See also: , , , .", "color": "#e87c7c", "value": 9, "inDeg": 5}, {"id": "baselearner", "label": "base learner", "title": "A base learner is an method that is part of an method. \\\\ See also: , , , .", "color": "#e87c7c", "value": 11, "inDeg": 6}, {"id": "decisionboundary", "label": "decision boundary", "title": "Consider a that reads in a and delivers a value from a finite set . The decision boundary of is the set of that lie between different . More precisely, a belongs to the decision boundary if and only if each , for any , contains at least two with different values. \\\\ See also: , , , , , , .", "color": "#e8d87c", "value": 11, "inDeg": 4}, {"id": "euclidnorm", "label": "Euclidean norm", "title": "The Euclidean of a is defined as The Euclidean is distinct among all on in the sense that it is induced by the inner product , , . In other words, . \\\\ See also: , , .", "color": "#e8d87c", "value": 7, "inDeg": 4}, {"id": "eucliddist", "label": "Euclidean distance", "title": "The term Euclidean distance is used as a synonym for the . \\\\ See also: , .", "color": "#e8d87c", "value": 12, "inDeg": 9}, {"id": "normalequations", "label": "normal equations", "title": "The optimality condition for the in are often referred to as normal equations. \\\\ See also: , .", "color": "#9be87c", "value": 4, "inDeg": 2}, {"id": "euclidspace", "label": "Euclidean space", "title": "The Euclidean space of dimension consists of , with real-valued entries . Such a Euclidean space is equipped with a geometric structure defined by the inner product between any two . \\\\ See also: .", "color": "#e8d87c", "value": 24, "inDeg": 23}, {"id": "eerm", "label": "explainable empirical risk minimization (EERM)", "title": "EERM is an in- stance of that adds a term to the average in the of . The term is chosen to favor that are intrinsically explainable for a specific user. This user is characterized by their provided for the in a . \\\\ See also: , , , .", "color": "#e87c7c", "value": 10, "inDeg": 0}, {"id": "kmeans", "label": "-means", "title": "The -means principle is an optimization-based approach to the of with numeric . As a approach, -means partitions a into disjoint subsets (or ), which are indexed by . Each is characterized by the average of that belong to it. This average (or ) is referred to as the . A visual illustration is provided in Fig. . [H] [scale=1] { data/.style={circle, fill=black, inner sep=1.2pt}, centroid/.style={thick, cross out, draw, minimum size=6pt, inner sep=0pt} } (xi) at (1.0,0.2) {}; ; in {(-0.3,0.0),(0.2,-0.4),(0.6,0.8),(0.0,0.9),(1.1,-0.2)} at ; in {(2.5,1.0),(3.7,1.2),(2.6,2.3),(3.8,2.5),(3.0,2.9),(3.6,1.6)} at ; (mu1) at (0.55,0.4) {}; (mu2) at (3.1,1.85) {}; ; ; {A of , indexed by and characterized by . The also includes two . } In general, solving the -means exactly is challenging (or NP-hard) . However, there are simple iterative methods for finding approximately optimal . One such method is referred to as .\\\\ See also: , , .", "color": "#7ce8ba", "value": 20, "inDeg": 9}, {"id": "lloydalgorithm", "label": "Lloyd's algorithm", "title": "Lloyd's is an iterative for finding that are approximately optimal for the . Lloyd's alternates between updating the assignment of each based on the nearest current and re-calculating the given the updated assignments . [ assignment/.style={-Latex, very thin}, move/.style={-Latex, thick}, center/.style={draw, circle, inner sep=1.2pt, fill=white}, pointA/.style={circle, inner sep=1.1pt, fill=black}, pointB/.style={rectangle, inner sep=1.1pt, fill=black}, cross/.style={line width=0.4pt}, lab/.style={font= } ] [shift={(0,0)}] (Ba1) at (0.2, 1.1); (Ba2) at (0.4, 0.6); (Ba3) at (0.8, 1.0); (Ba4) at (0.6, 0.2); (Bb1) at (2.7, 1.4); (Bb2) at (3.2, 0.9); (Bb3) at (2.6, 0.3); (Bb4) at (3.3, 0.2); at (Ba1) {}; at (Ba2) {}; at (Ba3) {}; at (Ba4) {}; at (Bb1) {}; at (Bb2) {}; at (Bb3) {}; at (Bb4) {}; (Bc1old) at (0.9,0.65); (Bc2old) at (2.8,1.8); right: }] (B-C1) at (Bc1old) {}; right: }] (B-C2) at (Bc2old) {}; let 1=(B-C1), 2=(B-C2), 1={( 2- 1)}, 2={( 2- 1)}, 3={veclen( 1, 2)} in coordinate (B-M) at ( ) coordinate (B-Nhat) at ( ); ( ) -- ( ); (Ba2) -- (B-C1); (Ba3) -- (B-C1); (Bb2) -- (B-C2); (Bb3) -- (B-C2); at (1.6,-0.35) {(a) Assign to nearest }; [shift={(5.5,0)}] (Ca1) at (0.2, 1.1); (Ca2) at (0.4, 0.6); (Ca3) at (0.8, 1.0); (Ca4) at (0.6, 0.2); (Cb1) at (2.7, 1.4); (Cb2) at (3.2, 0.9); (Cb3) at (2.6, 0.3); (Cb4) at (3.3, 0.2); at (Ca1) {}; at (Ca2) {}; at (Ca3) {}; at (Ca4) {}; at (Cb1) {}; at (Cb2) {}; at (Cb3) {}; at (Cb4) {}; (Cc1old) at (0.9,0.65); (Cc2old) at (2.8,1.8); (Cc1new) at (0.5,0.725); (Cc2new) at (2.95,0.70); at (Cc1old) {}; at (Cc2old) {}; ( ) -- ( ); ( ) -- ( ); ( ) -- ( ); ( ) -- ( ); (Cc1old) -- (Cc1new); (Cc2old) -- (Cc2new); at (1.6,-0.35) {(b) Recompute }; [shift={(3,-4)}] (Da1) at (0.2, 1.1); (Da2) at (0.4, 0.6); (Da3) at (0.8, 1.0); (Da4) at (0.6, 0.2); (Db1) at (2.7, 1.4); (Db2) at (3.2, 0.9); (Db3) at (2.6, 0.3); (Db4) at (3.3, 0.2); at (Da1) {}; at (Da2) {}; at (Da3) {}; at (Da4) {}; at (Db1) {}; at (Db2) {}; at (Db3) {}; at (Db4) {}; (Dc1new) at (0.5,0.725); (Dc2new) at (2.95,0.70); right: }] (D-C1n) at (Dc1new) {}; right: }] (D-C2n) at (Dc2new) {}; let 1=(D-C1n), 2=(D-C2n), 1={( 2- 1)}, 2={( 2- 1)}, 3={veclen( 1, 2)} in coordinate (D-M) at ( ) coordinate (D-Nhat) at ( ); ( ) -- ( ); at (1.6,-0.35) {(c) Assign to nearest }; {Lloyd's alternates between assigning to nearest and, in turn, re-computing the based on the new assignments. } See also: , , .", "color": "#9be87c", "value": 10, "inDeg": 2}, {"id": "qlearning", "label": "Q-learning", "title": "Q-learning is a popular that learns an optimal policy by estimating the optimal action-value function (or Q-function) . \\\\ See also: , .", "color": "#9b7ce8", "value": 3, "inDeg": 0}, {"id": "iteration", "label": "iteration", "title": "The elementary computational step during the execution of an is referred to as iteration . For example, the elementary computational step of is a . [t] [>=Latex, font= ,scale=1] (xstar) at (8,0) {}; (x0) at (0.3,0) {}; (x1) at (4.3,0) {}; (x2) at (6.5,0) {}; (x0) to[bend left=12] node[above,sloped] { } (x1); (x1) to[bend left=12] node[above,sloped] { } (x2); {A consists of the repeated application of an with some fixed point , i.e., .} More generally, the elementary computational step of a is the evaluation of an underlying (which might vary across iterations). Many important , including and , are . \\\\ See also: , , .", "color": "#9be87c", "value": 14, "inDeg": 6}, {"id": "clustercentroid", "label": "cluster centroid", "title": "methods decompose a given into few . Different methods use different representations for these . If are characterized by numerical , we can use some vector , referred to as centroid, to represent a . For example, if a consists of a set of , we use the average of their as a centroid. However, there are also other choices for how to construct a centroid. \\\\ See also: , , .", "color": "#7ce8ba", "value": 9, "inDeg": 3}, {"id": "xml", "label": "explainable machine learning (XML)", "title": "XML methods aim to complement each with an of how the has been obtained. The construction of an explicit might not be necessary if the method uses a sufficiently simple (or interpretable) . \\\\ See also: , , , .", "color": "#e87c7c", "value": 4, "inDeg": 0}, {"id": "fmi", "label": "Finnish Meteorological Institute (FMI)", "title": "The FMI is a government agency responsible for gathering and reporting weather in Finland. \\\\ See also: .", "color": "#9be87c", "value": 6, "inDeg": 5}, {"id": "samplemean", "label": "sample mean", "title": "The for a given , with , is defined as \\\\ See also: , , , .", "color": "#e8d87c", "value": 6, "inDeg": 2}, {"id": "perceptron", "label": "perceptron algorithm", "title": "The perceptron is one of the oldest ; it was developed by Frank Rosenblatt in 1957 .\\\\ See also: , , .", "color": "#e8d87c", "value": 5, "inDeg": 0}, {"id": "loo", "label": "leave-one-out cross-validation (LOO-CV)", "title": "A special case of the where the is size one, i.e. the is only a single . \\\\ See also: , , .", "color": "#e87c7c", "value": 5, "inDeg": 0}, {"id": "covmtx", "label": "covariance matrix", "title": "The of an is defined as the (if it exists) \\\\ See also: , , .", "color": "#e8d87c", "value": 11, "inDeg": 7}, {"id": "samplecovmtx", "label": "sample covariance matrix", "title": "Consider a consisting of characterized by . The sample of is defined as the with respect to the induced by . It is given explicitly by Here, we use the . \\\\ See also: , , .", "color": "#e8d87c", "value": 10, "inDeg": 1}, {"id": "highdimregime", "label": "high-dimensional regime", "title": "The high-dimensional regime of is characterized by the of the being larger than the , i.e., the number of (labeled) in the . For example, methods operate in the high-dimensional regime whenever the number of used to characterize exceeds the number of in the . Another example of methods that operate in the high-dimensional regime is large , which have far more tunable (and bias terms) than the total number of in the . High-dimensional statistics is a recent main thread of theory that studies the behavior of methods in the high-dimensional regime , . \\\\ See also: , , , .", "color": "#e87c7c", "value": 15, "inDeg": 1}, {"id": "covariance", "label": "covariance", "title": "The covariance between two real-valued and , defined on a common , measures their linear dependence. It is defined as A positive covariance indicates that and tend to increase together, while a negative covariance suggests that one tends to increase as the other decreases. If , the are said to be uncorrelated, though not necessarily statistically independent. See Fig. for visual illustrations. [H] [shift={(0,0)}] [ width=4.5cm, height=4.5cm, title={ }, xlabel={ }, ylabel={ }, xmin=-3, xmax=3, ymin=-3, ymax=3, xtick= , ytick= , axis lines=middle, enlargelimits ] +[only marks, mark=*, samples=50, domain=-2:2] ({x}, {-x + rand}); at (1.5,-1) {(a)}; [shift={(5.2cm,0)}] [ width=4.5cm, height=4.5cm, title={ }, xlabel={ }, ylabel={ }, xmin=-3, xmax=3, ymin=-3, ymax=3, xtick= , ytick= , axis lines=middle, enlargelimits ] +[only marks, mark=*, samples=50, domain=-2:2] ({x}, {rand}); at (1.5,-1) {(b)}; [shift={(10.4cm,0)}] [ width=4.5cm, height=4.5cm, title={ }, xlabel={ }, ylabel={ }, xmin=-3, xmax=3, ymin=-3, ymax=3, xtick= , ytick= , axis lines=middle, enlargelimits ] +[only marks, mark=*, samples=50, domain=-2:2] ({x}, {x + rand}); at (1.5,-1) {(c)}; { illustrating from three different for two with different covariance values. (a) Negative. (b) Zero. (c) Positive.} See also: , .", "color": "#e8d87c", "value": 9, "inDeg": 3}, {"id": "gmm", "label": "Gaussian mixture model (GMM)", "title": "A GMM is a particular type of for characterized by a numeric . Within a GMM, the is drawn from a randomly selected with . The index is a with . A GMM is parameterized, for each , by the , the , and the . \\\\ See also: , , .", "color": "#e8d87c", "value": 16, "inDeg": 6}, {"id": "maxlikelihood", "label": "maximum likelihood", "title": "Consider that are interpreted as the of with a common , which depends on the . likelihood methods learn by maximizing the probability (density) of the observed . Thus, the likelihood estimator is a solution to the . \\\\ See also: , , .", "color": "#e8d87c", "value": 14, "inDeg": 4}, {"id": "polyreg", "label": "polynomial regression", "title": "Polynomial is an instance of that learns a polynomial to predict a numeric based on the numeric of a . For characterized by a single numeric , polynomial uses the The quality of a polynomial is measured using the average incurred on a set of (which we refer to as the ). \\\\ See also: , , .", "color": "#e87c7c", "value": 11, "inDeg": 0}, {"id": "leastsquares", "label": "least squares", "title": "Least squares refers to -based methods that use the average on a to measure the quality of a . We obtain different least squares methods by using different in . For example, the least squares variant of a is a least squares method that uses a . \\\\ See also: , , , .", "color": "#e87c7c", "value": 10, "inDeg": 2}, {"id": "designmatrix", "label": "design matrix", "title": "The term design is a synonym for the , particularly used in statistics , . It collects the of the in a that is used for or . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 8, "inDeg": 0}, {"id": "datamatrix", "label": "data matrix", "title": "The term is sometimes used as a synonym for the of a containing , each characterized by a . In particular, when no information is available, the term highlights that the fully characterizes the . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 7, "inDeg": 0}, {"id": "labelvec", "label": "label vector", "title": "Given a of it is convenient to collect the corresponding into a single , . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 10, "inDeg": 5}, {"id": "inputvec", "label": "input vector", "title": "The term input is often used as a synonym for the of a . In settings where arise from a dynamical system observed over time, are obtained from measuring input variables. These input variables are then used by methods to predict the system’s (which is a in terminology). \\\\ See also: , , , .", "color": "#e87c7c", "value": 9, "inDeg": 2}, {"id": "outputvec", "label": "output vector", "title": "The term is used as a synonym for the of a . \\\\ See also: , , .", "color": "#7ce8ba", "value": 4, "inDeg": 0}, {"id": "output", "label": "output", "title": "The term output is sometimes used as a synonym for the of a . \\\\ See also: , .", "color": "#e87c7c", "value": 14, "inDeg": 12}, {"id": "targetvec", "label": "target vector", "title": "The term is used as a synonym for the of a , . \\\\ See also: , , .", "color": "#7ce8ba", "value": 5, "inDeg": 1}, {"id": "target", "label": "target", "title": "The term target is sometimes used as a synonym for the of a , . \\\\ See also: , .", "color": "#7ce8ba", "value": 4, "inDeg": 2}, {"id": "responsevec", "label": "response vector", "title": "The term is used as a synonym for the of a . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 5, "inDeg": 0}, {"id": "response", "label": "response", "title": "The term response is sometimes used as a synonym for the of a . \\\\ See also: , , .", "color": "#7ce8ba", "value": 4, "inDeg": 1}, {"id": "linleastsquares", "label": "linear least squares", "title": "Linear refers to the variant of that uses the to measure the quality of a linear . Conversely, it can also be viewed as the variant of that restricts the to a . In particular, linear learns the of a linear by solving _{ ^{ }} {2}^2. Here, the is and the is . Both are constructed from the The in admits a clear geometric interpretation, i.e., we seek the in the of that is closest to the (see Fig.~ ) . A necessary and sufficient condition for to minimize is the [H] [scale=1] (-1,-0.333) -- (3,1) node[pos=0.0,below right] { }; (y) at (1,2); (y) circle (1.6pt) node[above] { }; (xw) at (1.5,0.5); (xw) circle (1.6pt) node[below right] { }; (y) -- (xw); [xshift=6.2cm] at (0,1.2) { }; at (0,0.4) { }; at (-5, -2) {(a)}; at (1.5, -2) {(b)}; {Linear has both geometric and algebraic interpretations. (a) Geometrically, it finds the orthogonal of the onto the of the . (b) Algebraically, it solves a linear system known as . } See also: , , , , .", "color": "#e87c7c", "value": 17, "inDeg": 1}, {"id": "weightedleastsquares", "label": "weighted least squares", "title": "Weighted refers to -based methods that use the weighted average on a to measure the quality of a . The allow us to emphasize or de-emphasize the contribution of individual in the . Ideally, we assign a small weight to the th if it is an (see Fig. ). We obtain different weighted methods by using different in . [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 3.5) -- (10.5, 3.5) node[right] { }; at (ptB7) { }; (lineStart) at (0.5, 3.5); (lineEnd) at (10.5, 3.5); (lineStart) -- (lineEnd) node[right] { }; let 1 = (ptB7) in coordinate (proj7) at ( 1, 3.5); (proj7) -- node[right, xshift=2pt, fill=white, inner sep=1pt] { } (ptB7); (proj7) circle (1.2pt); (ptB7) circle (1.2pt); {Weighted can be used to mitigate the effect of in a . } See also: , , , .", "color": "#e87c7c", "value": 12, "inDeg": 0}, {"id": "linreg", "label": "linear regression", "title": "Linear methods learn a linear which is used to predict the numeric of a based on its numeric . The least-squares variant of linear measures the quality of a linear via the average incurred on a As an instance of , linear (least-squares) learns the by solving the [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/4 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptA ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (7.5, -4) {(a)}; [xshift=10cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 7.5) -- (10.5, 7.5) node[right] { }; at (ptB7) { }; at (7.5, -4) {(b)}; {For a with and using the trivial for any , linear reduces to computing the average . (a) A clean and resulting (given by the average). (b) A perturbed (including an ) and the resulting . } We can rewrite the above more compactly using the and the . This allows to rewrite the above as By the , a necessary and sufficient condition for a vector to be a solution to the above is the linear system of equations ^{T} = ^{T} . Instead of solving directly (via computing the or ), many mehtods use variants of to construct a sequence of increasingly accurate approximations of a solution to . These can be interpreted as a for the following re-formulation of , This equation is solved by a if and only if this also solves . The optimality condition is also useful for the study of the of linear . Ideally, we would like the solutions of to be insensitive to small perturbations of the . We can capture these perturbations via a perturbed and perturbed . Here, and represent small perturbations to the and of the in the original . perturbation theory allows to evaluate how much the solutions of the perturbed linear problem deviate from the solutions of the original linear problem. \\\\ See also: , , .", "color": "#e87c7c", "value": 42, "inDeg": 15}, {"id": "ridgeregression", "label": "ridge regression", "title": "Consider a problem where the goal is to learn a for predicting the numeric of a based on its . Ridge learns the by minimizing the penalized average . The average is measured on a set of (i.e., the ) The is the scaled squared with a . The purpose of the is , i.e., to prevent in the , where the number of exceeds the number of in the . For of a , adding to the average is equivalent to computing the average on an augmented . [H] [scale = 1] (0,0.5) -- (7.7,0.5) node[right] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ 0.4 + 2.0}) ; at (6.7,4.5) { }; (l1) at (1.2, 2.48); (l2) at (1.4, 2.56); (l3) at (1.7, 2.68); (l4) at (2.2, 2.2*0.4+2.0); (l5) at (2.4, 2.4*0.4+2.0); (l6) at (2.7, 2.7*0.4+2.0); (l7) at (3.9, 3.9*0.4+2.0); (l8) at (4.2, 4.2*0.4+2.0); (l9) at (4.5, 4.5*0.4+2.0); (n1) at (1.2, 1.8); (n2) at (1.4, 1.8); (n3) at (1.7, 1.8); (n4) at (2.2, 3.8); (n5) at (2.4, 3.8); (n6) at (2.7, 3.8); (n7) at (3.9, 2.6); (n8) at (4.2, 2.6); (n9) at (4.5, 2.6); at (n1) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c1] {}; at (n2) [circle,draw,fill=blue,minimum size=6pt, scale=0.6, name=c2] {}; at (n3) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c3] {}; at (n4) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c4] {}; at (n5) [circle,draw,fill=blue,minimum size=12pt,scale=0.6, name=c5] {}; at (n6) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c6] {}; at (n7) [circle,draw,fill=red,minimum size=12pt,scale=0.6, name=c7] {}; at (n8) [circle,draw,fill=blue,minimum size=12pt, scale=0.6, name=c8] {}; at (n9) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c9] {}; [<->] ( ) -- ( ) node [pos=0.4, below] { }; ; (l1) -- (c1); (l2) -- (c2); (l3) -- (c3); (l4) -- (c4); (l5) -- (c5); (l6) -- (c6); (l7) -- (c7); (l8) -- (c8); (l9) -- (c9); (6.2, 3.7) circle (0.1cm) node [anchor=west,black,xshift=0.1cm] {original }; (6.2, 3.2) circle (0.1cm) node [anchor=west,black,xshift=0.1cm] {augmented }; {For a , adding the to the in is equivalent to on an augmented } This augmented is obtained by replacing each in the original by the of infinitely many whose is centered around . \\\\ See also: , , , .", "color": "#e87c7c", "value": 29, "inDeg": 3}, {"id": "expectation", "label": "expectation", "title": "Consider a numeric that we interpret as the of an with . The expectation of is defined as the integral . Note that the expectation is only defined if this integral exists, i.e., if the is integrable , , . Fig. illustrates the expectation of a scalar that takes on values from a finite set only. [H] [ ybar, y=5cm, x=2cm, bar width=0.6cm, xlabel={ }, clip=false, ylabel={ }, y label style={rotate=-90, anchor=west, xshift=-1cm}, xtick={1,2,3,4,5}, ymin=0, ymax=0.6, grid=both, major grid style={gray!20}, tick align=outside, axis line style={black!70}, ] +[ybar, fill=blue!50] coordinates { (1,0.1) (2,0.2) (3,0.4) (4,0.2) (5,0.1) }; at (axis cs:1,0.13) { }; at (axis cs:2,0.23) { }; at (axis cs:3,0.43) { }; at (axis cs:4,0.23) { }; at (axis cs:5,0.13) { }; at (axis cs:3.8,0.53) { }; {The expectation of a is obtained by summing its possible values , weighted by the corresponding . } See also: , , , , .", "color": "#e8d87c", "value": 22, "inDeg": 16}, {"id": "logreg", "label": "logistic regression", "title": "Logistic learns a linear (or ) to predict a binary based on the numeric of a , . The quality of a linear is measured by the average on some (i.e., the ). \\\\ See also: , , , , , , , , , .", "color": "#e87c7c", "value": 12, "inDeg": 2}, {"id": "logloss", "label": "logistic loss", "title": "Consider a characterized by and a binary . We use a real-valued to predict the from the . The logistic incurred by this is defined as { } \\, ( 1 + \\,(- ( ))). [H] [ axis lines=middle, xlabel={ }, ylabel={ }, xlabel style={at={(axis description cs:1.,0.3)}, anchor=north}, ylabel style={at={(axis description cs:0.5,1.1)}, anchor=center}, xmin=-3.5, xmax=3.5, ymin=-0.5, ymax=2.5, xtick={-3, -2, -1, 0, 1, 2, 3}, ytick={0, 1, 2}, domain=-3:3, samples=100, width=10cm, height=6cm, grid=both, major grid style={line width=.2pt, draw=gray!50}, minor grid style={line width=.1pt, draw=gray!20}, legend pos=south west ] ; {The logistic incurred by the for a with .} Note that the expression for the logistic applies only for the and when using the thresholding rule . \\\\ See also: , , , .", "color": "#e87c7c", "value": 12, "inDeg": 2}, {"id": "hingeloss", "label": "hinge loss", "title": "Consider a characterized by a and a binary . The hinge incurred by a real-valued is defined as { } \\{ 0 , 1 - ( ) \\}. [H] [ axis lines=middle, xlabel={ }, ylabel={ }, xlabel style={at={(axis description cs:1.,0.3)}, anchor=north}, ylabel style={at={(axis description cs:0.5,1.1)}, anchor=center}, xmin=-3.5, xmax=3.5, ymin=-0.5, ymax=2.5, xtick={-3, -2, -1, 0, 1, 2, 3}, ytick={0, 1, 2}, domain=-3:3, samples=100, width=10cm, height=6cm, grid=both, major grid style={line width=.2pt, draw=gray!50}, minor grid style={line width=.1pt, draw=gray!20}, legend pos=south west ] ; {The hinge incurred by the for a with . A regularized variant of the hinge is used by the .} See also: , , .", "color": "#e87c7c", "value": 11, "inDeg": 1}, {"id": "iidasspt", "label": "independent and identically distributed assumption (i.i.d.\\ assumption)", "title": "The assumption is a widely used for the generation of . In particular, are represented as . \\\\ See also: , , , .", "color": "#e8d87c", "value": 13, "inDeg": 9}, {"id": "hypospace", "label": "hypothesis space", "title": "A space is a mathematical that characterizes the learning capacity of an method. The goal of such a method is to learn a that maps of a to a of its . Given a finite amount of computational resources, a practical method typically explores only a restricted set of all possible from the to the . Such a restricted set is referred to as a space underlying the method (see Fig. ). For the analysis of a given method, the choice of a space is not unique, i.e., any superset containing all the method can learn is also a valid space. [H] [allow upside down, scale=0.4] [below] at (5,-3) { }; [ultra thick] (5,0) circle (5cm); [ultra thick,fill=black!20] (5,0) circle (1cm); [] at (5,0) { }; {The space of an method is a (typically very small) subset of the (typically very large) set of all possible from the into the . } On the other hand, from an engineering perspective, the space is a design choice for -based methods. This design choice can be guided by the available computational resources and . For instance, if efficient operations are feasible and a roughly linear relation exists between and , a can be a useful choice for . \\\\ See also: , , , .", "color": "#e87c7c", "value": 35, "inDeg": 21}, {"id": "model", "label": "model", "title": "The study and design of methods is often based on a mathematical model . Maybe the most widely used example of a mathematical model for is a . A consists of that are used by an method to predict from the of . Another important type of mathematical model is a , which consists of that describe how are generated. Unless stated otherwise, we use the term model to refer specifically to the underlying an method. We illustrate one example of a and a in Fig. . [H] [scale=1] (-1,0) -- (3,0) node[right] { }; (0,-1) -- (0,3) node[above] { }; (-0.5,0) -- (2.5,2) node[right] { }; (-0.5,1) -- (2.5,1) node[right] { }; (-0.5,2) -- (2.5,0.5) node[right] { }; at (1.5,-1.2) {(a)}; [scale=1] (-1,0) -- (3,0) node[right] { }; (0,-1) -- (0,3) node[above] { }; (1,1) ellipse [x radius=1, y radius=0.5]; (2,2) ellipse [x radius=0.7, y radius=0.3]; at (1,0.3) { }; at (2,2.7) { }; at (1.5,-1.2) {(b)}; {Two types of mathematical models used in . (a) A consisting of three . (b) A consisting of over the plane spanned by the and values of a . } See also: , , .", "color": "#e87c7c", "value": 93, "inDeg": 83}, {"id": "modelparam", "label": "model parameter", "title": "The elements of a are specified by quantities that are referred to as . In the context of , a consists of maps that are specified by a list of . It is often convenient to stack these into a . [H] [scale=1] (0,0) ellipse (1.6 and 1.1); at (0,1.5) { }; (-0.6,0.2) circle (1.5pt) node[above left] { }; (0.7,-0.3) circle (1.5pt) node[below right] { }; (6,0) ellipse (1.8 and 1.2); at (6,1.6) { }; (5.4,0.1) circle (1.5pt) node[above left] { }; (6.7,-0.2) circle (1.5pt) node[below right] { }; (-0.6,0.2) .. controls (2,0.9) .. (5.4,0.1); (0.7,-0.3) .. controls (2,-0.9) .. (6.7,-0.2); at (3,1.2) { }; {The select a well-defined out of the .} We can think of as an identifier for a , similar to how a social security number identifies a person.\\\\ See also: , , , .", "color": "#e87c7c", "value": 61, "inDeg": 53}, {"id": "ai", "label": "artificial intelligence (AI)", "title": "AI refers to systems that behave rationally in the sense of maximizing a long-term . The -based approach to AI is to train a to predict optimal actions. These are computed from observations about the state of the environment. The choice of sets AI applications apart from more basic applications. AI systems rarely have access to a labeled that allows the average to be measured for any possible choice of . Instead, AI systems use observed signals to estimate the incurred by the current choice of . \\\\ See also: , .", "color": "#e87c7c", "value": 15, "inDeg": 6}, {"id": "reward", "label": "reward", "title": "A reward refers to some observed (or measured) quantity that allows us to estimate the incurred by the (or decision) of a . For example, in an application to self-driving vehicles, could represent the current steering direction of a vehicle. We could construct a reward from the measurements of a collision sensor that indicate if the vehicle is moving toward an obstacle. We define a low reward for the steering direction if the vehicle moves dangerously toward an obstacle. \\\\ See also: , , .", "color": "#9b7ce8", "value": 12, "inDeg": 6}, {"id": "clusteringerror", "label": "clustering error", "title": "Consider a method that decomposes a given into . The error is a quantitative of the usefulness of the . Different methods use different choices for the error. [scale=1] (c1) at (0.8,0.7); ( ) rectangle ( ); at (c1) { }; (c2) at (6.6,1.6); ( ) rectangle ( ); at (c2) { }; [shift={(c1)}, xscale=1.3, yscale=1.3, rotate=0] / in {-0.6/-0.4, 0.1/0.9, 0.7/-0.6} { ( , ) circle (1.5pt); ( , ) -- (0,0); } [shift={(c2)}, xscale=1.5, yscale=1.5, rotate=0] / in {-1.1/-0.5, -0.2/0.6, 0.6/-0.2} { ( , ) circle (1.5pt); ( , ) -- (0,0); } {For with numeric , we can use the average squared to the nearest as a of the error. } For example, the method measures the error via the average squared between the of a and the nearest (see Figure ). Another construction for the error can be based on a such as the where the are of the underlying .\\\\ See also: , , , .", "color": "#e8d87c", "value": 15, "inDeg": 0}, {"id": "hardclustering", "label": "hard clustering", "title": "Hard refers to the task of partitioning a given set of into (a few) non-overlapping . This requirement allows to represent a by a subset of , i.e., precisely those belonging to the . In contrast to hard , methods allow for overlapping and specify, for each , a numeric to each . Hard is an extreme case of where the take only two values, indicating either no belonging or full belonging. For characterized by numeric , a widely used hard method is . Any method for numeric can be adapted for non-numerical using methods. One important example of this approach is , where have a similarity structure in the form of an undirected . The nodes of this represent while undirected (possibly weighted) edges represent similarities (and their extend) between . We can then use the entries of the of the as numeric for each . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 17, "inDeg": 3}, {"id": "softclustering", "label": "soft clustering", "title": "Soft refers to the task of partitioning a given set of into (a few) overlapping . Each is assigned to several different with varying . Soft methods determine the (or soft assignment) for each and each . A principled approach to soft for characterized by numerical is via a such as the . The conditional of a belonging to a specific mixture component is then a natural choice for the . soft methods can be applied to non-numeric by using methods to provide numerical (such as in ). \\\\ See also: , , , , .", "color": "#7ce8ba", "value": 17, "inDeg": 5}, {"id": "kroneckerproduct", "label": "Kronecker product", "title": "The Kronecker product of two and is a block denoted by and defined as , The Kronecker product is a special case of the tensor product for and is widely used in multivariate statistics, linear algebra, and structured . It satisfies the identity for and of compatible dimensions. \\\\ See also: , , , .", "color": "#7ce8ba", "value": 4, "inDeg": 0}, {"id": "clustering", "label": "clustering", "title": "Clustering methods decompose a given set of into a few subsets, which are referred to as . Each consists of that are more similar to each other than to outside the . Different clustering methods use different for the similarity between and different forms of representations. The clustering method uses the average of a (i.e., the ) as its representative. A popular method based on represents a by a . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 25, "inDeg": 16}, {"id": "cluster", "label": "cluster", "title": "A cluster is a subset of that are more similar to each other than to the outside the cluster. The quantitative of similarity between is a design choice. If are characterized by Euclidean , we can define the similarity between two via the between their . An example of such clusters is shown in Fig. .\\\\ [H] [ width=10cm, height=8cm, xlabel={ }, ylabel={ }, title={Clusters of Data Points}, xmin=0, xmax=10, ymin=0, ymax=10, axis lines=left, legend style={at={(0.5,-0.25)}, anchor=north, legend columns=3} ] coordinates { (1,1) (2,1.2) (1.8,2) (2.2,1.5) (1.5,2.5) }; coordinates { (7,8) (8,7.5) (7.5,8.5) (8.2,7.8) (7.7,7) }; coordinates { (5,3) (5.5,3.2) (5.2,2.8) (4.8,3.5) (5.1,3.1) }; {Illustration of three clusters in a 2-D . Each cluster groups that are more similar to each other than to those in other clusters, based on the .} See also: , , , .", "color": "#7ce8ba", "value": 19, "inDeg": 14}, {"id": "huberloss", "label": "Huber loss", "title": "The Huber unifies the and the . \\\\ See also: , , .", "color": "#7cbae8", "value": 4, "inDeg": 1}, {"id": "svm", "label": "support vector machine (SVM)", "title": "The SVM is a binary meth\\-od that learns a linear . Thus, like and , it is also an instance of for the . However, the SVM uses a different from the one used in those methods. As illustrated in Fig. , it aims to maximally separate from the two different classes in the (i.e., margin principle). Maximizing this separation is equivalent to minimizing a regularized variant of the , , . [H] [auto,scale=0.8] [thick] (1,2) circle (0.1cm)node[anchor=west] { }; [thick] (0,1.6) circle (0.1cm)node[anchor=west] { }; [thick] (0,3) circle (0.1cm)node[anchor=west] { }; [thick] (2,1) circle (0.1cm)node[anchor=east,above] { }; (B) at (-2,0) {support }; (B) to (1.9,1) ; [|<->|,thick] (2.05,0.95) -- (2.75,0.25)node[pos=0.5] { } ; [thick] (1,-1.5) -- (4,1.5) node [right] { } ; [thick] (3,-1.9) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; [thick] (4,.-1) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; {The SVM learns a (or ) with minimal average soft-margin . Minimizing this is equivalent to maximizing the margin between the of and each class of the .} The above basic variant of SVM is only useful if the from different categories can be (approximately) linearly separated. For an application where the categories are not derived from a . \\\\ See also: , , , .", "color": "#e87c7c", "value": 20, "inDeg": 1}, {"id": "eigenvalue", "label": "eigenvalue", "title": "We refer to a number as an eigenvalue of a square if there exists a nonzero such that . [H] [>=stealth, line width=0.8pt] (0,0) -- (2,1) node[midway, above left] { }; (A) at (3.0,0.5) { }; (2,0.5) -- (2.5,0.5); (3.5,0.5) -- (4.0,0.5); (4.6,0) -- (5.6,0.5) node[midway, above] { }; This vector is the corresponding to the eigenvalue . \\\\ See also: , .", "color": "#7ce8ba", "value": 16, "inDeg": 13}, {"id": "eigenvector", "label": "eigenvector", "title": "An eigenvector of a is a nonzero such that with some . \\\\ See also: , , .", "color": "#7ce8ba", "value": 12, "inDeg": 9}, {"id": "evd", "label": "eigenvalue decomposition (EVD)", "title": "The EVD for a square is a factorization of the form The columns of the are the of the . The diagonal contains the corresponding to the . Note that the above decomposition exists only if the is . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 9, "inDeg": 5}, {"id": "svd", "label": "singular value decomposition (SVD)", "title": "The SVD for a is a factorization of the form with orthonormal and . The is only nonzero along the main diagonal, whose entries are nonnegative and referred to as singular values. \\\\ See also: .", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "tv", "label": "total variation", "title": "See .", "color": "#9be87c", "value": 1, "inDeg": 0}, {"id": "cvxclustering", "label": "convex clustering", "title": "Consider a . learns by minimizing Here, denotes the - (for ). It turns out that many of the optimal coincide. A then consists of those with identical , . \\\\ See also: , , , , , , .", "color": "#e8d87c", "value": 7, "inDeg": 0}, {"id": "gdmethod", "label": "gradient-based method", "title": "A -based method is an iterative technique for finding the (or ) of a of the . Such a method constructs a sequence of approximations to an optimal choice for . As the name indicates, a -based method uses the of the evaluated during previous iterations to construct new, (hopefully) improved . One important example of a -based method is . \\\\ See also: , , , , .", "color": "#9be87c", "value": 26, "inDeg": 18}, {"id": "sgd", "label": "subgradient descent", "title": "descent is a of that does not require differentiability of the to be minimized. This generalization is obtained by replacing the concept of a with that of a . Similar to , allow us to construct local approximations of an . The might be the viewed as a of the that select a . \\\\ See also: , , , , , , , , .", "color": "#9be87c", "value": 10, "inDeg": 1}, {"id": "stochGD", "label": "stochastic gradient descent (SGD)", "title": "SGD is obtained from by replacing the of the with a approximation. A main application of SGD is to train a parameterized via on a that is either very large or not readily available (e.g., when are stored in a database distributed globally). To evaluate the of the (as a of the ), we need to compute a sum over all in the . We obtain a approximation to the by replacing the sum with a sum over a randomly chosen subset (see Fig. ). We often refer to these randomly chosen as a . The size is an important of SGD. SGD with is referred to as mini- SGD . [H] [scale=1.5, >=stealth] plot ( , {( -1.5)^2 + 1}); at (0.5, 2) { }; plot ( , {( -2)^2 + 0.5}); at (3.3, 1.5) { }; {SGD for approximates the by replacing the sum over all in the (indexed by ) with a sum over a randomly chosen subset . } See also: , , , , , , , , , , , , .", "color": "#e87c7c", "value": 22, "inDeg": 9}, {"id": "onlineGD", "label": "online gradient descent (online GD)", "title": "Consider an method that learns from some . The learning process uses that arrive at consecutive time instants . Let us interpret the (generation of) as with a common . The of a can then (under mild conditions) be obtained as the limit We might use this limit as the for learning the . Unfortunately, the above limit can only be evaluated if we wait infinitely long in order to collect all . However, many applications require methods that learn online: as soon as a new arrives at time , we update the current . Note that the new contributes the component to the . As its name suggests, online updates via a (projected) such that ^{( +1)} { ^{( )} - _{ } _{ } { ^{( )}}{ }}. Note that is a for the current component of the . The update ignores all previous components , for . It might therefore happen that, compared with , the updated increase the retrospective average . However, for a suitably chosen , online can be shown to be optimal in practically relevant settings. By optimal, we mean that the delivered by online after observing are at least as good as those delivered by any other learning method , . [H] [x=1.5cm,scale=1.5, every node/.style={font= }] (0.5, 0) -- (5.5, 0) node[below] {}; in {1, 2, 3, 4, 5} { ( , 0.1) -- ( , -0.1) node[below] { }; } / in {1/2.5, 2/1.8, 3/2.3, 4/1.5, 5/2.0} { ( , ) circle (2pt) node[above right] { }; } / in {1/1.0, 2/1.6, 3/1.8, 4/2.2, 5/1.9} { ( , ) circle (2pt) node[below left] { }; } / / in {1/2.5/1.0, 2/1.8/1.6, 3/2.3/2.0, 4/1.5/1.8, 5/2.0/1.9} { ( , ) -- ( , ); } {An instance of online that updates the using the arriving at time . This instance uses the .} See also: , , , .", "color": "#e87c7c", "value": 18, "inDeg": 2}, {"id": "pca", "label": "principal component analysis (PCA)", "title": "Consider a constituted by characterized by , for . PCA determines, for a given number a linear such that the new allow us to reconstruct the original with linear reconstruction error We can view PCA as a form of using the with a reconstruction that achieves the above minimum reconstruction error. It turns out that this problem can be solved by a whose rows are given by corresponding to the largest of the Note that coincides with the of if its vanishes. The allows for an of the form This decomposition consists of decreasing nonnegative and corresponding that form an orthonormal basis of . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 23, "inDeg": 6}, {"id": "loss", "label": "loss", "title": "methods use a to measure the error incurred by applying a specific to a specific . With a slight abuse of notation, we use the term loss for both the itself and the specific value , for a and . \\\\ See also: , .", "color": "#e87c7c", "value": 52, "inDeg": 47}, {"id": "lossfunc", "label": "loss function", "title": "A is a It assigns a nonnegative real number (i.e., the ) to a pair that consists of a , with and , and a . The value quantifies the discrepancy between the true and the . Lower (closer to zero) values indicate a smaller discrepancy between and . Fig. depicts a for a given , with and , as a of the . [H] [scale = 0.7, every axis/.append style={ axis line style={-Latex, thick}, tick style={thick} }] [axis x line=center, axis y line=center, xlabel={}, xlabel style={below right}, ylabel style={above right}, xtick= , ytick= , xmin=-5, xscale = 1.4, xmax=5, ymin=-0.5, ymax=2.5 ] ; ; ; [below] at (10,1) { }; [right] at (4,6) { }; {Some for a fixed , with and , and a varying . methods try to find (or learn) a that incurs minimal .} See also: , , , .", "color": "#e87c7c", "value": 33, "inDeg": 22}, {"id": "decisiontree", "label": "decision tree", "title": "A decision tree is a flowchart-like representation of a . More formally, a decision tree is a directed containing a root node that reads in the of a . The root node then forwards the to one of its child nodes based on some elementary test on the . If the receiving child node is not a leaf node, i.e., it has child nodes itself, it represents another test. Based on the test result, the is forwarded to one of its descendants. This testing and forwarding of the is continued until the ends up in a leaf node without any children. See Fig.\\ for visual illustrations. [H] {.45 } { (A) {}; (B) {}; (C) {}; (D) {}; (E) {}; (A) -- (B) node[midway, left] {no}; (A) -- (C) node[midway, right] {yes}; (C) -- (D) node[midway, left] {no}; (C) -- (E) node[midway, right] {yes}; at (0.7,-4.5) { (a)}; } {.45 } (-2,2) rectangle (2,-2); (-0.5,0) circle (1cm); (0.5,0) circle (1cm); (-2,1.5) rectangle (2,-1.5); (-0.5,0) circle (1cm); (0.5,0) circle (1cm); (-0.5,0) circle [radius=0.025]; [below right, red] at (-0.5,0) { }; [below left, blue] at (-0.7,0) { }; [above left] at (-0.7,1) { }; [left] at (-0.4,0) { }; (0.5,0) circle [radius=0.025]; [right] at (0.6,0) { }; at (0,-3.5) { (b)}; {(a) A decision tree is a flowchart-like representation of a piecewise constant . Each piece is a . The depicted decision tree can be applied to numeric , i.e., . It is parameterized by the threshold and the . (b) A decision tree partitions the into . Each corresponds to a specific leaf node in the decision tree.} See also: .", "color": "#e87c7c", "value": 15, "inDeg": 6}, {"id": "API", "label": "application programming interface (API)", "title": "An API is a formal mechanism that allows software components to interact in a structured and modular way . In the context of , APIs are commonly used to provide access to a trained . Users—whether humans or machines—can submit the of a and receive a corresponding . Suppose a trained is defined as . Through an API, a user can input and receive the output without knowledge of the detailed structure of the or its training. In practice, the is typically deployed on a server connected to the Internet. Clients send requests containing values to the server, which responds with the computed . APIs promote modularity in system design, i.e., one team can develop and train the , while another team handles integration and user interaction. Publishing a trained via an API also offers practical advantages. For instance, the server can centralize computational resources that are required to compute . Furthermore, the internal structure of the remains hidden—which is useful for protecting intellectual property or trade secrets. However, APIs are not without . Techniques such as can potentially reconstruct a from its using carefully selected . \\\\ See also: , , , , , , .", "color": "#e87c7c", "value": 8, "inDeg": 0}, {"id": "modelinversion", "label": "model inversion", "title": "A inversion is a form of on an system. An adversary seeks to infer of individual by exploiting partial access to a trained . This access typically consists of querying the for using carefully chosen inputs. Basic inversion techniques have been demonstrated in the context of facial image , where images are reconstructed using the ( of) outputs combined with auxiliary information such as a person’s name (see Fig. ). [H] [scale=1.5] (-0.5,0) -- (5.5,0) node[right] {face image }; (0,-0.2) -- (0,2.5) node[above] {name}; plot ({ }, {2/(1 + exp(-3*( - 3)))}); {2/(1 + exp(-3*( - 3)))} ( ,0) -- ( , ); (0, ) -- ( , ); ( , ) circle (0.1); at (-0.1, ) { ``Alexander Jung''}; at ( ,-0.25) { }; at (4,2.2) {trained }; {Model inversion techniques implemented in the context of facial image classification. } See also: , , , , , , , , , .", "color": "#e87c7c", "value": 13, "inDeg": 3}, {"id": "samplesize", "label": "sample size", "title": "The number of individual contained in a or . Consider a -based method that uses a with sample size and a with . If the can be well-approximated by the , then the ratio between and can be a useful indicator for the occurence of . \\\\ See also: , .", "color": "#e87c7c", "value": 11, "inDeg": 2}, {"id": "skipconnection", "label": "skip connection", "title": "Consider a with neurons that are organized in consecutive . A skip connection links the output of a neuron in some to the input of a neuron in a non-consecutive .\\\\ See also: , .", "color": "#e87cd8", "value": 3, "inDeg": 0}, {"id": "ann", "label": "artificial neural network (ANN)", "title": "An artificial neural network (ANN) is a graphical (signal-flow) representation of a that maps of a at its input to a for the corresponding at its output. The fundamental computational unit of an ANN is the artificial neuron, which applies an to the sum of its inputs. The output of a neuron can be used either as the final output of the ANN or as an input to other neurons. A key design parameter of an ANN is its connectivity structure (or architecture), i.e., which neuron outputs are connected to which neuron inputs. As illustrated in Fig.\\ , we can represent an ANN as an . One widely used type of are where neurons form consecutive . In a , the outputs of neurons in a given are typically only connnected to the inputs of the neurons in a consecutive . Sometimes it is useful to add shortcut or skip connections that directly connect the outputs of neurons in one to the inputs of neurons in a non-consecutive . [H] [>=stealth, node distance=2.3cm and 2.4cm] (x1) {}; (x2) [below=of x1] {}; (h1) [right=of x1, yshift=5mm] {}; (h2) [right=of x2, yshift=-5mm] {}; (y) [right=of h1, yshift=-2cm] {}; (x1) -- (h1) node [midway, above] { }; (x2) -- (h1)node [pos=0.1, above] { }; (x1) -- (h2) node [pos=0.8, above] { }; (x2) -- (h2) node [midway, above] { }; (h1) -- (y) node [midway, above] { }; (h2) -- (y) node [midway, above] { }; (x1) -- (y) node [midway, above] { }; {An ANN can be represented as a weighted with nodes representing neurons or of a . can be viewed as trivial neurons without input and fixed ouput given by the value. The weighted directed edges indicate how neuron outputs are used as inputs to other neurons. The edge weights are tunable and are used to scale the inputs to the neurons. The output of some neurons are used as the . } See also: , , , .", "color": "#e87c7c", "value": 28, "inDeg": 18}, {"id": "randomforest", "label": "random forest", "title": "A random forest is a set of different . Each of these is obtained by fitting a perturbed copy of the original . \\\\ See also: , .", "color": "#7ce8ba", "value": 3, "inDeg": 1}, {"id": "gd", "label": "gradient descent (GD)", "title": "GD is an iterative method for finding the of a . GD generates a sequence of estimates that (ideally) converge to a of . At each iteration , GD refines the current estimate by taking a step in the direction of the steepest descent of a local linear approximation. This direction is given by the negative of the at the current estimate . The resulting update rule is given by ^{( \\!+\\!1)} = ^{( )} - f( ^{( )}) where is a suitably small . For a suitably choosen , the update typically reduces the value, i.e., . Fig.\\ illustrates a single GD step. [H] [scale=0.9] (-4,0) grid (4,4); plot ( , {(1/4)* }); plot ( , {2* - 4}); (4,4) -- node[right] { } (4,2); (4,4) -- node[above] { } (1,4); (4,2) -- node[below] { } (3,2) ; (-4.25,0) -- (4.25,0) node[right] { }; (0,-2pt) -- (0,4.25) node[above] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; / in {1/1, 2/2, 3/3, 4/4} (2pt,0pt) -- (-2pt,0pt) node[left] { }; {A single toward the minimizer of .} See also: , , , , .", "color": "#9be87c", "value": 19, "inDeg": 13}, {"id": "abserr", "label": "absolute error loss", "title": "Consider a with and numeric . As its name suggests, the absolute error incurred by a is defined as Fig. depicts the absolute error for a fixed with and . It also indicates the values incurred by two different and . Similar to the , the absolute error is also a of the . However, in contrast to the , the absolute error is , as it is not at the optimal . This property makes -based methods using the absolute error computationally more demanding , . To build intuition, it is useful to consider the two depicted in Fig. . Just by inspecting the slope of around and , it is impossible to determine whether we are very close to the optimum (at ) or still far away (at ). As a result, any that is based on local approximations of the (such as ) must use a decreasing to avoid overshooting when approaching the optimum. This required decrease in tends to slow down the of the . Besides the increased computational complexity, using absolute error in can be beneficial in the presence of in the . In contrast to the , the slope of the absolute error does not increase with increasing error . As a result, the effect of introducing an with large error on the solution of with absolute error is much smaller compared with the effect on the solution of with . [H] [x=3cm,y=1.6cm] {0.0} {0.6} {3.7} [axis lines=middle,xtick= ,ytick= ,width=15cm,height=5cm,xmin=-4,xmax=4,ymin=-0.2,ymax=3,domain=-4:4,samples=100,clip=false,enlarge x limits=0.15,enlarge y limits=0.15] ; coordinates {( , 0)}; at (axis cs: , 0) { }; {abs( - )} coordinates {( , )}; at (axis cs: , ) { }; at (axis cs: , 0) { }; coordinates {( , 0) ( , )}; {abs( - )} coordinates {( , )}; at (axis cs: , 0) { }; coordinates {( , 0) ( , )}; at (axis cs: , ) { }; at (axis cs:4,0) { }; {For a with numeric , the absolute error can be used as a to guide the learning of a . } See also: , , , , , , .", "color": "#7cbae8", "value": 26, "inDeg": 5}, {"id": "device", "label": "device", "title": "A physical system that can store and process . In the context of , the term typically refers to a computer capable of reading from different sources and using them to train an . \\\\ See also: , , , .", "color": "#9be87c", "value": 14, "inDeg": 10}, {"id": "huberreg", "label": "Huber regression", "title": "Huber refers to -based methods that use the as a of the error. Two important special cases of Huber are and . Tuning the threshold of the allows the user to trade the of the against the computational benefits of the . \\\\ See also: , , , .", "color": "#7cbae8", "value": 14, "inDeg": 2}, {"id": "ladregression", "label": "least absolute deviation regression", "title": "Least absolute deviation regression is an instance of using the . It is a special case of . [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/4 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptA ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (7.5, -4) {(a)}; [xshift=10cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (ptB7) {outlier}; at (7.5, -4) {(b)}; {For the simple , with amounts to computing the . (a) Original . (b) Noisy including an . } For the , with is solved by the . Using instead for the same , makes computing the . \\\\ See also: , , .", "color": "#7cbae8", "value": 12, "inDeg": 3}, {"id": "metric", "label": "metric", "title": "A metric is a quantitative used to compare objects. In mathematics, a metric measures the distance between two points in a space and must follow specific rules, i.e., the distance is always nonnegative, zero only if the points are the same, symmetric, and it satisfies the triangle inequality . In the context of , the term metric refers to a quantitative of how well a performs (somewhat similar to a ). Examples include , precision, and the average on a , . The term is typically used in the context of , while the term metric is used in the context of . \\\\ See also: , , .", "color": "#e8d87c", "value": 19, "inDeg": 9}, {"id": "bayesrisk", "label": "Bayes risk", "title": "Consider a for a application where each is interpreted as a . The includes a for the and of a . The Bayes is the possible that can be achieved by any . Any that achieves the Bayes is referred to as a . \\\\ See also: , , .", "color": "#e87c7c", "value": 14, "inDeg": 3}, {"id": "bayesestimator", "label": "Bayes estimator", "title": "Consider a with a joint over the and the of a . For a given , we refer to a as a Bayes estimator if its is the achievable . Note that whether a qualifies as a Bayes estimator depends on the underlying and the choice for the . \\\\ See also: , , .", "color": "#e87c7c", "value": 11, "inDeg": 2}, {"id": "weights", "label": "weights", "title": "Consider a parameterized . We use the term weights for numeric that are used to scale or their transformations in order to compute . A uses weights to compute the linear combination . Weights are also used in to form linear combinations of or the outputs of neurons in hidden (see Fig. ). [H] [neuron/.style={circle, draw, minimum size=1cm}, thick, >=stealth] (h1) at (0, 2) { }; (h2) at (0, 0) { }; (h3) at (0, -2) { }; (outpoint); at ([xshift=0.2cm]outpoint) { }; (h1) -- node[above] { } (outpoint); (h2) -- node[above] { } (outpoint); (h3) -- node[below] { } (outpoint); {A section of an that contains a hidden with outputs (or ) , , and . These outputs are combined linearly to compute , which can be used either as output of the or as input to another . } See also: , , , , , , .", "color": "#e87c7c", "value": 18, "inDeg": 11}, {"id": "probdist", "label": "probability distribution", "title": "To analyze methods, it can be useful to interpret as of a . The typical properties of such are then governed by the distribution of this . The distribution of a binary is fully specified by the and . The distribution of a real-valued might be specified by a such that . In the most general case, a distribution is defined by a , . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 50, "inDeg": 42}, {"id": "pdf", "label": "probability density function (pdf)", "title": "The pdf of a continuous real-valued allows to compute the (of the ) via a This definition extends naturally to a (continuous) vector-valued as the is defined for with any . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 14, "inDeg": 6}, {"id": "parameter", "label": "parameter", "title": "The parameter of an is a tunable (i.e., learnable or adjustable) quantity that allows us to choose between different . For example, the consists of all with a particular choice for the parameters . Another example of a parameter is the assigned to a connection between two neurons of an . \\\\ See also: , , , , , , .", "color": "#e87c7c", "value": 29, "inDeg": 22}, {"id": "lln", "label": "law of large numbers", "title": "The law of large numbers refers to the of the average of an increasing (large) number of to the of their common . Different instances of the law of large numbers are obtained by using different notions of . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 6, "inDeg": 1}, {"id": "stopcrit", "label": "stopping criterion", "title": "Many methods use iterative that construct a sequence of in order to minimize the . For example, iteratively update the of a , such as a or a . Given a finite amount of computational resources, we need to stop updating the after a finite number of iterations. A stopping criterion is any well-defined condition for deciding when to stop updating. \\\\ See also: , .", "color": "#e87c7c", "value": 9, "inDeg": 0}, {"id": "jacobimethod", "label": "Jacobi method", "title": "The Jacobi method is an for solving systems of linear equations (i.e., a linear system) of the form . Here, is a square with nonzero main diagonal entries. The method constructs a sequence by updating each entry of according to Note that all entries are updated simultaneously. The above iteration converges to a solution, i.e., , under certain conditions on the , e.g., being strictly diagonally dominant or symmetric positive definite , , . Jacobi-type methods are appealing for large linear systems due to their parallelizable structure . We can interpret the Jacobi method as a . Indeed, using the decomposition , with being the diagonal of , allows us to rewrite the linear equation as a fixed-point equation which leads to the iteration . \\\\ As an example, for the linear equation the Jacobi method updates each component of as follows: See also: , , , .", "color": "#9be87c", "value": 4, "inDeg": 0}, {"id": "renyidiv", "label": "R\\'enyi divergence", "title": "The R\\'enyi divergence measures the (dis)similarity between two . \\\\ See also: .", "color": "#e8d87c", "value": 1, "inDeg": 0}, {"id": "nonsmooth", "label": "non-smooth", "title": "We refer to a as non-smooth if it is not . \\\\ See also: , .", "color": "#7cbae8", "value": 4, "inDeg": 2}, {"id": "convex", "label": "convex", "title": "A subset of the is referred to as convex if it contains the line segment between any two points in that set, i.e., Similarly, a is convex if its is a convex set . We illustrate one example of a convex set and a convex in Fig. . [H] (-3,0) ellipse (2 and 1.2); (-3,0) ellipse (2 and 1.2); (-3.7,0.2) circle (2pt) node[left] { }; (-2.3,-0.5) circle (2pt) node[right] { }; (-3.7,0.2) -- (-2.3,-0.5); at (-1.2,-1.0) { }; at (-3,-2.4) {(a)}; [shift={(5,-1)}] plot ({ }, {0.5* }); plot[domain=-1.5:1.5, smooth] ({ }, {0.5* }) -- (2, {0.5*2*2}) -- (-2, {0.5*2*2}) -- cycle; at (0,-0.4) { }; at (0,-1.4) {(b)}; {(a) A convex set . (b) A convex . } See also: , , .", "color": "#e8d87c", "value": 20, "inDeg": 17}, {"id": "smooth", "label": "smooth", "title": "A real-valued is smooth if it is and its is continuous at all , . A smooth is referred to as -smooth if the is Lipschitz continuous with Lipschitz constant , i.e., The constant quantifies the smoothness of the : the smaller the , the smoother is. with a smooth can be solved effectively by . Indeed, approximate the locally around a current choice using its . This approximation works well if the does not change too rapidly. We can make this informal claim precise by studying the effect of a single with (see Fig. ). [H] [scale=0.8, x=0.6cm,y=0.05cm] plot ({ }, { ^2}); (w) at ( ,{ }); (wkplus1) at (4+ ,{(4+ )^2}); (wk) at (8+ ,{(8+ )^2}); (wk) -- +(-2, -{4*(8 + )} ) -- +(1, {2*(8 + )}); (w) -- +(-1, {-{2* }} ) -- +(1, {+{2* }}) node[below] { }; (wk) circle (2pt) node[above left] { } node[below right, xshift=-15pt,yshift=-15pt] { } ; (w) circle (2pt) node[above right] { } ; (wkplus1) circle (2pt) node[below right] { }; (wk) -- ( ) ; (wkplus1) -- ( ) ; ( ) -- ( ) node[midway, right] { }; {Consider an that is -smooth. Taking a , with , decreases the objective by at least , , . Note that the becomes larger for smaller . Thus, for smoother (i.e., those with smaller ), we can take larger steps. } See also: , , , .", "color": "#9be87c", "value": 15, "inDeg": 7}, {"id": "parammodel", "label": "parametric model", "title": "A parametric is a mathematical characterized by a finite set of variable quantities called . An important example is the consisting, for a given , of all (on ) with some and . In the context of , a parametric defines a parameterized by a finite number of . Each is uniquely identified by a list of (see Fig.~ ). We can stack these into a . Two widely used examples of parametric are the and the . The corresponding is typically a subset of . [H] (paramspace) {}; { space }; (theta1) at ( ) {}; ; (theta2) at ( ) {}; ; (plotcloud) {}; { }; (plot1start) at ( ) {}; (plot1start) .. controls ++(0.8, 1) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (plot2start) at ( ) {}; (plot2start) .. controls ++(0.8, 0.5) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (theta1) to ( ); (theta2) to (plot2start); {The space of an consists of all feasible choices for the . Each choice for the selects a . } See also: , , .", "color": "#e87c7c", "value": 25, "inDeg": 8}, {"id": "paramspace", "label": "parameter space", "title": "The space of an is the set of all feasible choices for the (see Fig. ). Many important methods use a that is parameterized by of the . Two widely used examples of parameterized are and . The space is then often a subset , e.g., all with a smaller than one. [H] (paramspace) {}; { space }; (theta1) at ( ) {}; ; (theta2) at ( ) {}; ; (plotcloud) {}; { }; (plot1start) at ( ) {}; (plot1start) .. controls ++(0.8, 1) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (plot2start) at ( ) {}; (plot2start) .. controls ++(0.8, 0.5) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (theta1) to ( ); (theta2) to (plot2start); {The space of an consists of all feasible choices for the . Each choice for the selects a . } See also: , , .", "color": "#e87c7c", "value": 16, "inDeg": 5}, {"id": "datanorm", "label": "data normalization", "title": "normalization refers to transformations applied to the of to improve the method's or . For example, in with using a fixed , depends on controlling the of in the . A common approach is to normalize such that their does not exceed one . \\\\ See also: , , .", "color": "#9be87c", "value": 13, "inDeg": 0}, {"id": "dataaug", "label": "data augmentation", "title": "augmentation methods add synthetic to an existing set of . These synthetic are obtained by perturbations (e.g., adding noise to physical measurements) or transformations (e.g., rotations of images) of the original . These perturbations and transformations are such that the resulting synthetic should still have the same . As a case in point, a rotated cat image is still a cat image even if their (obtained by pixel color intensities) are very different (see Fig. ). augmentation can be an efficient form of . [H] {0.5} {2} plot[smooth, tension=1] coordinates {(0,0) (2,1) (4,0) (6,-1) (8,0)}; at (0,0) { }; plot[smooth, tension=1] coordinates {(0 + ,0 + ) (2 + ,1 + ) (4 + ,0 + ) (6 + ,-1 + ) (8 + ,0 + )}; at (8 + ,0 + ) { }; (2,1) circle (2pt) node[above] { }; (6,-1) circle (2pt) node[above] { }; (2,1) to[out=240, in=240] node[midway, below] { } (6,-1); { augmentation exploits intrinsic symmetries of in some . We can represent a symmetry by an , parameterized by some number . For example, might represent the effect of rotating a cat image by degrees. A with must have the same as a with . } See also: , , , , , , .", "color": "#e87c7c", "value": 11, "inDeg": 3}, {"id": "localdataset", "label": "local dataset", "title": "The concept of a local is in between the concept of a and a . A local consists of several individual characterized by and . In contrast to a single used in basic methods, a local is also related to other local via different notions of similarity. These similarities might arise from or communication infrastructure and are encoded in the edges of an . \\\\ See also: , , , , , , .", "color": "#9be87c", "value": 13, "inDeg": 6}, {"id": "localmodel", "label": "local model", "title": "Consider a collection of that are represented as nodes of an . A local is a assigned to a node . Different nodes can have different , i.e., in general, for different nodes . \\\\ See also: , , , .", "color": "#9be87c", "value": 11, "inDeg": 7}, {"id": "mutualinformation", "label": "mutual information (MI)", "title": "The MI between two , defined on the same is given by It is a of how well we can estimate based solely on . A large value of indicates that can be well predicted solely from . This could be obtained by a learned by an -based method. \\\\ See also: , , , , , .", "color": "#e8d87c", "value": 8, "inDeg": 1}, {"id": "zerogradientcondition", "label": "zero-gradient condition", "title": "Consider the unconstrained with a and . [htbp] [scale=1.1,x=2cm] {1} {0.5} {-0.2} {2.4} {( - )^2 + } plot ( ,{( - )^2 + }); at ( , ) { }; (xstar) at ( , ); (xstar) circle (1.6pt); ( ,0) -- (xstar) node[below,yshift=-18pt] { }; (0, ) -- (xstar); (xstar) ++(-0.7,0) -- ++(1.4,0); [xshift=20pt,yshift=-5pt] at ( ) { }; A necessary and sufficient condition for a to solve this problem is that the is the zero . In other words , By defining the , we can rewrite the zero-gradient condition as a fixed-point equation Here, denotes the identity (i.e., ) and is an arbitrary positive number. \\\\ See also: , , , , , .", "color": "#e8d87c", "value": 8, "inDeg": 1}, {"id": "edgeweight", "label": "edge weight", "title": "Each edge of an is assigned a nonnegative edge weight . A zero edge weight indicates the absence of an edge between nodes . \\\\ See also: .", "color": "#9be87c", "value": 3, "inDeg": 2}, {"id": "dataminprinc", "label": "data minimization principle", "title": "European protection regulation includes a minimization principle. This principle requires a controller to limit the collection of personal information to what is directly relevant and necessary to accomplish a specified purpose. The should be retained only for as long as necessary to fulfill that purpose , . \\\\ See also: .", "color": "#9be87c", "value": 2, "inDeg": 1}, {"id": "layer", "label": "layer", "title": "A is an that consists of consecutive layers, indexed by . The -th layer consists of artificial neurons with the layer width . Each of these artificial neurons evaluates an for a weighted sum of the outputs (or ) of the previous layer . The input to layer is formed from weighted sums of the of the for which the computes a . The outputs of the neurons in layer are then, in turn, used to form the inputs for the neurons in the next layer. The final (output) layer consists of a single neuron whose output is used as the delivered by the . \\\\ See also: , .", "color": "#e87c7c", "value": 17, "inDeg": 10}, {"id": "activation", "label": "activation", "title": "The output of an artificial neuron within an is referred to as its activation. In particular, the activation is obtained by applying a (typically nonlinear) to a weighted sum of its inputs. \\\\ See also: , .", "color": "#e87c7c", "value": 7, "inDeg": 4}, {"id": "cav", "label": "concept activation vector (CAV)", "title": "Consider a , consisting of several hidden , trained to predict the of a from its . One way to explain the behavior of the trained is by using the of a hidden as a new . We then probe the geometry of the resulting new by applying the to that represent a specific concept . By applying the also to that do not belong to this concept, we can train a binary that distinguishes between concept and non-concept based on the of the hidden . The resulting is a whose normal is the CAV for the concept . \\\\ See also: , , , , .", "color": "#e87c7c", "value": 15, "inDeg": 0}, {"id": "backpropagation", "label": "backpropagation", "title": "Backpropagation is an for computing the of an that depends on the of an . One example of such an is the average incurred by the on a of . This is a direct application of the chain rule from calculus to efficiently compute of the with respect to the . Backpropagation consists of two consecutive phases, also illustrated in Fig. . The first phase includes the forward pass, where a of is fed into the . The processes the input through its using its current , ultimately producing a at its output. The of the is compared to the true using a , which quantifies the error. The second phase includes the backward pass (i.e., backpropagation), where the error is backpropagated through the . The obtained with respect to the constitute the , which can be used, in turn, to implement a . [H] [ >=Stealth, neuron/.style={circle,draw,minimum size=9mm,inner sep=0pt}, conn/.style={-Stealth, line width=0.7pt}, grad/.style={Stealth-, dashed, line width=0.7pt}, lbl/.style={font= }, box/.style={draw, rounded corners, inner sep=4pt} ] (x1) at (0,1.8) { }; (x2) at (0,0) { }; (x3) at (0,-1.8){ }; (h1) { }; (h2) { }; (h3) { }; (yhat) { }; (loss) { }; in {1,2,3}{ in {1,2,3}{ (x ) -- (h ); } } in {1,2,3}{ (h ) -- (yhat); } (yhat) -- (loss); (yhat) to[bend left=10] node[above, lbl] { } (loss); in {1,2,3}{ (h ) to[bend left=10] (yhat); } in {1,2,3}{ in {1,2,3}{ (x ) to[bend left=10] (h ); } } at ( ) { }; at ( ) { }; (legend) { [baseline={(0,0)}] (0,0) -- (1.0,0); at (1.5,0) { forward pass (compute )}; (0,-0.5) -- (1.0,-0.5); at (1.5,-0.5) { backward pass (compute )}; }; at ( ) { ,\\; ,\\; }; {Solid arrows show the forward pass (i.e., flow and calculation), while dashed arrows show the correction flow during the backward pass for updating the { }.} See also: , , , .", "color": "#e87c7c", "value": 19, "inDeg": 0}, {"id": "vcdim", "label": "Vapnik–Chervonenkis dimension (VC dimension)", "title": "The statistical properties of an -based method depend critically on the expressive capacity of its (or ) . A standard of this capacity is the VC . Formally, it is the largest integer such that there exists a that can be perfectly classified (or shattered) by some . Formally, this means that for every one of the possible assignments of binary to each in , there exists some that realizes this labeling. Intuitively, the VC quantifies how well can fit arbitrary assignments, and thus captures its approximate power. It plays a central role in deriving bounds on the . Fig. illustrates the definition of the VC for a with . Fig.~ (a) and ~ (b) show the same set of three noncollinear under two different binary labelings. In both cases, a separating hyperplane exists that realizes the labeling. Since this holds for all possible binary labelings of the three , the set is shattered. Fig.~ (c) depicts four with a specific labeling. No linear separator can correctly classify all in this case. Thus, . \\\\ [H] {.3 } [scale =.4] [red] (-1,1) circle (3pt); [blue] (1,-1) circle (3pt); [blue] (-1,-1) circle (3pt); [black] (-1.5,0) -- (1.5,0); at (0,-3.4) {(a)}; {.3 } [scale =.4] [red] (-1,1) circle (3pt); [red] (1,-1) circle (3pt); [blue] (-1,-1) circle (3pt); [black] (-1.2,0.3) -- (0.3,-1.2); at (0,-3.4) {(b)}; {.3 } [ scale =.4] [red] (-1,1) circle (3pt); [blue] (1,1) circle (3pt); [red] (1,-1) circle (3pt); [blue] (-1,-1) circle (3pt); at (0,-3.4) {(c)}; {Illustration of the VC for a that is used to learn a in the . } More generally, for a , the VC equals . In other words, for , the VC essentially matches the of the underlying . For more complex , such as or , the relation between VC and the of the is far less direct. In these cases, alternative complexity , such as the , can be more useful for analyzing -based methods. \\\\ See also: , , , , .", "color": "#e87c7c", "value": 23, "inDeg": 1}, {"id": "metricspace", "label": "metric space", "title": "A space is a set equipped with a (referred to as a ) that satisfies the following requirements for all : Nonnegativity: ; Identity: if and only if ; Symmetry: ; Triangle inequality: . Formally, a space is a pair that satisfies the above requirements. [H] [>=stealth, x=0.5cm, y=1cm] at (2.5,3.6) { }; at (12.5,3.6) { }; [shift={(0,0)}] (0,0) -- (5.2,0) node[below right] { }; (0,0) -- (0,3.2) node[left] { }; (X) at (1.1,0.9); (Y) at (3.8,2.1); (X) circle (1.2pt) node[below left] { }; (Y) circle (1.2pt) node[above right] { }; (X) -- (Y) node[midway, below right, xshift=1pt] { }; at (3, -1) {(a)}; [shift={(9.0,0)}] (A) at (1.0,0.6); (B) at (3.1,0.9); (C) at (2.2,2.6); (D) at (4.8,2.2); (E) at (0.4,2.1); (A)--(B)--(C)--(E)--(A); (C)--(D)--(B); (A) circle (1.2pt) node[below left] { }; (D) circle (1.2pt) node[above right] { }; (A)--(B)--(D); at (5.0,0.7) { }; (B) circle (1.2pt); (C) circle (1.2pt); (E) circle (1.2pt); at (3, -1) {(b)}; {Examples of spaces. (a) with the as a . (b) with the shortest-path distance as a . } A prominent example of a space is the equipped with a given by the . Another well-known example of a space is an , with the defined by the length of the shortest path connecting nodes and . \\\\ See also: , , .", "color": "#e8d87c", "value": 15, "inDeg": 9}, {"id": "rademachercomplexity", "label": "Rademacher complexity", "title": "Similar to the , the Rademacher complexity is a quantitative of the size of a . It is based on the empirical Rademacher complexity, which is defined for a given as _ ( ) = _{ _{1},\\, ,\\, _{ } } _{ } { } _{ =1}^ _ ( ^{( )} ). Here, the is taken with respect to the , which are and take values in with equal . The Rademacher complexity of is then defined as the of the empirical Rademacher complexity of a random that consists of , for . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 12, "inDeg": 1}, {"id": "penaltyterm", "label": "penalty term", "title": "Consider an -based method that learns by minimizing the average (or ) on a . To avoid , and control the , it is common to augment the with a penalty term . We refer to the resulting modified as . [H] [scale = 1] (0,0.5) -- (7.7,0.5) node[right] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ 0.4 + 2.0}) ; at (6.7,4.5) { }; (l1) at (1.2, 2.48); (l2) at (1.4, 2.56); (l3) at (1.7, 2.68); (l4) at (2.2, 2.2*0.4+2.0); (l5) at (2.4, 2.4*0.4+2.0); (l6) at (2.7, 2.7*0.4+2.0); (l7) at (3.9, 3.9*0.4+2.0); (l8) at (4.2, 4.2*0.4+2.0); (l9) at (4.5, 4.5*0.4+2.0); (n1) at (1.2, 1.8); (n2) at (1.4, 1.8); (n3) at (1.7, 1.8); (n4) at (2.2, 3.8); (n5) at (2.4, 3.8); (n6) at (2.7, 3.8); (n7) at (3.9, 2.6); (n8) at (4.2, 2.6); (n9) at (4.5, 2.6); at (n1) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c1] {}; at (n2) [circle,draw,fill=blue,minimum size=6pt, scale=0.6, name=c2] {}; at (n3) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c3] {}; at (n4) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c4] {}; at (n5) [circle,draw,fill=blue,minimum size=12pt,scale=0.6, name=c5] {}; at (n6) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c6] {}; at (n7) [circle,draw,fill=red,minimum size=12pt,scale=0.6, name=c7] {}; at (n8) [circle,draw,fill=blue,minimum size=12pt, scale=0.6, name=c8] {}; at (n9) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c9] {}; [<->] ( ) -- ( ) node [pos=0.4, below] { }; ; (l1) -- (c1); (l2) -- (c2); (l3) -- (c3); (l4) -- (c4); (l5) -- (c5); (l6) -- (c6); (l7) -- (c7); (l8) -- (c8); (l9) -- (c9); (6.2, 3.7) circle (0.1cm) node [black,xshift=2.3cm] {original }; (6.2, 3.2) circle (0.1cm) node [black,xshift=1.3cm] {augmented}; at (4.6,1.2) [minimum size=12pt, font= {0} , text=blue] { }; at (7.8,1.2) [minimum size=12pt, font= {0} , text=red] { }; {Adding a penalty term to the in is equivalent to including perturbations of the during . The controls the extend of the perturbations. } The penalty term depends only on the but not on the in the . For some combinations of and , the penalty term can be obtained as the average incurred on (an infinite number of) perturbed copies of the . In other words, adding a penalty term in can be viewed as a form of . \\\\ See also: , , , .", "color": "#e87c7c", "value": 22, "inDeg": 3}, {"id": "psd", "label": "positive semi-definite (psd)", "title": "A (real-valued) is referred to as psd if for every . A psd matrix admits a with nonnegative . The notion of being psd can be extended from to (real-valued) symmetric (with ) as follows: For any finite set of , the resulting with entries is psd . \\\\ See also: , .", "color": "#7ce8ba", "value": 12, "inDeg": 4}, {"id": "normalmatrix", "label": "normal matrix", "title": "A square matrix that commutes with its conjugate transpose, i.e., . Normal matrices admit an orthonormal basis of and are unitarily .", "color": "#7ce8ba", "value": 5, "inDeg": 3}, {"id": "spectraldecomp", "label": "spectral decomposition", "title": "Every admits a spectral decomposition of the form = ( ^{(1)}, , ^{( )} ) & & & 0\\\\ & & & \\\\ & & & \\\\ 0 & & & ( ^{(1)} )^{H}\\\\ \\\\ ( ^{( )} )^{H} = _{ =1}^{ } ^{( )} ( ^{( )})^{H} \\\\ with an orthonormal basis . [t] [scale=2.1, line cap=round, line join=round] (0,0) -- (-0.5,1) node[above right] { }; (0,0) -- (2.0,1) node[above left] { }; {The spectral decomposition of a provides an orthonormal basis . Applying amounts to a scaling of the basis by the . } Each basis element is an of with corresponding , for .", "color": "#7ce8ba", "value": 5, "inDeg": 1}, {"id": "symmetricmatrix", "label": "symmetric matrix", "title": "A square with real-valued entries that is equal to its transpose, i.e., . Every symmetric is a .", "color": "#7ce8ba", "value": 3, "inDeg": 1}, {"id": "transpose", "label": "transpose", "title": "The transpose of a real-valued is obtained by exchanging rows and columns. For a , its transpose is denoted and satisfies .", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "conjugatetranspose", "label": "conjugate transpose", "title": "The conjugate transpose of a is obtained by transposing the and taking the complex conjugate of each entry. For a matrix , its conjugate transpose is denoted by and is defined entrywise by where denotes complex conjugation.", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "hermitian", "label": "Hermitian (matrix)", "title": "A square matrix is Hermitian if it coincides with its conjugate transpose, i.e., . Trivally, a Hermitian matrix is also a .", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "dimension", "label": "dimension", "title": "The dimension of a is the cardinality of any of . Strictly speaking, this definition applies only to finite-dimensional , i.e., those that possess a finite . [H] [scale=1] (O) at (0,0); (O) -- (1.8,0) node[below right] { }; (O) -- (0,1.6) node[above left] { }; (0,0) -- (1.2,1.2) node[above right] { }; (0,0) -- (-1.2,1.2) node[above left] { }; (O) -- (2.0,0.6) node[above right] { }; (O) -- (0.4,1.8) node[left] { }; {Three , , for the .} For such spaces, all have the same cardinality, which is the dimension of the space . \\\\ See also: , .", "color": "#7ce8ba", "value": 10, "inDeg": 8}, {"id": "linearlyindep", "label": "linearly independent", "title": "A subset of a is linearly independent if there is no nontrivial linear combination of these that equals the zero . In other words, \\\\ See also: , , , .", "color": "#7ce8ba", "value": 6, "inDeg": 2}, {"id": "basis", "label": "basis", "title": "A basis of a is a set of such that any can be expressed as a linear combination of the basis , i.e., \\\\ See also: , , .", "color": "#7ce8ba", "value": 6, "inDeg": 3}, {"id": "widematrix", "label": "wide matrix", "title": "A is referred to as wide if it has more columns than rows, i.e., when . [H] (0,0) rectangle ( , ); at (0.5* , 0.5* ) { }; (-0.2, 0) -- (-0.2, ) node[midway, left=8pt] { }; (0, -0.2) -- ( , -0.2) node[midway, below=8pt] { }; See also: .", "color": "#7ce8ba", "value": 2, "inDeg": 1}, {"id": "randomexperiment", "label": "random experiment", "title": "A random experiment is a physical (or abstract) process that produces an from a set of possibilities. This set of all possible is referred to as the of the experiment. The key characteristic of a random experiment is that its is unpredictable (or uncertain). Any measurement or observation of the is a , i.e., a of the . theory uses a as a mathematical structure for the study of random experiments. A key conceptual property of a random experiment is that it can be repeated under identical conditions. Strictly speaking, repeating a random experiment a given number of times defines a new random experiment. The of this new experiment are length- sequences of from the original experiment (see Fig. ). While the of a single experiment is uncertain, the long-run behaviour of the of repeated experiments tends to become increasingly predictable. This informal claim can be made precise via fundamental results of theory, such as the and the . [H] [>=Stealth, node distance=1.5cm and 2cm, every node/.style={font= }] (experiment) [draw, rectangle, rounded corners, minimum width=2.6cm, align=center] {random\\ }; (omega) [right=of experiment] { }; (rightpad) at ( ); (experiment) -- (omega); (sequence) [below=of experiment, yshift=-0.5cm] { }; (sequence1) [below=of sequence, yshift=-0.5cm] { }; (experiment.south) -- node[midway, right, xshift=3pt] {repeat times} (sequence.north); (sequence.south) -- node[midway, right, xshift=3pt] { } (sequence1.north); (experiment.south) -- (sequence.north) coordinate[pos=0.6] (repeatpoint); ; {A random experiment produces an from a set of possibilities (i.e., a ) . Repeating the experiment times yields another random experiment, whose are sequences . One example of a random experiment arising in many applications is the gathering of a . } Examples for random experiments arising in applications include the following: collection: The collected in -based methods can be interpreted as , i.e., as of the of a random experiment. uses a random experiment at each iteration to select a subset of the . methods use random experiments to perturb the of an method to ensure . See also: , , , , .", "color": "#e8d87c", "value": 27, "inDeg": 10}, {"id": "pseudoinverse", "label": "pseudoinverse", "title": "The Moore–Penrose pseudoinverse of a generalizes the notion of an . The pseudoinverse arises naturally in for a with and . The learned by are given by We can then define the pseudoinverse via the limit \\\\ See also: , , .", "color": "#7ce8ba", "value": 9, "inDeg": 2}, {"id": "tallmatrix", "label": "tall matrix", "title": "A is referred to as tall if it has more rows than columns, i.e., when . [H] (0,0) rectangle ( , ); at (0.5* , 0.5* ) { }; (-0.2, 0) -- (-0.2, ) node[midway, left=8pt] { }; (0, -0.2) -- ( , -0.2) node[midway, below=8pt] { }; See also: .", "color": "#7ce8ba", "value": 2, "inDeg": 1}, {"id": "mgf", "label": "moment generating function (MGF)", "title": "Consider the MGF of a real-valued , which is defined as for any for which this exists . As its name indicates, the MGF allows us to compute the moments for . In particular, the th moment is obtained by evaluating the th derivative of for , i.e., . This fact can be verified by the following identities: {t} & = \\{ (t x) \\} \\\\ & {=} \\! \\{ _{k=0}^{ } {t^{k}}{k!} x^{k} \\} \\\\ & {=} _{k=0}^{ } {t^{k}}{k!}\\, \\! \\{ x^{k} \\}. Here, step is due to the Taylor series expansion of and step is valid when the MGF exists for all in some interval . [H] [ width=9cm, height=4.2cm, domain=-1:1, samples=200, xlabel={ }, ylabel={}, ytick= , ytick={-1,-0.5,0,0.5,1}, yticklabels={ , , , , }, xtick={-1,-0.5,0,0.5,1}, xticklabels={ , , , , }, xmin=-1, xmax=1, legend style={at={(1.5,0.02)},anchor=south east} ] ; ; ; {The first few powers of an . The MGF encodes the moments of , which are the of the powers for .} The MGF is a useful tool for the study of sums of independent . As a case in point, if and are independent , then the MGF of their sum typically satisfies , i.e., the MGF of the sum is typically the pointwise product of the individual MGFs . \\\\ See also: , .", "color": "#e8d87c", "value": 3, "inDeg": 1}, {"id": "chernoffbound", "label": "Chernoff bound", "title": "The Chernoff bound is a derived as a direct application of . Let be a real-valued such that its exists for some . Applying to the nonnegative yields, for any , = (-t )\\, \\{ (t )\\} . Note that this is actually an entire family of upper bounds, parametrized by all valid choices for (i.e., must exist). \\\\ See also: , , , .", "color": "#e8d87c", "value": 6, "inDeg": 0}, {"id": "rankdeficient", "label": "rank-deficient", "title": "A is -deficient if it is not , i.e., when . [H] [x=2cm] (0,0) -- (1,0) node[below] { }; (0,0) -- (0,1) node[above] { }; [shift={(3.2,0)}] (A) at (0.2,0.0); (B) at (2.0,0.0); (0,0) -- (A) node[below,yshift=-2pt] { }; (0,0) -- (B) node[above,yshift=2pt] { }; (1.6,0.5) to[bend left] node[midway, above] { } (2.7,0.5); {Example of a -deficient . } In , the solution of the problem is not unique whenever the is such that the is -deficient. \\\\ See also: , , .", "color": "#7ce8ba", "value": 9, "inDeg": 1}, {"id": "fullrank", "label": "full-rank", "title": "A is full- if it has . For a , i.e., when , being full- means that its is equal to . [H] [every node/.style={font= }] at (0,2) { }; { full- square}; at (4.5,2) { }; { square}; at (0,-1.0) { }; { full- }; at (4.5,-1.0) { }; { }; {Examples of full- and .} A square is full- if and only if it is invertible. \\\\ See also: , , , , .", "color": "#7ce8ba", "value": 12, "inDeg": 3}, {"id": "rank", "label": "rank", "title": "The rank of a , denoted as , is the number of columns of . Equivalently, the rank can be defined as the of the . The rank of a can neither exceed the number of rows nor the number of columns of , , i.e., . \\\\ See also: , , , .", "color": "#7ce8ba", "value": 8, "inDeg": 2}, {"id": "inverse", "label": "inverse matrix", "title": "An inverse is defined for a square that is of , meaning its columns are linearly independent. In this case, is said to be invertible, and its inverse satisfies A square is invertible if and only if its is nonzero. Inverse are fundamental in solving systems of linear equations and in the closed-form solution of , . The concept of an inverse can be extended to that are not square or do not have . One may define a ``left inverse'' satisfying or a ``right inverse'' satisfying . For general rectangular or singular , the Moore–Penrose provides a unified concept of a generalized inverse . [H] [x=2cm,y=2cm] (0,0) -- (1,0) node[below right] { }; (0,0) -- (0,1) node[above left] { }; [shift={(2.0,0)}] (A) at (1.5,0.5); (B) at (-0.2,1.2); (0,0) -- (A) node[pos=0.5, below right] { }; (0,0) -- (B) node[above right] { }; [shift={(4.9,0)}] (0,0) -- (1,0) node[pos=0.5, below] { }; (0,0) -- (0,1) node[above] { }; (1.2,0.4) to node[above] { } (1.8,0.4); (3.8,0.4) to node[below] { } (4.4,0.4); {A represents a linear transformation of . The inverse represents the inverse transformation. } See also: , , , .", "color": "#7ce8ba", "value": 9, "inDeg": 4}, {"id": "matrix", "label": "matrix", "title": "A matrix of size is a 2-D array of numbers, which is denoted by Here, denotes the matrix entry in the th row and the th column. Matrices are useful representations of various mathematical objects , including the following: Systems of linear equations: We can use a matrix to represent a system of linear equations One important example of systems of linear equations is the optimality condition for the within . : Consider a -dimensional and a -dimensional . If we fix a for and a for , each matrix naturally defines a (see Fig. ) such that : We can use a matrix to represent a . Each row corresponds to a single , and each column corresponds to a specific or of a . [H] [x=2cm] (0,0) -- (1,0) node[below] { }; (0,0) -- (0,1) node[above] { }; [shift={(3.2,0)}] (0,0) -- (1,0) node[below] { }; (0,0) -- (0,1) node[above] { }; (A) at (0.2,-1.0); (B) at (0.4,1.2); (0,0) -- (A) node[below,right] { }; (0,0) -- (B) node[right,xshift=1pt] { }; (1.6,0.5) to[bend left] node[midway, above] { } (2.7,0.5); {A matrix defines a between two . } See also: , , .", "color": "#7ce8ba", "value": 55, "inDeg": 45}, {"id": "hyperplane", "label": "hyperplane", "title": "A hyperplane is an -dimensional affine of a -dimensional . In the context of a , a hyperplane is a set of the form where is a normal and is an offset. Such a hyperplane partitions into two Hyperplanes arise as the of . \\\\ See also: , , , .", "color": "#e8d87c", "value": 10, "inDeg": 3}, {"id": "normalvector", "label": "normal vector", "title": "See .", "color": "#e8d87c", "value": 1, "inDeg": 0}, {"id": "halfspace", "label": "halfspace", "title": "See .", "color": "#e8d87c", "value": 2, "inDeg": 1}, {"id": "subspace", "label": "subspace", "title": "A subset of a is a subspace of if it is also a with respect to the same operations as . \\\\ See also: .", "color": "#e8d87c", "value": 4, "inDeg": 3}, {"id": "columnspace", "label": "column space", "title": "The column space of a , denoted by , is the set of all linear combinations of the columns of . In other words, The column space of the is a of the . \\\\ See also: , .", "color": "#7ce8ba", "value": 7, "inDeg": 3}, {"id": "mvndist", "label": "multivariate normal distribution", "title": "The multivariate normal distribution, which is denoted by , is a fundamental for numerical of fixed dimension . It defines a family of over -valued ~ , , . Each distribution in this family is fully specified by its and . When the is invertible, the corresponding is characterized by the following : Note that this is only defined when is invertible. More generally, any admits the following representation: where is a and satisfies . This representation remains valid even when is singular, in which case is not ~ . The family of multivariate normal distributions is exceptional among for numerical quantities, at least for the following reasons. First, the family is closed under affine transformations, i.e., Second, the maximizes the among all distributions with the same ~ . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 19, "inDeg": 7}, {"id": "stdnormvec", "label": "standard normal random vector", "title": "A standard normal random is a random whose entries are . It is a special case of a , . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 6, "inDeg": 1}, {"id": "continuous", "label": "continuous", "title": "A is continuous at a point if, for every , there is a such that, for all with , it holds that . In other words, we can make arbitrarily close to by choosing sufficiently close to . [H] [ >=stealth, thick, declare function={f( ) = 0.3*( -2)^3 + 2.5;} ] (0, {f( )- }) rectangle ( , {f( )+ }); (0, {f( )- }) -- ( , {f( )- }); (0, {f( )+ }) -- ( , {f( )+ }); ({ - }, 0) rectangle ({ + }, ); ({ - }, 0) -- ({ - }, ); ({ + }, 0) -- ({ + }, ); ({ - }, {f( )- }) rectangle ({ + }, {f( )+ }); ({ - }, {f( )- }) rectangle ({ + }, {f( )+ }); (-0.5,0) -- ( ,0) node[right] { }; (0,-0.5) -- (0, ) node[above] {}; plot[domain=0.2:4.5, samples=100] ( , {f( )}) node[right] { }; ( , 0) -- ( , {f( )}) -- (0, {f( )}); ( , {f( )}) circle (2pt); at ( , 0) { }; at (0, {f( )}) { }; (-0.2, {f( )}) -- (-0.2, {f( )+ }) node[midway, left=4pt] { }; (-0.2, {f( )- }) -- (-0.2, {f( )}) node[midway, left=4pt] { }; ( , -0.2) -- ({ + }, -0.2) node[midway, below=4pt] { }; ({ - }, -0.2) -- ( , -0.2) node[midway, below=4pt] { }; at (6.2, 1.5) {If ,\\\\ then .}; {The is continuous at every .} If is continuous at every point , then is said to be continuous on . The notion of a continuous can be naturally extended to between general . \\\\ See also: , .", "color": "#e8d87c", "value": 7, "inDeg": 3}, {"id": "minimum", "label": "minimum", "title": "Given a set of real numbers, the minimum is the smallest of those numbers. Note that for some sets, such as the set of negative real numbers, the minimum does not exist.", "color": "#e87c7c", "value": 15, "inDeg": 15}, {"id": "co-domain", "label": "co-domain", "title": "The co- of a is the set into which maps elements of its . [H] [ >=stealth, node distance=2cm, scale=1.0, every node/.style={transform shape} ] (0,0) ellipse (0.8cm and 1.4cm); at (0, 1.6) { }; (3.5,0) ellipse (1cm and 1.6cm); at (3.5, 1.8) {co- }; (3.5, -0.3) circle (0.6cm); at (3.5, -1.1) {range}; (0, 0.5) circle (1.5pt) coordinate (a1); (0, -0.5) circle (1.5pt) coordinate (a2); (3.5, 0) circle (1.5pt) coordinate (b1); (3.5, -0.5) circle (1.5pt) coordinate (b2); (3.5, 1.0) circle (1.5pt) coordinate (b_miss) node[right, font= , gray] {unused}; (a1) -- (b1); (a2) -- (b2); at (1.75, 0.5) { }; See also: , , .", "color": "#e8d87c", "value": 9, "inDeg": 6}, {"id": "cdf", "label": "cumulative distribution function (cdf)", "title": "The cdf of a real-valued is , \\\\ See also: , , .", "color": "#e8d87c", "value": 4, "inDeg": 1}, {"id": "weightedgraph", "label": "weighted graph", "title": "A whose edges are assigned numeric weights. Typically, these edge weights are nonnegative real numbers. For example, if a represents a road network with nodes being intersections and edges representing road segments, the edge weight could represent the capacity (measured in maximum vehicles per hour) of the road segment . [htbp] [scale=1.5, node/.style={circle, fill=black, inner sep=1.9pt}, lab/.style={anchor=west, xshift=3pt} ] (v1) at (0,0) {}; (v2) at (2,0) {}; (v3) at (1,1.5) {}; (v4) at (3,1.5) {}; at (v1) { }; at (v2) { }; at (v3) { }; at (v4) { }; [line width=1pt] (v1) -- node[midway, above] { } (v2); (v2) -- node[midway, right] { } (v3); (v3) -- node[midway, left] { } (v1); (v2) -- node[midway, right] { } (v4); See also: .", "color": "#e8d87c", "value": 2, "inDeg": 1}, {"id": "graph", "label": "graph", "title": "A graph consists of a node set and an edge set . Each edge is characterized by the nodes to which it is connected and in what precise sense. For example, an edge of a is leaving one node and pointing to another node. An edge of an undirected graph connects two nodes without any sense of direction . In principle, there can also be several (parallel) edges that are connected to the same nodes in the same way . Moreover, edges may connect a node to itself, resulting in so-called self-loops . A simple undirected graph contains no parallel edges and no self-loops . Each edge of a simple undirected graph can be identified with a set of two nodes . [htbp] [scale=1, node/.style={circle, fill=black, inner sep=1.9pt}, lab/.style={anchor=west, xshift=3pt} ] (v1) at (0,0) {}; (v2) at (2,0) {}; (v3) at (1,1.5) {}; (v4) at (3,1.5) {}; at (v1) { }; at (v2) { }; at (v3) { }; at (v4) { }; [line width=1pt] (v1) -- (v2); (v2) -- (v3); (v3) -- (v1); (v2) -- (v4); assign a numerical value , referred to as edge weight, to each edge . \\\\ See also: , .", "color": "#e8d87c", "value": 26, "inDeg": 22}, {"id": "markovchain", "label": "Markov chain", "title": "A Markov chain is a , defined on a common and using the index set . The might represent (the generation of) a state of a physical system at the time instant . The defining property of a Markov chain is the Markov property : For all , ^{(X_{ +1} X_ , ,X_1)} = ^{(X_{ +1} X_ )}. In other words, the of the next state depends on the past only through the current state . The concept of a Markov chain can be generalized from discrete time (with index set ) to continuous time (with index set ) . \\\\ See also: , .", "color": "#e8d87c", "value": 5, "inDeg": 1}, {"id": "markovprop", "label": "Markov property", "title": "See .", "color": "#e8d87c", "value": 2, "inDeg": 1}, {"id": "em", "label": "expectation–maximization (EM)", "title": "The EM is an iterative for approximately solving certain that are difficult to solve directly , . To motivate the EM and explain its construction, consider a application involving a single observed with , where is a finite . The generation is modeled via a that consists of a with . Here, the actual - used for the generation via sampling from - are unknown. A widely used approach for estimating these is via the solutions of the problem _{ } - { ; }. For some , such as a , this can be difficult to solve directly. As a work-around, one can often introduce an auxiliary attribute , generated via some , such that the corresponding yields a much easier problem _{ } - { , ; }. The attribute is introduced solely to simplify , but it is not observed in practice—only the feature is available. Thus, we cannot solve directly as we do not know which value to plug into the . The EM method resolves this dilemma by alternating between two steps: computing a “soft’’ estimate of the auxiliary attribute in the form of the using the current choice for the , and minimizing a surrogate derived from this . The completion of these two steps constitutes one full of the EM method. In more detail, the E-step produces the and the M-step minimizes over . This satisfies two key properties , : Q( ) - { ; } . Q( ) =- { ; }. To summarize, during each , EM minimizes an upper-bounding surrogate that is tight at the current iterate . Thus, EM is a method for approximately solving . The above construction and analysis of EM can be extended to more general settings involving multiple and infinite such as ; see for details. \\\\ See also: , , .", "color": "#e8d87c", "value": 21, "inDeg": 2}, {"id": "ppca", "label": "probabilistic principal component analysis (PPCA)", "title": "PPCA extends basic by using a for . The of PPCA frames the task of as an estimation problem that can be solved using . \\\\ See also: , , , .", "color": "#e8d87c", "value": 5, "inDeg": 0}, {"id": "condprobdist", "label": "conditional probability distribution", "title": "Consider a consisting of two and with . The conditional of given (or conditioned on) is denoted by . It is defined via the of the indicator of sets in the generated by the , . \\\\ See also: , .", "color": "#e8d87c", "value": 10, "inDeg": 3}, {"id": "linearmap", "label": "linear map", "title": "A linear is a that satisfies additivity, i.e., , and homogeneity, i.e., , for all and scalars . In particular, . Any linear can be represented as a multiplication , for some . The collection of real-valued linear (where ), for a given dimension , constitute a . The notion of a linear can be generalized from the and to arbitrary . \\\\ See also: , , , , .", "color": "#e87c7c", "value": 20, "inDeg": 12}, {"id": "vector", "label": "vector", "title": "A vector is an element of a . In the context of , a particularly important example of a is the , where is the (finite) dimension of the space. A vector can be represented as a list or one-dimensional (1-D) array of real numbers, i.e., with for . The value is the th entry of the vector . It can also be useful to view a vector as a that maps each index to a value , i.e., . This perspective is particularly useful for the study of . See Fig. for the two views of a vector. [H] [c]{0.48 } 2, --1, 3, 0, --2, 1 { } {0.48 } [ width=6.5cm, height=5cm, title={}, xlabel={index }, ylabel={ }, ymin=-3.5, ymax=3.5, xmin=0.5, xmax=6.5, xtick={1,2,3,4,5,6}, ytick={-3,-2,-1,0,1,2,3}, axis x line=bottom, axis y line=left, grid=both, major grid style={dotted, gray!60}, enlargelimits=0.1 ] +[ycomb, thick, mark=*] coordinates { (1,2) (2,-1) (3,3) (4,0) (5,-2) (6,1) }; at (2,-2.5) {(b)}; {Two equivalent views of a vector . (a) As a numeric array. (b) As a .} See also: , , .", "color": "#e8d87c", "value": 60, "inDeg": 53}, {"id": "vectorspace", "label": "vector space", "title": "A space (also called linear space) is a collection of elements, called , along with the following two operations (see also Fig. ): 1) addition (denoted by ) of two ; and 2) multiplication (denoted by ) of a with a scalar that belongs to some number field (such as the real numbers or the complex numbers ). The defining property of a space is that it is closed under two specific operations. First, if , then . Second, if and , then . [H] [>=Stealth, scale=1.2] (O) at (0,0); (V) at (2,1.5); (W) at (1,3); (VplusW) at (3,4.5); (HalfV) at (1,0.75); (O) -- (V) node[pos=1, right] { }; (O) -- (W) node[pos=1, left] { }; (O) -- (VplusW) node[pos=0.99, above right] { }; (V) -- (VplusW); (W) -- (VplusW); (O) -- (HalfV) node[midway, right] { }; (O) circle (2pt) node[below left] { }; (V) circle (2pt); (W) circle (2pt); (VplusW) circle (2pt); (HalfV) circle (2pt); {A space is a collection of such that scaling and adding them always yields another in .} A common example of a space is the , which is widely used in to represent . We can also use to represent, either exactly or approximately, the used by an method. Another example of a space, which is naturally associated with every , is the collection of all real-valued , . \\\\ See also: , , , .", "color": "#e8d87c", "value": 26, "inDeg": 17}, {"id": "stochastic", "label": "stochastic", "title": "We refer to a method as stochastic if it involves a random component or is governed by probabilistic laws. methods use randomness to reduce computational complexity (e.g., see ) or to capture in . \\\\ See also: , , .", "color": "#e8d87c", "value": 9, "inDeg": 5}, {"id": "stochproc", "label": "stochastic process", "title": "A process is a collection of defined on a common and indexed by some set , , . The index set typically represents time or space, allowing us to represent random phenomena that evolve across time or spatial dimensions—for example, sensor noise or financial time series. processes are not limited to temporal or spatial settings. For instance, random such as the or the can also be viewed as processes. Here, the index set consists of node pairs that index whose values encode the presence or weight of an edge between two nodes. Moreover, processes naturally arise in the analysis of , such as , which construct a of . \\\\ See also: , , , , .", "color": "#e8d87c", "value": 17, "inDeg": 6}, {"id": "characteristicfunc", "label": "characteristic function", "title": "The characteristic of a real-valued is the The characteristic uniquely determines the of . \\\\ See also: , .", "color": "#e8d87c", "value": 4, "inDeg": 1}, {"id": "entropy", "label": "entropy", "title": "Entropy quantifies the or unpredictability associated with an . For a taking on values in a finite set with a , the entropy is defined as For a given set of values , the entropy is maximized for a uniformly distributed , where . The minimal entropy, which is zero, is obtained when for some . generalizes the concept of from to . \\\\ See also: , .", "color": "#e8d87c", "value": 12, "inDeg": 5}, {"id": "diffentropy", "label": "differential entropy", "title": "For an with a , the differential is defined as Differential can be negative and lacks some properties of for discrete-valued , such as invariance under a change of variables . Among all with a given and , is maximized by . \\\\ See also: , .", "color": "#e8d87c", "value": 10, "inDeg": 3}, {"id": "domain", "label": "domain", "title": "The domain of a is the set from which takes its inputs. \\\\ See also: , , .", "color": "#e8d87c", "value": 13, "inDeg": 10}, {"id": "function", "label": "function", "title": "A function between two sets and assigns each element exactly one element . We write this as where is the and the of . That is, a function defines a unique for every input (see Fig. ). [H] [>=stealth, node distance=1.2cm and 2.5cm] {dot/.style={circle, fill=black, inner sep=1.2pt}} (A) [dot, label=left: ] {}; (B) [dot, below=of A, label=left: ] {}; (C) [dot, below=of B, label=left: ] {}; (1) [dot, right=4cm of A, label=right: ] {}; (2) [dot, below=of 1, label=right: ] {}; (3) [dot, below=of 2, label=right: ] {}; ; ; (A) -- (2); (B) -- (1); (C) -- (2); {A function mapping each element of the to exactly one element of the . } See also: , , .", "color": "#e8d87c", "value": 71, "inDeg": 68}, {"id": "map", "label": "map", "title": "We use the term map as a synonym for . \\\\ See also: .", "color": "#e87c7c", "value": 50, "inDeg": 49}, {"id": "event", "label": "event", "title": "Consider an , defined on some , which takes values in a space . An event is a subset of such that the is well defined. In other words, the of an event belongs to the underlying , i.e., the is a subset of the , , . Roughly speaking, an event represents a set of possible of some process. One example of such a process could also be the treatment of a health-care patient. \\\\ See also: , , , .", "color": "#e8d87c", "value": 18, "inDeg": 7}, {"id": "countable", "label": "countable", "title": "A set is called countable if its elements can be put into a one-to-one correspondence with the natural numbers or with a finite subset of . Equivalently, a set is countable if there exists an . [H] [>=stealth, node distance=1.0cm, thick] (a1) { }; (a2) { }; (a3) { }; ; [on background layer] ( ) rectangle ( ); (n1) { }; (n2) { }; (n3) { }; (n4) { }; (ndots) { }; ; (a1) -- (n3); (a2) -- (n1); (a3) -- (n4); {An that maps the elements of a finite set to the natural numbers , which implies that is countable.} Typical examples include the set of integers and rational numbers . In contrast, the set of real numbers is not countable, meaning no such one-to-one correspondence with exists. \\\\ See also: , .", "color": "#e8d87c", "value": 8, "inDeg": 6}, {"id": "pmf", "label": "probability mass function (pmf)", "title": "The pmf of a is a that assigns to each possible value of the the . Fig.\\ illustrates the pmf of a . [H] [>=stealth, thick,y=2cm] / in {1/0.3, 4/0.7}{ ( ,0) -- ( , ); ( , ) circle (2pt); } at (1,0.3) { }; at (1,0) { }; at (4,0) { }; at (-1.2,-0.80) { }; at (-5.2,1.18) { }; at (3.2,1.56) { }; {The pmf of a taking values in the set . Three are also shown whose relative frequencies of match this pmf exactly. Such could arise as of sharing the common pmf . } A pmf always satisfies . We can view a pmf as representing a collection of (sufficiently long) . This collection contains any , with the relative frequencies of every value being close to the corresponding pmf value , Note that requiring relative frequencies to be close to the pmf values implies that the empirical of such a is close to the of the pmf . Information theory refers to the collection of such as the typical set corresponding to the pmf . A main result of information theory states that a generated by sampling from belongs, with high , to the typical set with respect to . \\\\ See also: , , , .", "color": "#e8d87c", "value": 19, "inDeg": 8}, {"id": "discreteRV", "label": "discrete random variable (discrete RV)", "title": "A , i.e., a that maps the of a to elements of a space , is referred to as discrete if its value space . \\\\ See also: , , .", "color": "#e8d87c", "value": 13, "inDeg": 5}, {"id": "rv", "label": "random variable (RV)", "title": "An RV is a that maps the of a to elements of a space , . Mathematically, an RV is a whose is the of a and whose is a space . Different types of RVs include , which map each to an element of a binary set (e.g., or ); { }, which take on values in a set (which can be finite or countably infinite); , which take on values in the real numbers ; { -valued RVs}, which map to the . theory uses the concept of spaces to rigorously define and study the properties of collections of RVs . \\\\ See also: , , , , , , , .", "color": "#e8d87c", "value": 82, "inDeg": 69}, {"id": "outcome", "label": "outcome", "title": "Outcome is one possible result of a physical process. Such a process could be the observation of a physical phenomenon, a computation performed by an , or a . \\\\ See also: .", "color": "#e8d87c", "value": 15, "inDeg": 12}, {"id": "probspace", "label": "probability space", "title": "A space is a mathematical structure that allows us to reason about a , e.g., the observation of a physical phenomenon. Formally, a space is a triplet where is a containing all possible of a ; is a , i.e., a collection of subsets of (called ) that satisfies certain closure properties under set operations; is a , i.e., a that assigns a to each . This must satisfy and for any of pairwise disjoint in . spaces provide the foundation of that can be used to study the behavior of methods , , . \\\\ See also: , , , , , , , .", "color": "#e8d87c", "value": 28, "inDeg": 16}, {"id": "integrable", "label": "integrable", "title": "A defined on a is called integrable if the of its absolute value is finite, i.e., In this case, the is well-defined and finite. An defined on the of a is integrable if which ensures that the exists and is finite. \\\\ See also: , .", "color": "#e8d87c", "value": 10, "inDeg": 1}, {"id": "measurespace", "label": "measure space", "title": "A space is a triple consisting of a set , a of subsets of , and a . The assigns a nonnegative number to each set , generalizing the notions of length, area, or volume in , . spaces provide the mathematical foundation for the or the definition of as mappings between spaces. A is a special case of a space where the total of the is normalized to one, i.e., . In this case, is called a . \\\\ See also: , , .", "color": "#e8d87c", "value": 10, "inDeg": 1}, {"id": "measure", "label": "measure", "title": "A measure on a set equipped with a is a that assigns a nonnegative value to each set such that , , : 1) ; and 2) for any collection of pairwise disjoint sets in , which is referred to as `` additivity''. \\\\ See also: , .", "color": "#e8d87c", "value": 31, "inDeg": 27}, {"id": "LebesgueIntegral", "label": "Lebesgue integral", "title": "The Lebesgue integral assigns each a number that is referred to as the integral of . The integral of can be interpreted as the volume that is enclosed by the in the space . We can compute it be increasingly accurate approximations by . [H] [scale=1.5] (-0.2,0) -- (3.4,0) node[right] { }; plot( ,{0.5+0.3* +0.1* }) node[right] { }; (0,0) -- plot[domain=0:3] ( ,{0.5+0.3* +0.1* }) -- (3,0) -- cycle; (0,0) rectangle (1,0.5); at (0.5,-0.2) { }; (1,0) rectangle (2,0.9); (2,0) rectangle (3,1.5); (0,0.5)--(1,0.5); (1,0.9)--(2,0.9); (2,1.5)--(3,1.5); at (0.8,0.5) {}; in {0,1,2,3} ( ,0) -- ( ,2.5); at (0,-0.05) { }; at (1,-0.05) { }; at (2,-0.05) { }; at (3,-0.05) { }; at (1.6,3.0) { }; [anchor=west] at (3.2,1.5) { }; It is useful to think of the Lebesgue integral as a that maps an to the value of its integral, The precise definition of this , whose consists of the , is a cornerstone of theory . \\\\ See also: .", "color": "#e8d87c", "value": 10, "inDeg": 5}, {"id": "conditionalexpect", "label": "conditional expectation", "title": "Consider a numeric defined on a . Let be a (sub-) that represents partial information about the of a . The conditional of given (or conditioned on) , denoted , is a numeric that , : 1) is with respect to ; and 2) satisfies Intuitively, summarizes the average value of using only information contained in the (typically smaller) , , . \\\\ See also: , , .", "color": "#e8d87c", "value": 9, "inDeg": 2}, {"id": "conditionalpmf", "label": "conditional probability mass function (conditional pmf)", "title": "Consider two and defined on the same . The conditional pmf of given (or conditioned on) is denoted and is defined by for all realizations with . Equivalently, the conditional pmf can be expressed using as where denotes the generated by the . \\\\ See also: , , .", "color": "#e8d87c", "value": 6, "inDeg": 0}, {"id": "iid", "label": "independent and identically distributed (i.i.d.)", "title": "A collection of is referred to as i.i.d. if each follows the same , and the are mutually independent. That is, for any collection of , we have \\\\ See also: , , , , .", "color": "#e8d87c", "value": 26, "inDeg": 21}, {"id": "preimage", "label": "preimage", "title": "Consider a between two sets. The preimage of a subset is the set of all inputs that are mapped into by , i.e., The preimage is well defined even if the is non-invertible . \\\\ See also: .", "color": "#e8d87c", "value": 2, "inDeg": 1}, {"id": "measurable", "label": "measurable", "title": "Consider a , such as recording the air temperature at an weather station. The corresponding consists of all possible (e.g., all possible temperature values in degree Celsius). In many applications, we are not interested in the exact , but only whether it belongs to a subset (e.g., determining whether the temperature is below zero degrees). We call such a subset measurable if it is possible to decide, for any , whether or not (see Fig.\\ ). \\\\ [H] (0,0) -- (8.5,0) node[right] {temperature ( C)}; / in {0/--20, 1/--10, 2/0, 3/10, 4/20, 5/30, 6/40, 7/50, 8/60} { ( ,0.1) -- ( ,-0.1); at ( ,-0.1) { }; } (0,0.3) rectangle (2,0.6); at (1,0.6) { C}; (5.5,0.3) rectangle (7.5,0.6); at (6,0.6) { C C}; {A constituted by all possible temperature values that can occur at an station. Two measurable subsets of temperature values, denoted by and , are highlighted. For any actual temperature value , it is possible to determine (via some equipment) whether and whether . } In principle, measurable sets could be chosen freely (e.g., depending on the resolution of the measuring equipment). However, it is often useful to impose certain completeness requirements on the collection of measurable sets. For example, the itself should be measurable, and the union of two measurable sets should also be measurable. These completeness requirements can be formalized via the concept of a (or ) , , . A measurable space is a pair that consists of an arbitrary set and a collection of measurable subsets of that form a . \\\\ See also: , , , .", "color": "#e8d87c", "value": 21, "inDeg": 13}, {"id": "sigmaalgebra", "label": "-algebra", "title": "Consider a with a . A -algebra (or ) is a collection of subsets of with the following properties , , : The empty set and the entire belong to , i.e., and . If a set belongs to , then its complement also belongs to , i.e., implies . If a collection of sets belongs to , then their union also belongs to , i.e., implies . See also: , , .", "color": "#e8d87c", "value": 16, "inDeg": 10}, {"id": "sigmafield", "label": "-field", "title": "See .", "color": "#e8d87c", "value": 3, "inDeg": 2}, {"id": "injective", "label": "injective", "title": "A is injective if it maps distinct elements of its to distinct elements of its , i.e., if implies for all . Equivalently, no two different inputs are mapped to the same . \\\\ See also: .", "color": "#e8d87c", "value": 5, "inDeg": 1}, {"id": "typicalset", "label": "typical set", "title": "See .", "color": "#e8d87c", "value": 1, "inDeg": 0}, {"id": "majmin", "label": "majorize-minimize (MM)", "title": "Consider an with some complicated (potentially non- and ) . One important example of such an is , which is used to learn the of a nonlinear . An MM method is an iterative that constructs a of as follows , , (see also Fig. ): During the th , the is approximated by another . This approximation must be an upper bound for (i.e., must majorize) the original , i.e., for all , and it must be tight for , i.e., . The new are then obtained by minimizing the approximation, i.e., . [H] [x=1.2cm,y=1cm] ( -0.2,-2) -- ( +0.3,-2) node[right] { }; plot ( ,{sin( r)}) node[pos=0.1,above left,black] { }; plot ( ,{ + (-0.7)*( - )}); ( ,{ +(-0.7)*( - )}) -- ( ,{ +(-0.7)*( - )}); plot ( ,{ +(-0.7)*( - ) + (0.7)*( - )}); at ( , ) { }; (2.35619449,0.70710678) circle (1.2pt); ( ,-2) -- ( , ); at ( ,-2) { }; {The construction of based on the iterative MM method.} Similar to , the MM principle is also based on approximating an locally, around the current , and then optimizing this approximation to obtain new . However, the construction of local approximations is very different. While use linear for these approximations, MM methods can use nonlinear as long as they are upper bounds for the original . \\\\ See also: , .", "color": "#e8d87c", "value": 14, "inDeg": 1}, {"id": "markovsinequality", "label": "Markov's inequality", "title": "Consider a real-valued nonnegative for which the exists. Markov's inequality provides an upper bound on the that exceeds a given positive threshold . In particular, { \\{ x\\}}{a} a > 0. This inequality can be verified by noting that is the with the As illustrated in Fig. , for any positive , This implies Markov's inequality via the monotonicity property of the . [H] [scale=1, x=0.8cm, y=0.8cm] (0,0) -- ( +1,0) node[below right] { }; (0,0) -- (0,3.1) node[left, text=blue!70!black] { }; plot[samples=400, domain=0: , smooth] ( ,{ (6/sqrt(2*pi)) * ( )^(1.5) * exp(- /2) }) -- ( ,0) -- (0,0) -- cycle; plot ( ,{ (6/(sqrt(2*pi))) * ( )^(1.5) * exp(- /2) }) node[pos=0.9, above right, xshift=2pt] {}; ( ,0) -- ( ,1.05); at ( ,0) { }; at (1* ,3) { }; at (0,0) { }; (0,0) -- ( ,0); ( ,0) circle (2pt); ( ,1) -- ( ,1) node[pos=0.9, above, yshift=2pt] { }; ( ,1) circle (2pt); plot ( ,{ (1/ ) }); at ({2.5* +0.2},{2.5}) { }; (0,1) -- ++(-0.12,0) node[left] { }; {The and the of a nonnegative with a can be obtained via of and , respectively.} See also: , , .", "color": "#e8d87c", "value": 10, "inDeg": 3}, {"id": "chebyshevsinequality", "label": "Chebyshev's inequality", "title": "Consider a real-valued for which the second moment exists (and is finite). The existence of the second moment implies the existence of a finite and a finite . Chebyshev's inequality refers to the following upper bound on the that deviates from by more than a given threshold . In particular, { ^2} > 0. This upper bound can be obtained by applying to the new . [H] [ width=9cm, height=4.2cm, samples=300, axis lines=left, ylabel={ }, xlabel={ }, x label style={at={(axis description cs:1,0)}, anchor=west}, ylabel style={rotate=270,anchor=south,at={(axis description cs:0,1.02)}}, xtick={-1.5,0,1.5}, xticklabels={ , , }, ytick= , ymin=0, ymax=0.45, domain=-4:4, clip=false ] ; ; fill between[of=pdf and axis, soft clip={domain=1.5:4}]; fill between[of=pdf and axis, soft clip={domain=-4:-1.5}]; (axis cs:0,0) -- (axis cs:0,0.42); (axis cs:1.5,0) -- (axis cs:1.5,{exp(-0.5*1.5^2)/sqrt(2*pi)}); (axis cs:-1.5,0) -- (axis cs:-1.5,{exp(-0.5*1.5^2)/sqrt(2*pi)}); {Chebyshev's inquality provides an upper bound on the tail (i.e., shaded area) of a real-valued with a finite second moment. } See also: , , .", "color": "#e8d87c", "value": 8, "inDeg": 2}, {"id": "hoeffdingsinequality", "label": "Hoeffding's inequality", "title": "Hoeffding's inequality is a fundamental that provides an upper bound on the that a sum (or average) of independent, bounded deviates from its by more than some threshold. Let be independent real-valued taking values in , and and . Then, Hoeffding's inequality states that { |S_n - \\{S_n\\}| t } 2 ( - { _{i=1}^n (b_i - a_i)^2} ) t > 0. Hoeffding's inequality typically provides sharper bounds than , but it is more restrictive by assuming bounded . In the context of , this result is useful for deriving guarantees for and in the context of . \\\\ See also: , , , , , , .", "color": "#e8d87c", "value": 12, "inDeg": 1}, {"id": "rgg", "label": "random geometric graph (RGG)", "title": "An RGG is a for built from nodes randomly placed in a . Given a , the RGG is characterized by the number of nodes, the connection radius, and the describing the node placement. More precisely, for a node set , each node is assigned to a random position , typically as of taking values in a set . Together with a , this forms a , often with the induced by a . A specific of an RGG contains an edge if and only if the distance between the nodes with respect to the is smaller than some threshold, i.e., when for some threshold , as illustrated in Fig. . [H] [x=0.6cm,y=0.6cm] (-5,-5) rectangle (5,5); at (-5,-5) { }; at (-5, 5) { }; at ( 5,-5) { }; (-2.0,-3.5) circle (2pt); (-2.0,-3.5) circle (2.5); at (-2.0,-3.5) { 1}; (-0.5,-3.3) circle (2pt); (-0.5,-3.3) circle (2.5); at (-0.5,-3.3) { 2}; (-2.0,-3.5) -- (-0.5,-3.3); (3.0,3.5) circle (2pt); (3.0,3.5) circle (2.5); at (3.0,3.5) { 3}; {Illustration of an RGG with and radius (with respect to the ), where nodes 1 and 2 (corresponding to and , within radius ) are connected, while node 3 (corresponding to ) has no other node within that distance.} See also: , , .", "color": "#e8d87c", "value": 12, "inDeg": 0}, {"id": "banachfixedpoint", "label": "Banach's fixed-point theorem", "title": "Banach's fixed-point theorem (also referred to as the contraction principle ) states that every on a complete has a unique fixed point. Formally, let be a non-empty complete and let satisfy for some constant . Then, has a unique fixed point, i.e., there exists a unique with , which can be computed by a . [H] [>=Latex, font= ] {space/.style={draw, thick, circle, minimum size=4.0cm},pt/.style={circle, inner sep=1.5pt, draw, fill=black},maparrow/.style={->, very thick},link/.style={->, thick},distline/.style={dashed, thick}} (XL) at (0,0) {}; (XR) at ( ,0) {}; (XL.east) -- node[above=2pt] { } (XR.west); (x1) at (-0.8,0.9); (x2) at (0.9,0.5); at (x1) {}; at (x2) {}; (fx1) at ( -0.3,0.5); (fx2) at ( +0.6,0.5); (FX1) at (fx1) {}; (FX2) at (fx2) {}; at ( ) { }; at ( ) { }; (xsL) at (0,-0.9); (xsR) at ( ,-0.9); at (xsL) {}; at (xsR) {}; {A has a unique fixed point with .} See also: , , , , .", "color": "#e8d87c", "value": 5, "inDeg": 0}, {"id": "diagonalizable", "label": "diagonalizable", "title": "A square is called diagonalizable if it is similar to a diagonal , . Formally, is diagonalizable if there exists an invertible such that where is a diagonal whose main diagonal entries are the of . A is diagonalizable if and only if it has linearly independent . \\\\ See also: , , .", "color": "#7ce8ba", "value": 8, "inDeg": 4}, {"id": "schurdecomp", "label": "Schur decomposition", "title": "Every square admits a Schur decomposition Here, is a unitary matrix (i.e., ) and is upper triangular with the of on its diagonal. Carefully note that the Schur decomposition exists also for a that is not , {The first step in the construction of the Schur decomposition. Every has at least one with unit-norm , . This allows to decompose as depicted. Here, we extended to an orthonormal basis and used and . Applying the same construction recursively to yields the Schur decomposition.} \\\\ See also: , , .", "color": "#7ce8ba", "value": 5, "inDeg": 0}, {"id": "unitary", "label": "unitary (matrix)", "title": "A square is called unitary if its conjugate transpose (Hermitian transpose) is also its inverse, i.e., if Equivalently, the columns (and rows) of a unitary form an orthonormal basis of with respect to the standard inner product . \\\\ See also: .", "color": "#7ce8ba", "value": 1, "inDeg": 0}, {"id": "innerproduct", "label": "inner product", "title": "Consider a over the field , where is either the field of real numbers or the field of complex numbers . An inner product in is a that satisfies the following properties for all and all scalars : Conjugate symmetry: , Linearity in the first argument: , Positive-definiteness: , with equality if and only if . The pair is called an inner product space. Each inner product induces a via for all , which in turn induces a via for all . \\\\ See also: , , .", "color": "#e8d87c", "value": 6, "inDeg": 0}, {"id": "trace", "label": "trace (matrix)", "title": "The trace of a square is the sum of its diagonal entries . Formally, it is the It satisfies the cyclic property , for any . [font= , every node/.style={inner sep=1pt}] (a11) at (0,0) { }; (a12) at (1,0) { }; (a13) at (2,0) { }; (a21) at (0,-1) { }; (a22) at (1,-1) { }; (a23) at (2,-1) { }; (a31) at (0,-2) { }; (a32) at (1,-2) { }; (a33) at (2,-2) { }; (-0.4,0.4) rectangle (2.4,-2.4); (C) at ( ); (C) ellipse [x radius=2.1cm, y radius=0.35cm,rotate=-45]; Furthermore, if has (each repeated according to its algebraic multiplicity), then This identity follows from the invariance of the trace under similarity transformations .\\\\ See also: , .", "color": "#7ce8ba", "value": 4, "inDeg": 1}, {"id": "stddev", "label": "standard deviation", "title": "The standard deviation of a real-valued is defined as the square root of its , i.e., . \\\\ See also: , , .", "color": "#e8d87c", "value": 3, "inDeg": 0}, {"id": "sequence", "label": "sequence", "title": "A sequence is an ordered collection of values from a set . For example, a sequence of values from the set could be Formally, a sequence is a We denote a sequence by or . Sometimes we also use the notation . Note that the same value can appear multiple times in the sequence at different positions . Sequences are fundamental for the study of methods, for instance when describing successive iterates of an iterative . We can also use a sequence to represent an infinite See also: , .", "color": "#e8d87c", "value": 21, "inDeg": 17}, {"id": "convergence", "label": "convergence", "title": "Consider a with numeric values . This is said to converge to a value if the values become arbitrarily close to for sufficiently large indices . Mathematically speaking, the converges to if , We denote the convergence of a to by [H] [x=1.2cm, y=2cm, >=stealth] (0.5,0) -- (6.5,0) node[right] { }; (0.5,0) -- (0.5,1.6) node[above] { }; (0, {1- }) rectangle (6.3, {1+ }); (0,{1+ }) -- (6.3,{1+ }) node[right] { }; (0,{1- }) -- (6.3,{1- }) node[right] { }; (0,1) -- (6.3,1) node[right] { }; in {1,...,6} { {1 - 0.6^( )} ( , ) circle (2pt); } in {1,2,3} { ( ,0.02) -- ( ,-0.02) node[below] { }; } ( ,0) -- ( ,1.7); at ( ,1.7) { }; {A real-valued sequence converging to the limit . } The concept of convergence of a real-valued (where ) extends naturally to a in an arbitrary . Indeed, we just need to replace the absolute difference by the . Note that a can only converge if it is a . However, not every is converging unless the underlying is complete. \\\\ See also: , , .", "color": "#e8d87c", "value": 10, "inDeg": 6}, {"id": "johnsonlindenstrausslemma", "label": "Johnson--Lindenstrauss lemma (JL lemma)", "title": "The JL lemma describes conditions for the existence of a with such that the pairwise between of a finite is approximately preserved , , . Consider a with characterized by in . Then, for any that satisfies there is a such that (1\\!-\\! ) { ^{( )}\\!-\\! ^{( ')}}{2} \\! \\! { ( ^{( )} )\\!-\\! ( ^{( ')} )}{2} \\! \\!(1\\!+\\! ) { ^{( )}\\!-\\! ^{( ')}}{2} for all . [H] (x1) at (0.5,-0.6); (x2) at (2.0,0.9); (x3) at (1.1,0.3); in {x1,x2,x3} ( ) circle (1.7pt); at (x1) { }; at (x2) { }; at (x3) { }; [anchor=east] at (1.2,2.2) { }; [xshift=1cm] (2.9,2.2) -- (4.1,2.2) node[midway, above] { }; [xshift=2cm] (y1) at (4.7,-0.7); (y2) at (6.1,0.5); (y3) at (5.3,-0.1); in {y1,y2,y3} ( ) circle (1.7pt); at (y1) { }; at (y2) { }; at (y3) { }; [anchor=west] at (6.0,2.2) { }; {The JL lemma offers precise conditions that guarantee the existence of a such that pairwise between (the of) are approximately preserved. Roughly speaking, maps neighboring points in the original to neighboring points in the new .} The can be obtained from a random whose entries are . It can be shown that the satisfies with at least . \\\\ See also: , , , , , .", "color": "#e8d87c", "value": 17, "inDeg": 2}, {"id": "statespace", "label": "state space", "title": "The state space of a system is a set that contains all possible states of a system at a given time step. A state is a mathematical representation of the information that characterizes the system. States may be fully observed, partially observed, or latent. State spaces are used across a wide range of techniques, including and . \\\\ See also: , , , .", "color": "#9b7ce8", "value": 7, "inDeg": 1}, {"id": "differentiable", "label": "differentiable", "title": "A real-valued is differentiable if it can be approximated locally at any point by a linear . The local linear approximation at the point is determined by the . \\\\ See also: , .", "color": "#9be87c", "value": 16, "inDeg": 14}, {"id": "gradient", "label": "gradient", "title": "For a real-valued , if a exists such that , it is referred to as the gradient of at . If it exists, the gradient is unique and denoted by or . \\\\ See also: , .", "color": "#9be87c", "value": 22, "inDeg": 20}, {"id": "subgradient", "label": "subgradient", "title": "For a real-valued , a such that is referred to as a subgradient of at , . \\\\ See also: , .", "color": "#e8d87c", "value": 4, "inDeg": 2}, {"id": "strcvx", "label": "strongly convex", "title": "A continuously real-valued is strongly with coefficient if , . \\\\ See also: , , .", "color": "#e8d87c", "value": 4, "inDeg": 1}, {"id": "strictlyconvex", "label": "strictly convex", "title": "A real-valued is strictly if for any two distinct in its and any it satisfies Equivalently, for any , which implies that admits a unique minimizer on any subset of its . Unlike , strictly do not require a uniform quadratic lower bound. \\\\ See also: , .", "color": "#e8d87c", "value": 5, "inDeg": 1}, {"id": "directedcycle", "label": "directed cycle", "title": "A directed cycle in a is a of distinct nodes such that . In a directed cycle, following the direction of each edge eventually leads back to the starting node, creating a closed loop. [H] [>=Latex, node distance=1.4cm, thick] (a1) at (90:1.5); (a2) at (210:1.5); (a3) at (330:1.5); (a1) circle (2pt) node[above=3pt] { }; (a2) circle (2pt) node[below left=3pt] { }; (a3) circle (2pt) node[below right=3pt] { }; (a1) -- (a2); (a2) -- (a3); (a3) -- (a1); ; ; ; {A directed cycle consisting of three nodes in a closed loop.} The presence of a directed cycle prevents a from being a . \\\\ See also: , .", "color": "#e87cd8", "value": 5, "inDeg": 1}, {"id": "dag", "label": "directed acyclic graph (DAG)", "title": "A DAG is a which contains no . Formally, a DAG satisfies that, for any of distinct nodes , the presence of directed edges implies that . [H] [>=Latex, node distance=1.4cm, thick, every node/.style={circle, fill=black, inner sep=1.5pt}] (a1) {}; (a2) {}; (a3) {}; (a1) -- (a2); (a2) -- (a3); at (1.5,-1.5) {(a)}; (b1) {}; (b2) {}; (b3) {}; (b1) -- (b2); (b2) -- (b3); (b3) to (b1); at (8.3,-1.5) {(b)}; {(a) A DAG defined on three nodes . (b) Another on the same nodes that is not a DAG, since it contains a .} The absence of allows for a topological ordering of nodes such that all edges point from earlier to later nodes in this order. Several , such as or , are naturally represented as DAGs. \\\\ See also: , , .", "color": "#e87cd8", "value": 10, "inDeg": 3}, {"id": "directedgraph", "label": "directed graph", "title": "A directed contains edges that have an orientation (or direction). Mathematically, a directed consists of nodes and a set of directed edges. [H] [>=stealth, node distance=1.8cm] (i) {}; (ip) [right=of i] {}; (i) -- (ip); {The edges of a directed have an orientation (or direction). We can indicate the orientation by an arrow head.} We can represent a directed edge from node to node by an ordered pair . Directed are widely used to model interconnected systems or networks, such as transportation systems, electronic circuits, and biological processes . \\\\ See also: .", "color": "#e87cd8", "value": 4, "inDeg": 3}, {"id": "undirectedgraph", "label": "undirected graph", "title": "See .", "color": "#e8d87c", "value": 7, "inDeg": 6}, {"id": "simplefunction", "label": "simple function", "title": "A simple is a that takes on only finitely many values. In other words, where denotes the indicator of a subset and are arbitrary coefficients. The subsets in the above decomposition must be and must form a partition of . \\\\ See also: , .", "color": "#e8d87c", "value": 4, "inDeg": 1}, {"id": "gradstep", "label": "gradient step", "title": "Given a real-valued and a , the step updates by adding the scaled negative to obtain the new (see Fig. ) - f( ). Mathematically, the step is an operator that is paramet\\-rized by the and the . [H] [scale=0.8] (-4,0) grid (4,4); plot ( , {(1/4)* }); plot ( , {2* - 4}); (4,4) -- node[right] { } (4,2); (4,4) -- node[above] { } (2,4); (4,2) -- node[below] { } (3,2) ; at (-4.1, 4.1) { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; {The basic step maps a given to the updated . It defines an operator .} Note that the step optimizes locally—in a whose size is determined by the —a linear approximation to the . A natural of is to locally optimize the itself—instead of its linear approximation—such that = _{ ' ^{ }} f( ')\\!+\\! { } {2}^2. We intentionally use the same symbol for the in as we used for the in . The larger the we choose in , the more progress the update will make toward reducing the value . Note that, much like the step , the update also defines an operator that is parameterized by the and the . For a , this operator is known as the of . \\\\ See also: , , , , , , , , , , .", "color": "#9be87c", "value": 29, "inDeg": 18}, {"id": "mirrordescent", "label": "mirror descent", "title": "Mirror descent is an iterative obtained by generalizing the . The for minimizing a , can be written as Thus, a minimizes a linearization of penalized by a scaled squared . The scaling factor if the inverse of the used in the . Mirror descent replaces the squared by a induced by a . This mirror map is typically defined on a set and is and on the interior of . The resulting update becomes See also: , , .", "color": "#e8d87c", "value": 11, "inDeg": 0}, {"id": "bregmandivergence", "label": "Bregman divergence", "title": "The Bregman divergence induced by a , is defined as for in the of . It measures the deviation of from its first-order Taylor approximation around and is in general neither symmetric nor a . [htbp] [scale=3.4] (0,0)--(1,0)--(0.5,1)--cycle; at (0.5,0.4) { }; (0.06,0.04)--(0.94,0.04)--(0.50,0.92)--cycle; (0.14,0.09)--(0.86,0.09)--(0.50,0.82)--cycle; (0.24,0.16)--(0.76,0.16)--(0.50,0.68)--cycle; (0.36,0.25)--(0.64,0.25)--(0.50,0.55)--cycle; (0.50,0.36)--(0.50,0.36)--(0.50,0.36)--cycle; {Contour lines of a defined on a set . The density of the contour lines can be used to steer the used in a : If the current lies in a region with dense contour lines, a smaller is preferable}. For twice , the divergence behaves locally like a quadratic form which can be interpreted as a squared of the displacement induced by . \\\\ See also: , .", "color": "#e8d87c", "value": 11, "inDeg": 1}, {"id": "mdp", "label": "Markov decision process (MDP)", "title": "An MDP is a mathematical structure for the study of . Formally, an MDP is a which is defined by a specific choice for a ; an ; a transition specifying the over the next state , given the current state and action ; a that assigns a numerical to each state-action pair . These components define the of a of . The defining property of an MDP is the . That is, at time instant , the of the next state and depends on the past only via the current state and action . \\\\ See also: , , , , , .", "color": "#e8d87c", "value": 12, "inDeg": 0}, {"id": "reinforcementlearning", "label": "reinforcement learning (RL)", "title": "RL refers to an setting where we can only evaluate the usefulness of a single (i.e., a choice of ) at each time step . In particular, RL methods apply the current to the of the newly received . The usefulness of the resulting is quantified by a signal (see Fig. ). [H] [scale=1] (-2, 0) -- (6, 0); at (6.3, 0) { }; plot ( -3, {-0.2*( )^2 + 2}); at (0-3, {-0.2*(0)^2 + 2}) { }; (1.5-3, {-0.2*(1.5)^2 + 2}) circle (2pt); at (1.5-3, -0.3) { }; (1.5-3, 0) -- (1.5-3, {-0.2*(1.5)^2 + 2}); plot ( , {-0.15*( - 2)^2 + 3}); at (3, {-0.15*(3 - 2)^2 + 3}) { }; (2, {-0.15*(2 - 2)^2 + 3}) circle (2pt); at (2, -0.3) { }; (2, 0) -- (2, {-0.15*(3 - 2)^2 + 3}); plot ( +2, {-0.1*( - 4)^2 + 1.5}); at (4.5+2, {-0.1*(4.5 - 4)^2 + 1.5}) { }; (3.5+2, {-0.1*(3.5 - 4)^2 + 1.5}) circle (2pt); at (3.5+2, -0.3) { }; (3.5+2, 0) -- (3.5+2, {-0.1*(3.5 - 4)^2 + 1.5}); {Three consecutive time steps with corresponding . During time step , an RL method can evaluate the only for one specific , resulting in the signal . } In general, the depends also on the previous for . The goal of RL is to learn , for each time step , such that the (possibly discounted) cumulative is maximized , . \\\\ See also: , , .", "color": "#9b7ce8", "value": 16, "inDeg": 7}, {"id": "action", "label": "action", "title": "An action refers to a decision taken by an system at a given time step that influences the observed signal. The actions are elements of an action space and are typically denoted by . The action is selected based on the (that collects all available observations) and the current . RL uses methods to learn a that predicts an (nearly) optimal action. The usefulness of the is evaluated indirectly through the resulting signal . In the special case of a , the set of possible actions is finite and each action corresponds to selecting one arm. In more general RL settings, the action space may be continuous. \\\\ See also: , , , , .", "color": "#9b7ce8", "value": 11, "inDeg": 2}, {"id": "actionspace", "label": "action space", "title": "See .", "color": "#9b7ce8", "value": 2, "inDeg": 1}, {"id": "mab", "label": "multiarmed bandit (MAB)", "title": "An MAB problem is a precise formulation of a sequential decision-making task under . At each discrete time step , a learner selects one of several possible actions—called arms—from a finite set . Pulling arm at time yields a that is drawn from an unknown . We obtain different classes of MAB problems by placing different restrictions on this . In the simplest setting, the does not depend on . Given an MAB problem, the goal is to construct methods that maximize the cumulative over time by strategically balancing exploration (i.e., gathering information about uncertain arms) and exploitation (i.e., selecting arms known to perform well). MAB problems form an important special case of problems , . \\\\ See also: , .", "color": "#e8d87c", "value": 10, "inDeg": 4}, {"id": "regret", "label": "regret", "title": "The regret of a relative to another , which serves as a , is the difference between the incurred by and the incurred by . The is also referred to as an . \\\\ See also: , , .", "color": "#e87c7c", "value": 7, "inDeg": 3}, {"id": "personaldata", "label": "personal data", "title": "Any information relating to an identified or identifiable natural person (the subject). A natural person is identifiable if they can be identified, directly or indirectly, in particular by reference to an identifier such as a name, an identification number, location data, an online identifier, or one or more factors specific to the physical, physiological, genetic, mental, economic, cultural, or social identity of that person . In machine learning systems, personal data may occur in training data, model inputs, intermediate representations (e.g.\\ feature vectors or embeddings), or model outputs, provided the information relates to an identifiable natural person. The EU AI Act does not introduce a separate definition of personal data; whenever an AI system processes personal data, the GDPR definition and obligations apply in full.", "color": "#9be87c", "value": 1, "inDeg": 0}, {"id": "profiling", "label": "profiling", "title": "Profiling aims at identifying patterns and make inferences about individuals based on their . Profiling techniques use a methods to predict individual's performance at work, economic situation, health, personal preferences, interests, reliability, behavior, location, or movements. Profiling is instrumental in targeted advertising, credit scoring, fraud detection, and personalized services. The impose strict requirements on organizations that engage in profiling activities to ensure that individuals' rights are protected .", "color": "#9be87c", "value": 4, "inDeg": 1}, {"id": "aisystem", "label": "artificial intelligence system (AI system)", "title": "The EU Artificial Intelligence Act defines an system as a machine-based system that is designed to operate with varying levels of autonomy and that may exhibit adaptiveness (e.g., re-training) after deployment. systems compute that can influence environments or decisions . In line with this definition, regulatory obligations and risk classifications apply at the level of the AI system rather than at the level of individual or . The system-level view emphasizes that properties such as , fairness and emerge from the interaction of , , and operational context rather than from isolated components.", "color": "#9be87c", "value": 9, "inDeg": 2}, {"id": "gdpr", "label": "general data protection regulation (GDPR)", "title": "The GDPR was enacted by the European Union (EU), effective from 25 May 2018 . It safeguards the privacy and rights of individuals in the EU. The GDPR has significant implications for how are collected, stored, and used in applications. Key provisions include the following: : systems should only use the necessary amount of personal for their purpose. and : systems should enable their users to understand how the systems make decisions that impact the users. subject rights: Users should get an opportunity to access, rectify, and delete their personal , as well as to object to automated decision-making and . Accountability: Organizations must ensure robust security and demonstrate compliance through documentation and regular audits. See also: , , , , .", "color": "#9be87c", "value": 11, "inDeg": 5}, {"id": "highriskaisystem", "label": "high-risk artificial intelligence system (high-risk AI system)", "title": "A subset of that are classified as high-risk due to their potential to significantly impact safety, fundamental rights, or critical societal functions. High-risk AI systems are subject to stringent regulatory requirements under the EU Artificial Intelligence Act, including conformity assessments, risk management, transparency obligations, and post-market monitoring . Examples of high-risk AI systems include those used in critical infrastructure, education, employment, law enforcement, and biometric identification.", "color": "#9be87c", "value": 1, "inDeg": 0}, {"id": "deepfake", "label": "deepfake", "title": "Synthetic media generated or substantially modified by an such that it falsely appears to depict a real person, object, or . Deepfakes are typically produced using generative methods, trained to imitate visual, audio, or audiovisual characteristics of real data. From a system perspective, deepfakes are characterized by a deliberate mismatch between the observable content and its true origin, which can lead to deception, misinformation, or manipulation. CITE relavant legal sources.", "color": "#9be87c", "value": 2, "inDeg": 0}, {"id": "transparency", "label": "transparency", "title": "Transparency is a fundamental requirement for . In the context of methods, transparency is often used interchangeably with , . However, in the broader scope of systems, transparency extends beyond and includes providing information about the system’s limitations, reliability, and intended use. In medical diagnosis systems, transparency requires disclosing the confidence level for the delivered by a trained . In credit scoring, -based lending decisions should be accompanied by explanations of contributing factors, such as income level or credit history. These explanations allow humans (e.g., a loan applicant) to understand and contest automated decisions. Some methods inherently offer transparency. For example, provides a quantitative measure of reliability through the value . are another example, as they allow human-readable decision rules . Transparency also requires a clear indication when a user is engaging with an system. For example, -powered chatbots should notify users that they are interacting with an automated system rather than a human. Furthermore, transparency encompasses comprehensive documentation detailing the purpose and design choices underlying the system. For instance, datasheets and system cards help practitioners understand the intended use cases and limitations of an system . \\\\ See also: , .", "color": "#e87c7c", "value": 14, "inDeg": 5}]);
    const edges = new vis.DataSet([{"from": "imagesegmentation", "to": "clustering"}, {"from": "stratification", "to": "dataset"}, {"from": "stratification", "to": "stratum"}, {"from": "stratification", "to": "ml"}, {"from": "stratification", "to": "model"}, {"from": "stratification", "to": "trainset"}, {"from": "stratification", "to": "valset"}, {"from": "stratification", "to": "datapoint"}, {"from": "stratification", "to": "validation"}, {"from": "stratification", "to": "kfoldcv"}, {"from": "stratum", "to": "datapoint"}, {"from": "stratum", "to": "feature"}, {"from": "stratum", "to": "label"}, {"from": "stratum", "to": "dataset"}, {"from": "stratum", "to": "fmi"}, {"from": "stratum", "to": "stratification"}, {"from": "det", "to": "matrix"}, {"from": "det", "to": "function"}, {"from": "det", "to": "diagonalizable"}, {"from": "det", "to": "eigenvalue"}, {"from": "det", "to": "vector"}, {"from": "det", "to": "inverse"}, {"from": "hessian", "to": "function"}, {"from": "hessian", "to": "partialderivative"}, {"from": "hessian", "to": "matrix"}, {"from": "hessian", "to": "continuous"}, {"from": "hessian", "to": "neighborhood"}, {"from": "hessian", "to": "convex"}, {"from": "hessian", "to": "psd"}, {"from": "hessian", "to": "quadfunc"}, {"from": "hessian", "to": "gradient"}, {"from": "hessian", "to": "smooth"}, {"from": "hessian", "to": "differentiable"}, {"from": "attention", "to": "ml"}, {"from": "attention", "to": "datapoint"}, {"from": "attention", "to": "token"}, {"from": "attention", "to": "probmodel"}, {"from": "attention", "to": "function"}, {"from": "attention", "to": "parameter"}, {"from": "attention", "to": "erm"}, {"from": "attention", "to": "model"}, {"from": "attention", "to": "vector"}, {"from": "attention", "to": "nlp"}, {"from": "transformer", "to": "ml"}, {"from": "transformer", "to": "ann"}, {"from": "transformer", "to": "attention"}, {"from": "transformer", "to": "token"}, {"from": "transformer", "to": "model"}, {"from": "transformer", "to": "data"}, {"from": "transformer", "to": "rnn"}, {"from": "transformer", "to": "layer"}, {"from": "transformer", "to": "nlp"}, {"from": "rnn", "to": "ann"}, {"from": "rnn", "to": "data"}, {"from": "rnn", "to": "sequence"}, {"from": "rnn", "to": "token"}, {"from": "rnn", "to": "prediction"}, {"from": "rnn", "to": "gdmethod"}, {"from": "llm", "to": "ml"}, {"from": "llm", "to": "model"}, {"from": "llm", "to": "modelparam"}, {"from": "llm", "to": "data"}, {"from": "llm", "to": "sequence"}, {"from": "llm", "to": "token"}, {"from": "llm", "to": "transformer"}, {"from": "llm", "to": "selfsupervisedlearning"}, {"from": "llm", "to": "training"}, {"from": "llm", "to": "labeled datapoint"}, {"from": "llm", "to": "label"}, {"from": "llm", "to": "feature"}, {"from": "llm", "to": "datapoint"}, {"from": "llm", "to": "trainset"}, {"from": "llm", "to": "nlp"}, {"from": "selfsupervisedlearning", "to": "feature"}, {"from": "selfsupervisedlearning", "to": "datapoint"}, {"from": "selfsupervisedlearning", "to": "label"}, {"from": "selfsupervisedlearning", "to": "nlp"}, {"from": "selfsupervisedlearning", "to": "training"}, {"from": "selfsupervisedlearning", "to": "llm"}, {"from": "selfsupervisedlearning", "to": "data"}, {"from": "optproblem", "to": "objfunc"}, {"from": "optmethod", "to": "algorithm"}, {"from": "optmethod", "to": "optproblem"}, {"from": "optmethod", "to": "output"}, {"from": "optmethod", "to": "ml"}, {"from": "optmethod", "to": "erm"}, {"from": "convexopt", "to": "convex"}, {"from": "convexopt", "to": "optproblem"}, {"from": "convexopt", "to": "euclidspace"}, {"from": "convexopt", "to": "objfunc"}, {"from": "convexopt", "to": "function"}, {"from": "convexopt", "to": "epigraph"}, {"from": "convexopt", "to": "optmethod"}, {"from": "newtonmethod", "to": "optmethod"}, {"from": "newtonmethod", "to": "minimum"}, {"from": "newtonmethod", "to": "maximum"}, {"from": "newtonmethod", "to": "differentiable"}, {"from": "newtonmethod", "to": "objfunc"}, {"from": "newtonmethod", "to": "gdmethod"}, {"from": "newtonmethod", "to": "gradient"}, {"from": "newtonmethod", "to": "hessian"}, {"from": "newtonmethod", "to": "matrix"}, {"from": "newtonmethod", "to": "quadfunc"}, {"from": "newtonmethod", "to": "function"}, {"from": "newtonmethod", "to": "convergence"}, {"from": "newtonmethod", "to": "iteration"}, {"from": "newtonmethod", "to": "gd"}, {"from": "newtonmethod", "to": "lossfunc"}, {"from": "hilbertspace", "to": "vectorspace"}, {"from": "hilbertspace", "to": "norm"}, {"from": "hilbertspace", "to": "cauchysequence"}, {"from": "hilbertspace", "to": "vector"}, {"from": "hilbertspace", "to": "projection"}, {"from": "hilbertspace", "to": "subspace"}, {"from": "hilbertspace", "to": "euclidspace"}, {"from": "cauchysequence", "to": "sequence"}, {"from": "cauchysequence", "to": "metricspace"}, {"from": "cauchysequence", "to": "fixedpointiter"}, {"from": "nonexpansiveop", "to": "operator"}, {"from": "nonexpansiveop", "to": "hilbertspace"}, {"from": "nonexpansiveop", "to": "fixedpointiter"}, {"from": "nonexpansiveop", "to": "contractop"}, {"from": "fixedpointiter", "to": "iteration"}, {"from": "fixedpointiter", "to": "optproblem"}, {"from": "fixedpointiter", "to": "sequence"}, {"from": "fixedpointiter", "to": "operator"}, {"from": "fixedpointiter", "to": "differentiable"}, {"from": "fixedpointiter", "to": "convex"}, {"from": "fixedpointiter", "to": "function"}, {"from": "fixedpointiter", "to": "nonexpansiveop"}, {"from": "fixedpointiter", "to": "modelparam"}, {"from": "fixedpointiter", "to": "contractop"}, {"from": "fixedpointiter", "to": "proxop"}, {"from": "ergraph", "to": "graph"}, {"from": "ergraph", "to": "probmodel"}, {"from": "ergraph", "to": "iid"}, {"from": "ergraph", "to": "rv"}, {"from": "ergraph", "to": "realization"}, {"from": "ergraph", "to": "probability"}, {"from": "attack", "to": "ml"}, {"from": "attack", "to": "dataset"}, {"from": "attack", "to": "datapoisoning"}, {"from": "attack", "to": "device"}, {"from": "attack", "to": "privattack"}, {"from": "attack", "to": "sensattr"}, {"from": "attack", "to": "dosattack"}, {"from": "attack", "to": "backdoor"}, {"from": "privattack", "to": "attack"}, {"from": "privattack", "to": "ml"}, {"from": "privattack", "to": "sensattr"}, {"from": "privattack", "to": "model"}, {"from": "privattack", "to": "modelinversion"}, {"from": "privattack", "to": "trustAI"}, {"from": "privattack", "to": "gdpr"}, {"from": "epigraph", "to": "function"}, {"from": "epigraph", "to": "graph"}, {"from": "epigraph", "to": "convex"}, {"from": "nullspace", "to": "matrix"}, {"from": "nullspace", "to": "vector"}, {"from": "nullspace", "to": "featlearn"}, {"from": "nullspace", "to": "featurevec"}, {"from": "nullspace", "to": "datapoint"}, {"from": "nullspace", "to": "featurespace"}, {"from": "nullspace", "to": "prediction"}, {"from": "nullspace", "to": "model"}, {"from": "nullspace", "to": "classifier"}, {"from": "nullspace", "to": "featuremap"}, {"from": "maximum", "to": "supremum"}, {"from": "discrepancy", "to": "fl"}, {"from": "discrepancy", "to": "netdata"}, {"from": "discrepancy", "to": "empgraph"}, {"from": "discrepancy", "to": "measure"}, {"from": "discrepancy", "to": "hypothesis"}, {"from": "discrepancy", "to": "map"}, {"from": "discrepancy", "to": "localmodel"}, {"from": "FedRelax", "to": "fl"}, {"from": "FedRelax", "to": "distributedalgorithm"}, {"from": "fedavg", "to": "fl"}, {"from": "fedavg", "to": "algorithm"}, {"from": "fedavg", "to": "localmodel"}, {"from": "fedavg", "to": "modelparam"}, {"from": "fedavg", "to": "stochGD"}, {"from": "FedGD", "to": "fl"}, {"from": "FedGD", "to": "distributedalgorithm"}, {"from": "FedGD", "to": "empgraph"}, {"from": "FedGD", "to": "gradstep"}, {"from": "FedGD", "to": "gdmethod"}, {"from": "FedSGD", "to": "fl"}, {"from": "FedSGD", "to": "distributedalgorithm"}, {"from": "FedSGD", "to": "empgraph"}, {"from": "FedSGD", "to": "gradstep"}, {"from": "FedSGD", "to": "gdmethod"}, {"from": "FedSGD", "to": "stochGD"}, {"from": "hfl", "to": "localdataset"}, {"from": "hfl", "to": "datapoint"}, {"from": "hfl", "to": "feature"}, {"from": "hfl", "to": "ssl"}, {"from": "hfl", "to": "fl"}, {"from": "hfl", "to": "vfl"}, {"from": "dimred", "to": "feature"}, {"from": "dimred", "to": "risk"}, {"from": "dimred", "to": "overfitting"}, {"from": "dimred", "to": "effdim"}, {"from": "dimred", "to": "model"}, {"from": "dimred", "to": "ml"}, {"from": "dimred", "to": "linreg"}, {"from": "dimred", "to": "matrix"}, {"from": "dimred", "to": "data"}, {"from": "dimred", "to": "scatterplot"}, {"from": "dimred", "to": "datapoint"}, {"from": "dimred", "to": "autoencoder"}, {"from": "dimred", "to": "randomprojection"}, {"from": "dimred", "to": "pca"}, {"from": "dimred", "to": "johnsonlindenstrausslemma"}, {"from": "diagnosis", "to": "erm"}, {"from": "diagnosis", "to": "model"}, {"from": "diagnosis", "to": "hypothesis"}, {"from": "diagnosis", "to": "trainerr"}, {"from": "diagnosis", "to": "valerr"}, {"from": "diagnosis", "to": "trainset"}, {"from": "diagnosis", "to": "valset"}, {"from": "diagnosis", "to": "baseline"}, {"from": "diagnosis", "to": "bayesrisk"}, {"from": "diagnosis", "to": "ml"}, {"from": "diagnosis", "to": "validation"}, {"from": "diagnosis", "to": "kfoldcv"}, {"from": "diagnosis", "to": "generalization"}, {"from": "ml", "to": "hypothesis"}, {"from": "ml", "to": "map"}, {"from": "ml", "to": "model"}, {"from": "ml", "to": "prediction"}, {"from": "ml", "to": "label"}, {"from": "ml", "to": "datapoint"}, {"from": "ml", "to": "measure"}, {"from": "ml", "to": "loss"}, {"from": "ml", "to": "lossfunc"}, {"from": "ml", "to": "feature"}, {"from": "ml", "to": "data"}, {"from": "ml", "to": "hypospace"}, {"from": "ml", "to": "dataset"}, {"from": "ml", "to": "training"}, {"from": "ml", "to": "erm"}, {"from": "ml", "to": "onlinelearning"}, {"from": "featlearn", "to": "ml"}, {"from": "featlearn", "to": "datapoint"}, {"from": "featlearn", "to": "feature"}, {"from": "featlearn", "to": "map"}, {"from": "featlearn", "to": "featurespace"}, {"from": "featlearn", "to": "hypospace"}, {"from": "featlearn", "to": "measure"}, {"from": "featlearn", "to": "pca"}, {"from": "featlearn", "to": "minimum"}, {"from": "featlearn", "to": "dataset"}, {"from": "encoder", "to": "autoencoder"}, {"from": "autoencoder", "to": "ml"}, {"from": "autoencoder", "to": "encoder"}, {"from": "autoencoder", "to": "map"}, {"from": "autoencoder", "to": "model"}, {"from": "autoencoder", "to": "ann"}, {"from": "autoencoder", "to": "vector"}, {"from": "autoencoder", "to": "linmodel"}, {"from": "autoencoder", "to": "pca"}, {"from": "autoencoder", "to": "training"}, {"from": "autoencoder", "to": "erm"}, {"from": "autoencoder", "to": "loss"}, {"from": "autoencoder", "to": "featurevec"}, {"from": "autoencoder", "to": "featlearn"}, {"from": "autoencoder", "to": "dimred"}, {"from": "modelparallelism", "to": "model"}, {"from": "modelparallelism", "to": "optmethod"}, {"from": "modelparallelism", "to": "ml"}, {"from": "modelparallelism", "to": "device"}, {"from": "modelparallelism", "to": "modelparam"}, {"from": "modelparallelism", "to": "dataparallelism"}, {"from": "modelparallelism", "to": "dataset"}, {"from": "modelparallelism", "to": "parameter"}, {"from": "modelparallelism", "to": "ann"}, {"from": "modelparallelism", "to": "transformer"}, {"from": "modelparallelism", "to": "vfl"}, {"from": "dataparallelism", "to": "data"}, {"from": "dataparallelism", "to": "optmethod"}, {"from": "dataparallelism", "to": "ml"}, {"from": "dataparallelism", "to": "model"}, {"from": "dataparallelism", "to": "device"}, {"from": "dataparallelism", "to": "modelparam"}, {"from": "dataparallelism", "to": "dataset"}, {"from": "dataparallelism", "to": "modelparallelism"}, {"from": "dataparallelism", "to": "training"}, {"from": "dataparallelism", "to": "hfl"}, {"from": "perplexity", "to": "rv"}, {"from": "perplexity", "to": "entropy"}, {"from": "vfl", "to": "device"}, {"from": "vfl", "to": "feature"}, {"from": "vfl", "to": "datapoint"}, {"from": "vfl", "to": "dataset"}, {"from": "vfl", "to": "featurevec"}, {"from": "vfl", "to": "localdataset"}, {"from": "vfl", "to": "label"}, {"from": "vfl", "to": "data"}, {"from": "vfl", "to": "privprot"}, {"from": "vfl", "to": "modelparallelism"}, {"from": "vfl", "to": "fl"}, {"from": "interpretability", "to": "ml"}, {"from": "interpretability", "to": "model"}, {"from": "interpretability", "to": "prediction"}, {"from": "interpretability", "to": "testset"}, {"from": "interpretability", "to": "hypothesis"}, {"from": "interpretability", "to": "linearmap"}, {"from": "interpretability", "to": "expectation"}, {"from": "interpretability", "to": "trainset"}, {"from": "interpretability", "to": "label"}, {"from": "interpretability", "to": "explainability"}, {"from": "interpretability", "to": "explanation"}, {"from": "interpretability", "to": "map"}, {"from": "interpretability", "to": "trustAI"}, {"from": "interpretability", "to": "regularization"}, {"from": "interpretability", "to": "lime"}, {"from": "multitask learning", "to": "learningtask"}, {"from": "multitask learning", "to": "dataset"}, {"from": "multitask learning", "to": "deepnet"}, {"from": "multitask learning", "to": "weights"}, {"from": "multitask learning", "to": "layer"}, {"from": "learningtask", "to": "dataset"}, {"from": "learningtask", "to": "datapoint"}, {"from": "learningtask", "to": "feature"}, {"from": "learningtask", "to": "label"}, {"from": "learningtask", "to": "model"}, {"from": "learningtask", "to": "lossfunc"}, {"from": "learningtask", "to": "erm"}, {"from": "learningtask", "to": "objfunc"}, {"from": "learningtask", "to": "regression"}, {"from": "learningtask", "to": "classification"}, {"from": "learningtask", "to": "probmodel"}, {"from": "learningtask", "to": "multitask learning"}, {"from": "learningtask", "to": "labelspace"}, {"from": "explainability", "to": "ml"}, {"from": "explainability", "to": "prediction"}, {"from": "explainability", "to": "measure"}, {"from": "explainability", "to": "model"}, {"from": "explainability", "to": "testset"}, {"from": "explainability", "to": "probmodel"}, {"from": "explainability", "to": "data"}, {"from": "explainability", "to": "entropy"}, {"from": "explainability", "to": "trustAI"}, {"from": "explainability", "to": "regularization"}, {"from": "lime", "to": "model"}, {"from": "lime", "to": "hypothesis"}, {"from": "lime", "to": "featurevec"}, {"from": "lime", "to": "datapoint"}, {"from": "lime", "to": "prediction"}, {"from": "lime", "to": "explanation"}, {"from": "lime", "to": "erm"}, {"from": "lime", "to": "trainset"}, {"from": "lime", "to": "label"}, {"from": "lime", "to": "decisiontree"}, {"from": "lime", "to": "deepnet"}, {"from": "lime", "to": "linmodel"}, {"from": "linmodel", "to": "ml"}, {"from": "linmodel", "to": "datapoint"}, {"from": "linmodel", "to": "featurevec"}, {"from": "linmodel", "to": "model"}, {"from": "linmodel", "to": "hypospace"}, {"from": "linmodel", "to": "linearmap"}, {"from": "linmodel", "to": "feature"}, {"from": "linmodel", "to": "prediction"}, {"from": "linmodel", "to": "compasp"}, {"from": "linmodel", "to": "statasp"}, {"from": "linmodel", "to": "bias"}, {"from": "linmodel", "to": "risk"}, {"from": "linmodel", "to": "interpretability"}, {"from": "linmodel", "to": "convex"}, {"from": "linmodel", "to": "optmethod"}, {"from": "linmodel", "to": "minimum"}, {"from": "linmodel", "to": "ann"}, {"from": "linmodel", "to": "deepnet"}, {"from": "linmodel", "to": "featuremap"}, {"from": "linmodel", "to": "layer"}, {"from": "linmodel", "to": "output"}, {"from": "linmodel", "to": "decisiontree"}, {"from": "linmodel", "to": "decisionregion"}, {"from": "linmodel", "to": "differentiable"}, {"from": "linmodel", "to": "gradient"}, {"from": "linmodel", "to": "robustness"}, {"from": "linmodel", "to": "trustAI"}, {"from": "linmodel", "to": "map"}, {"from": "linmodel", "to": "continuous"}, {"from": "linmodel", "to": "lime"}, {"from": "operator", "to": "function"}, {"from": "operator", "to": "domain"}, {"from": "operator", "to": "co-domain"}, {"from": "operator", "to": "vectorspace"}, {"from": "operator", "to": "hilbertspace"}, {"from": "operator", "to": "metricspace"}, {"from": "operator", "to": "ml"}, {"from": "operator", "to": "euclidspace"}, {"from": "contractop", "to": "operator"}, {"from": "contractop", "to": "metricspace"}, {"from": "contractop", "to": "domain"}, {"from": "proxop", "to": "convex"}, {"from": "proxop", "to": "function"}, {"from": "proxop", "to": "operator"}, {"from": "proxop", "to": "penaltyterm"}, {"from": "proxop", "to": "eucliddist"}, {"from": "proxop", "to": "vector"}, {"from": "proxop", "to": "generalization"}, {"from": "proxop", "to": "gradstep"}, {"from": "proxop", "to": "smooth"}, {"from": "proxop", "to": "stepsize"}, {"from": "proximable", "to": "convex"}, {"from": "proximable", "to": "function"}, {"from": "proximable", "to": "proxop"}, {"from": "connected", "to": "undirectedgraph"}, {"from": "connected", "to": "graph"}, {"from": "connected", "to": "algconn"}, {"from": "earlystopping", "to": "erm"}, {"from": "earlystopping", "to": "optmethod"}, {"from": "earlystopping", "to": "gd"}, {"from": "earlystopping", "to": "modelparam"}, {"from": "earlystopping", "to": "emprisk"}, {"from": "earlystopping", "to": "trainset"}, {"from": "earlystopping", "to": "iteration"}, {"from": "earlystopping", "to": "objfunc"}, {"from": "earlystopping", "to": "valerr"}, {"from": "earlystopping", "to": "regularization"}, {"from": "earlystopping", "to": "model"}, {"from": "earlystopping", "to": "gdmethod"}, {"from": "earlystopping", "to": "hypospace"}, {"from": "earlystopping", "to": "sequence"}, {"from": "earlystopping", "to": "gradstep"}, {"from": "earlystopping", "to": "overfitting"}, {"from": "statasp", "to": "ml"}, {"from": "statasp", "to": "probdist"}, {"from": "statasp", "to": "probmodel"}, {"from": "statasp", "to": "data"}, {"from": "compasp", "to": "ml"}, {"from": "compasp", "to": "erm"}, {"from": "compasp", "to": "gradstep"}, {"from": "compasp", "to": "modelparam"}, {"from": "compasp", "to": "gd"}, {"from": "zerooneloss", "to": "loss"}, {"from": "zerooneloss", "to": "classifier"}, {"from": "zerooneloss", "to": "prediction"}, {"from": "zerooneloss", "to": "label"}, {"from": "zerooneloss", "to": "datapoint"}, {"from": "zerooneloss", "to": "feature"}, {"from": "zerooneloss", "to": "acc"}, {"from": "probability", "to": "event"}, {"from": "probability", "to": "randomexperiment"}, {"from": "underfitting", "to": "ml"}, {"from": "underfitting", "to": "erm"}, {"from": "underfitting", "to": "hypothesis"}, {"from": "underfitting", "to": "emprisk"}, {"from": "underfitting", "to": "trainset"}, {"from": "underfitting", "to": "model"}, {"from": "underfitting", "to": "feature"}, {"from": "underfitting", "to": "label"}, {"from": "underfitting", "to": "linmodel"}, {"from": "underfitting", "to": "data"}, {"from": "underfitting", "to": "loss"}, {"from": "underfitting", "to": "risk"}, {"from": "underfitting", "to": "overfitting"}, {"from": "overfitting", "to": "ml"}, {"from": "overfitting", "to": "erm"}, {"from": "overfitting", "to": "hypothesis"}, {"from": "overfitting", "to": "minimum"}, {"from": "overfitting", "to": "emprisk"}, {"from": "overfitting", "to": "trainset"}, {"from": "overfitting", "to": "loss"}, {"from": "overfitting", "to": "gengap"}, {"from": "overfitting", "to": "generalization"}, {"from": "overfitting", "to": "validation"}, {"from": "diffusionmethod", "to": "ml"}, {"from": "diffusionmethod", "to": "model"}, {"from": "diffusionmethod", "to": "map"}, {"from": "diffusionmethod", "to": "datapoint"}, {"from": "diffusionmethod", "to": "data"}, {"from": "diffusionmethod", "to": "denautoencoder"}, {"from": "diffusionmethod", "to": "prediction"}, {"from": "diffusionmethod", "to": "training"}, {"from": "denautoencoder", "to": "autoencoder"}, {"from": "denautoencoder", "to": "inputvec"}, {"from": "denautoencoder", "to": "featurevec"}, {"from": "denautoencoder", "to": "datapoint"}, {"from": "denautoencoder", "to": "prediction"}, {"from": "denautoencoder", "to": "diffusionmethod"}, {"from": "normaldist", "to": "gaussrv"}, {"from": "gaussrv", "to": "gaussian"}, {"from": "gaussrv", "to": "rv"}, {"from": "gaussrv", "to": "pdf"}, {"from": "gaussrv", "to": "mean"}, {"from": "gaussrv", "to": "variance"}, {"from": "gaussrv", "to": "probdist"}, {"from": "gaussrv", "to": "normaldist"}, {"from": "gaussrv", "to": "vector"}, {"from": "gaussrv", "to": "covmtx"}, {"from": "gaussrv", "to": "iid"}, {"from": "gaussrv", "to": "matrix"}, {"from": "gaussrv", "to": "mvndist"}, {"from": "gaussrv", "to": "stochproc"}, {"from": "gaussrv", "to": "GaussProc"}, {"from": "gaussrv", "to": "probmodel"}, {"from": "gaussrv", "to": "ml"}, {"from": "gaussrv", "to": "clt"}, {"from": "gaussrv", "to": "maximum"}, {"from": "gaussrv", "to": "uncertainty"}, {"from": "gaussrv", "to": "diffentropy"}, {"from": "gaussian", "to": "gaussrv"}, {"from": "clt", "to": "iid"}, {"from": "clt", "to": "rv"}, {"from": "clt", "to": "mean"}, {"from": "clt", "to": "variance"}, {"from": "clt", "to": "gaussrv"}, {"from": "clt", "to": "characteristicfunc"}, {"from": "clt", "to": "operator"}, {"from": "clt", "to": "fixedpointiter"}, {"from": "clt", "to": "convergence"}, {"from": "clt", "to": "generalization"}, {"from": "clt", "to": "gaussian"}, {"from": "GaussProc", "to": "rv"}, {"from": "GaussProc", "to": "mvndist"}, {"from": "GaussProc", "to": "mean"}, {"from": "GaussProc", "to": "function"}, {"from": "GaussProc", "to": "covariance"}, {"from": "GaussProc", "to": "realization"}, {"from": "GaussProc", "to": "fmi"}, {"from": "GaussProc", "to": "uncertainty"}, {"from": "GaussProc", "to": "prediction"}, {"from": "GaussProc", "to": "gaussrv"}, {"from": "trustAI", "to": "compasp"}, {"from": "trustAI", "to": "statasp"}, {"from": "trustAI", "to": "ml"}, {"from": "trustAI", "to": "ai"}, {"from": "trustAI", "to": "robustness"}, {"from": "trustAI", "to": "data"}, {"from": "trustAI", "to": "transparency"}, {"from": "sqerrloss", "to": "loss"}, {"from": "sqerrloss", "to": "prediction"}, {"from": "sqerrloss", "to": "hypothesis"}, {"from": "sqerrloss", "to": "label"}, {"from": "sqerrloss", "to": "feature"}, {"from": "sqerrloss", "to": "datapoint"}, {"from": "projection", "to": "euclidspace"}, {"from": "projection", "to": "vector"}, {"from": "projection", "to": "minimum"}, {"from": "projgd", "to": "erm"}, {"from": "projgd", "to": "model"}, {"from": "projgd", "to": "paramspace"}, {"from": "projgd", "to": "objfunc"}, {"from": "projgd", "to": "smooth"}, {"from": "projgd", "to": "gd"}, {"from": "projgd", "to": "modelparam"}, {"from": "projgd", "to": "gradstep"}, {"from": "projgd", "to": "projection"}, {"from": "diffpriv", "to": "ml"}, {"from": "diffpriv", "to": "dataset"}, {"from": "diffpriv", "to": "trainset"}, {"from": "diffpriv", "to": "erm"}, {"from": "diffpriv", "to": "output"}, {"from": "diffpriv", "to": "modelparam"}, {"from": "diffpriv", "to": "prediction"}, {"from": "diffpriv", "to": "datapoint"}, {"from": "diffpriv", "to": "measure"}, {"from": "diffpriv", "to": "privleakage"}, {"from": "diffpriv", "to": "probdist"}, {"from": "diffpriv", "to": "sensattr"}, {"from": "diffpriv", "to": "probmodel"}, {"from": "diffpriv", "to": "realization"}, {"from": "diffpriv", "to": "rv"}, {"from": "diffpriv", "to": "privattack"}, {"from": "diffpriv", "to": "privfunnel"}, {"from": "robustness", "to": "trustAI"}, {"from": "robustness", "to": "ml"}, {"from": "robustness", "to": "feature"}, {"from": "robustness", "to": "datapoint"}, {"from": "robustness", "to": "prediction"}, {"from": "robustness", "to": "model"}, {"from": "robustness", "to": "stability"}, {"from": "robustness", "to": "erm"}, {"from": "robustness", "to": "trainset"}, {"from": "robustness", "to": "datapoisoning"}, {"from": "robustness", "to": "attack"}, {"from": "stability", "to": "ml"}, {"from": "stability", "to": "map"}, {"from": "stability", "to": "dataset"}, {"from": "stability", "to": "output"}, {"from": "stability", "to": "erm"}, {"from": "stability", "to": "trainset"}, {"from": "stability", "to": "modelparam"}, {"from": "stability", "to": "minimum"}, {"from": "stability", "to": "loss"}, {"from": "stability", "to": "prediction"}, {"from": "stability", "to": "model"}, {"from": "stability", "to": "generalization"}, {"from": "stability", "to": "gengap"}, {"from": "stability", "to": "data"}, {"from": "stability", "to": "probdist"}, {"from": "stability", "to": "sample"}, {"from": "stability", "to": "realization"}, {"from": "stability", "to": "robustness"}, {"from": "privprot", "to": "ml"}, {"from": "privprot", "to": "dataset"}, {"from": "privprot", "to": "modelparam"}, {"from": "privprot", "to": "prediction"}, {"from": "privprot", "to": "datapoint"}, {"from": "privprot", "to": "feature"}, {"from": "privprot", "to": "label"}, {"from": "privprot", "to": "sensattr"}, {"from": "privprot", "to": "map"}, {"from": "privleakage", "to": "ml"}, {"from": "privleakage", "to": "dataset"}, {"from": "privleakage", "to": "prediction"}, {"from": "privleakage", "to": "datapoint"}, {"from": "privleakage", "to": "feature"}, {"from": "privleakage", "to": "probmodel"}, {"from": "privleakage", "to": "data"}, {"from": "privleakage", "to": "mutualinformation"}, {"from": "privleakage", "to": "measure"}, {"from": "privleakage", "to": "diffpriv"}, {"from": "privleakage", "to": "privattack"}, {"from": "privleakage", "to": "gdpr"}, {"from": "probmodel", "to": "model"}, {"from": "probmodel", "to": "datapoint"}, {"from": "probmodel", "to": "rv"}, {"from": "probmodel", "to": "probdist"}, {"from": "probmodel", "to": "parameter"}, {"from": "probmodel", "to": "maxlikelihood"}, {"from": "probmodel", "to": "realization"}, {"from": "probabilitysimplex", "to": "probability"}, {"from": "probabilitysimplex", "to": "vector"}, {"from": "probabilitysimplex", "to": "pmf"}, {"from": "probabilitysimplex", "to": "rv"}, {"from": "crossentropy", "to": "classification"}, {"from": "crossentropy", "to": "featurespace"}, {"from": "crossentropy", "to": "labelspace"}, {"from": "crossentropy", "to": "datapoint"}, {"from": "crossentropy", "to": "featurevec"}, {"from": "crossentropy", "to": "pmf"}, {"from": "crossentropy", "to": "probability"}, {"from": "crossentropy", "to": "label"}, {"from": "crossentropy", "to": "hypothesis"}, {"from": "crossentropy", "to": "loss"}, {"from": "crossentropy", "to": "measure"}, {"from": "crossentropy", "to": "logloss"}, {"from": "crossentropy", "to": "parammodel"}, {"from": "crossentropy", "to": "modelparam"}, {"from": "bce", "to": "loss"}, {"from": "bce", "to": "crossentropy"}, {"from": "bce", "to": "classification"}, {"from": "softlabel", "to": "classification"}, {"from": "softlabel", "to": "datapoint"}, {"from": "softlabel", "to": "feature"}, {"from": "softlabel", "to": "label"}, {"from": "softlabel", "to": "labelspace"}, {"from": "softlabel", "to": "ml"}, {"from": "softlabel", "to": "probdist"}, {"from": "softlabel", "to": "pmf"}, {"from": "softlabel", "to": "probability"}, {"from": "softlabel", "to": "featurevec"}, {"from": "softlabel", "to": "crossentropy"}, {"from": "mean", "to": "rv"}, {"from": "mean", "to": "euclidspace"}, {"from": "mean", "to": "expectation"}, {"from": "mean", "to": "probdist"}, {"from": "mean", "to": "dataset"}, {"from": "mean", "to": "samplespace"}, {"from": "mean", "to": "risk"}, {"from": "mean", "to": "optproblem"}, {"from": "mean", "to": "erm"}, {"from": "mean", "to": "sqerrloss"}, {"from": "median", "to": "rv"}, {"from": "median", "to": "probability"}, {"from": "median", "to": "dataset"}, {"from": "median", "to": "samplespace"}, {"from": "median", "to": "optproblem"}, {"from": "median", "to": "erm"}, {"from": "median", "to": "abserr"}, {"from": "median", "to": "mean"}, {"from": "median", "to": "parameter"}, {"from": "median", "to": "probmodel"}, {"from": "median", "to": "outlier"}, {"from": "median", "to": "datapoint"}, {"from": "median", "to": "robustness"}, {"from": "median", "to": "ladregression"}, {"from": "variance", "to": "rv"}, {"from": "variance", "to": "expectation"}, {"from": "variance", "to": "vector"}, {"from": "variance", "to": "trace"}, {"from": "variance", "to": "covmtx"}, {"from": "nn", "to": "hypothesis"}, {"from": "nn", "to": "function"}, {"from": "nn", "to": "dataset"}, {"from": "nn", "to": "metric"}, {"from": "nn", "to": "datapoint"}, {"from": "nn", "to": "featurevec"}, {"from": "nn", "to": "eucliddist"}, {"from": "nn", "to": "neighbor"}, {"from": "neighborhood", "to": "metricspace"}, {"from": "neighborhood", "to": "metric"}, {"from": "neighborhood", "to": "undirectedgraph"}, {"from": "neighborhood", "to": "neighbor"}, {"from": "neighbor", "to": "undirectedgraph"}, {"from": "neighbor", "to": "connected"}, {"from": "bias", "to": "erm"}, {"from": "bias", "to": "ml"}, {"from": "bias", "to": "hypothesis"}, {"from": "bias", "to": "trainset"}, {"from": "bias", "to": "probmodel"}, {"from": "bias", "to": "iidasspt"}, {"from": "bias", "to": "data"}, {"from": "bias", "to": "datapoint"}, {"from": "bias", "to": "realization"}, {"from": "bias", "to": "rv"}, {"from": "bias", "to": "modelparam"}, {"from": "bias", "to": "parammodel"}, {"from": "bias", "to": "prediction"}, {"from": "bias", "to": "featurevec"}, {"from": "bias", "to": "label"}, {"from": "bias", "to": "iid"}, {"from": "bias", "to": "esterr"}, {"from": "classification", "to": "label"}, {"from": "classification", "to": "datapoint"}, {"from": "classification", "to": "feature"}, {"from": "privfunnel", "to": "featuremap"}, {"from": "privfunnel", "to": "feature"}, {"from": "privfunnel", "to": "datapoint"}, {"from": "privfunnel", "to": "gdpr"}, {"from": "privfunnel", "to": "diffpriv"}, {"from": "condnr", "to": "matrix"}, {"from": "condnr", "to": "eigenvalue"}, {"from": "condnr", "to": "ml"}, {"from": "condnr", "to": "gdmethod"}, {"from": "condnr", "to": "linreg"}, {"from": "condnr", "to": "featuremtx"}, {"from": "condnr", "to": "trainset"}, {"from": "classifier", "to": "hypothesis"}, {"from": "classifier", "to": "map"}, {"from": "classifier", "to": "label"}, {"from": "classifier", "to": "labelspace"}, {"from": "classifier", "to": "function"}, {"from": "classifier", "to": "prediction"}, {"from": "classifier", "to": "classification"}, {"from": "classifier", "to": "decisionregion"}, {"from": "emprisk", "to": "risk"}, {"from": "emprisk", "to": "hypothesis"}, {"from": "emprisk", "to": "dataset"}, {"from": "emprisk", "to": "loss"}, {"from": "emprisk", "to": "datapoint"}, {"from": "nodedegree", "to": "undirectedgraph"}, {"from": "nodedegree", "to": "neighbor"}, {"from": "token", "to": "sequence"}, {"from": "token", "to": "nlp"}, {"from": "token", "to": "feature"}, {"from": "token", "to": "datapoint"}, {"from": "token", "to": "featurevec"}, {"from": "nlp", "to": "ml"}, {"from": "nlp", "to": "classification"}, {"from": "nlp", "to": "sequence"}, {"from": "nlp", "to": "token"}, {"from": "nlp", "to": "model"}, {"from": "nlp", "to": "attention"}, {"from": "riskstratification", "to": "stratification"}, {"from": "riskstratification", "to": "datapoint"}, {"from": "riskstratification", "to": "stratum"}, {"from": "riskstratification", "to": "prediction"}, {"from": "riskstratification", "to": "model"}, {"from": "riskstratification", "to": "clustering"}, {"from": "uncertainty", "to": "ml"}, {"from": "uncertainty", "to": "outcome"}, {"from": "uncertainty", "to": "explanation"}, {"from": "uncertainty", "to": "data"}, {"from": "uncertainty", "to": "prediction"}, {"from": "uncertainty", "to": "model"}, {"from": "uncertainty", "to": "label"}, {"from": "uncertainty", "to": "datapoint"}, {"from": "uncertainty", "to": "probability"}, {"from": "uncertainty", "to": "probmodel"}, {"from": "uncertainty", "to": "risk"}, {"from": "uncertainty", "to": "entropy"}, {"from": "uncertainty", "to": "variance"}, {"from": "ucb", "to": "ml"}, {"from": "ucb", "to": "reward"}, {"from": "ucb", "to": "probmodel"}, {"from": "ucb", "to": "stochastic"}, {"from": "ucb", "to": "mab"}, {"from": "ucb", "to": "model"}, {"from": "ucb", "to": "realization"}, {"from": "ucb", "to": "rv"}, {"from": "ucb", "to": "mean"}, {"from": "ucb", "to": "data"}, {"from": "ucb", "to": "outcome"}, {"from": "ucb", "to": "uncertainty"}, {"from": "ucb", "to": "regret"}, {"from": "ucb", "to": "optimism in the face of uncertainty"}, {"from": "optimism in the face of uncertainty", "to": "ml"}, {"from": "optimism in the face of uncertainty", "to": "modelparam"}, {"from": "optimism in the face of uncertainty", "to": "erm"}, {"from": "optimism in the face of uncertainty", "to": "loss"}, {"from": "optimism in the face of uncertainty", "to": "dataset"}, {"from": "optimism in the face of uncertainty", "to": "trainset"}, {"from": "optimism in the face of uncertainty", "to": "risk"}, {"from": "optimism in the face of uncertainty", "to": "hypothesis"}, {"from": "optimism in the face of uncertainty", "to": "probmodel"}, {"from": "optimism in the face of uncertainty", "to": "measure"}, {"from": "optimism in the face of uncertainty", "to": "probability"}, {"from": "optimism in the face of uncertainty", "to": "objfunc"}, {"from": "optimism in the face of uncertainty", "to": "srm"}, {"from": "optimism in the face of uncertainty", "to": "ucb"}, {"from": "optimism in the face of uncertainty", "to": "optmethod"}, {"from": "optimism in the face of uncertainty", "to": "gdmethod"}, {"from": "empgraph", "to": "fl"}, {"from": "empgraph", "to": "graph"}, {"from": "empgraph", "to": "device"}, {"from": "empgraph", "to": "localdataset"}, {"from": "empgraph", "to": "localmodel"}, {"from": "empgraph", "to": "gtvmin"}, {"from": "empgraph", "to": "modelparam"}, {"from": "empgraph", "to": "loss"}, {"from": "empgraph", "to": "discrepancy"}, {"from": "norm", "to": "function"}, {"from": "norm", "to": "vector"}, {"from": "norm", "to": "vectorspace"}, {"from": "dualnorm", "to": "norm"}, {"from": "dualnorm", "to": "euclidspace"}, {"from": "dualnorm", "to": "vector"}, {"from": "geometricmedian", "to": "inputvec"}, {"from": "geometricmedian", "to": "vector"}, {"from": "geometricmedian", "to": "subgradient"}, {"from": "explanation", "to": "transparency"}, {"from": "explanation", "to": "ml"}, {"from": "explanation", "to": "prediction"}, {"from": "explanation", "to": "feature"}, {"from": "explanation", "to": "datapoint"}, {"from": "explanation", "to": "map"}, {"from": "explanation", "to": "model"}, {"from": "explanation", "to": "featurevec"}, {"from": "explanation", "to": "lime"}, {"from": "explanation", "to": "differentiable"}, {"from": "explanation", "to": "gradient"}, {"from": "explanation", "to": "function"}, {"from": "explanation", "to": "classification"}, {"from": "risk", "to": "hypothesis"}, {"from": "risk", "to": "label"}, {"from": "risk", "to": "datapoint"}, {"from": "risk", "to": "feature"}, {"from": "risk", "to": "prediction"}, {"from": "risk", "to": "lossfunc"}, {"from": "risk", "to": "realization"}, {"from": "risk", "to": "iid"}, {"from": "risk", "to": "rv"}, {"from": "risk", "to": "iidasspt"}, {"from": "risk", "to": "loss"}, {"from": "risk", "to": "probdist"}, {"from": "actfun", "to": "ann"}, {"from": "actfun", "to": "activation"}, {"from": "actfun", "to": "function"}, {"from": "actfun", "to": "weights"}, {"from": "actfun", "to": "relu"}, {"from": "distributedalgorithm", "to": "algorithm"}, {"from": "distributedalgorithm", "to": "device"}, {"from": "distributedalgorithm", "to": "event"}, {"from": "distributedalgorithm", "to": "fl"}, {"from": "distributedalgorithm", "to": "model"}, {"from": "algorithm", "to": "output"}, {"from": "algorithm", "to": "gdmethod"}, {"from": "algorithm", "to": "linreg"}, {"from": "algorithm", "to": "trainset"}, {"from": "algorithm", "to": "modelparam"}, {"from": "algorithm", "to": "gradstep"}, {"from": "algorithm", "to": "inverse"}, {"from": "algorithm", "to": "normalequations"}, {"from": "algorithm", "to": "model"}, {"from": "algorithm", "to": "stochastic"}, {"from": "stochalgorithm", "to": "stochastic"}, {"from": "stochalgorithm", "to": "algorithm"}, {"from": "stochalgorithm", "to": "stochGD"}, {"from": "stochalgorithm", "to": "datapoint"}, {"from": "stochalgorithm", "to": "gradient"}, {"from": "stochalgorithm", "to": "objfunc"}, {"from": "stochalgorithm", "to": "stochproc"}, {"from": "stochalgorithm", "to": "outcome"}, {"from": "stochalgorithm", "to": "randomexperiment"}, {"from": "stochalgorithm", "to": "optmethod"}, {"from": "stochalgorithm", "to": "gdmethod"}, {"from": "batchlearning", "to": "batch"}, {"from": "batchlearning", "to": "ml"}, {"from": "batchlearning", "to": "model"}, {"from": "batchlearning", "to": "dataset"}, {"from": "batchlearning", "to": "data"}, {"from": "batchlearning", "to": "algorithm"}, {"from": "batchlearning", "to": "prediction"}, {"from": "batchlearning", "to": "onlinelearning"}, {"from": "onlinelearning", "to": "ml"}, {"from": "onlinelearning", "to": "data"}, {"from": "onlinelearning", "to": "modelparam"}, {"from": "onlinelearning", "to": "datapoint"}, {"from": "onlinelearning", "to": "minimum"}, {"from": "onlinelearning", "to": "maximum"}, {"from": "onlinelearning", "to": "fmi"}, {"from": "onlinelearning", "to": "hypothesis"}, {"from": "onlinelearning", "to": "onlineGD"}, {"from": "onlinelearning", "to": "onlinealgorithm"}, {"from": "onlinealgorithm", "to": "algorithm"}, {"from": "onlinealgorithm", "to": "data"}, {"from": "onlinealgorithm", "to": "datapoint"}, {"from": "onlinealgorithm", "to": "uncertainty"}, {"from": "onlinealgorithm", "to": "ml"}, {"from": "onlinealgorithm", "to": "onlineGD"}, {"from": "onlinealgorithm", "to": "modelparam"}, {"from": "onlinealgorithm", "to": "onlinelearning"}, {"from": "sensattr", "to": "ml"}, {"from": "sensattr", "to": "hypothesis"}, {"from": "sensattr", "to": "map"}, {"from": "sensattr", "to": "label"}, {"from": "sensattr", "to": "datapoint"}, {"from": "sensattr", "to": "feature"}, {"from": "sbm", "to": "model"}, {"from": "sbm", "to": "graph"}, {"from": "sbm", "to": "cluster"}, {"from": "sbm", "to": "probability"}, {"from": "sbm", "to": "label"}, {"from": "deepnet", "to": "ann"}, {"from": "deepnet", "to": "layer"}, {"from": "deepnet", "to": "ml"}, {"from": "deepnet", "to": "model"}, {"from": "deepnet", "to": "llm"}, {"from": "baseline", "to": "ml"}, {"from": "baseline", "to": "hypothesis"}, {"from": "baseline", "to": "model"}, {"from": "baseline", "to": "loss"}, {"from": "baseline", "to": "testset"}, {"from": "baseline", "to": "data"}, {"from": "baseline", "to": "probmodel"}, {"from": "baseline", "to": "minimum"}, {"from": "baseline", "to": "risk"}, {"from": "baseline", "to": "hypospace"}, {"from": "baseline", "to": "bayesrisk"}, {"from": "baseline", "to": "bayesestimator"}, {"from": "baseline", "to": "label"}, {"from": "baseline", "to": "datapoint"}, {"from": "baseline", "to": "feature"}, {"from": "baseline", "to": "lossfunc"}, {"from": "baseline", "to": "probdist"}, {"from": "baseline", "to": "mvndist"}, {"from": "baseline", "to": "sqerrloss"}, {"from": "baseline", "to": "mean"}, {"from": "baseline", "to": "variance"}, {"from": "kfoldcv", "to": "gengap"}, {"from": "kfoldcv", "to": "erm"}, {"from": "kfoldcv", "to": "ml"}, {"from": "kfoldcv", "to": "dataset"}, {"from": "kfoldcv", "to": "valset"}, {"from": "kfoldcv", "to": "trainset"}, {"from": "kfoldcv", "to": "model"}, {"from": "kfoldcv", "to": "validation"}, {"from": "kfoldcv", "to": "valerr"}, {"from": "spectrogram", "to": "gaussian"}, {"from": "spectrogram", "to": "classification"}, {"from": "spectrogram", "to": "deepnet"}, {"from": "graphclustering", "to": "graph"}, {"from": "graphclustering", "to": "clustering"}, {"from": "graphclustering", "to": "datapoint"}, {"from": "graphclustering", "to": "edgeweight"}, {"from": "specclustering", "to": "clustering"}, {"from": "specclustering", "to": "graphclustering"}, {"from": "specclustering", "to": "datapoint"}, {"from": "specclustering", "to": "graph"}, {"from": "specclustering", "to": "eigenvector"}, {"from": "specclustering", "to": "LapMat"}, {"from": "specclustering", "to": "featurevec"}, {"from": "specclustering", "to": "euclidspace"}, {"from": "specclustering", "to": "kmeans"}, {"from": "specclustering", "to": "softclustering"}, {"from": "specclustering", "to": "gmm"}, {"from": "specclustering", "to": "cluster"}, {"from": "specclustering", "to": "evd"}, {"from": "specclustering", "to": "scatterplot"}, {"from": "specclustering", "to": "eigenvalue"}, {"from": "flowbasedclustering", "to": "clustering"}, {"from": "flowbasedclustering", "to": "graph"}, {"from": "flowbasedclustering", "to": "kmeans"}, {"from": "flowbasedclustering", "to": "featurevec"}, {"from": "esterr", "to": "datapoint"}, {"from": "esterr", "to": "featurevec"}, {"from": "esterr", "to": "label"}, {"from": "esterr", "to": "hypothesis"}, {"from": "esterr", "to": "ml"}, {"from": "esterr", "to": "erm"}, {"from": "esterr", "to": "hypospace"}, {"from": "esterr", "to": "map"}, {"from": "esterr", "to": "modelparam"}, {"from": "dob", "to": "datapoint"}, {"from": "dob", "to": "cluster"}, {"from": "dob", "to": "softclustering"}, {"from": "dob", "to": "hardclustering"}, {"from": "msee", "to": "ml"}, {"from": "msee", "to": "modelparam"}, {"from": "msee", "to": "dataset"}, {"from": "msee", "to": "datapoint"}, {"from": "msee", "to": "iid"}, {"from": "msee", "to": "realization"}, {"from": "msee", "to": "rv"}, {"from": "msee", "to": "esterr"}, {"from": "msee", "to": "probdist"}, {"from": "msee", "to": "expectation"}, {"from": "msee", "to": "euclidnorm"}, {"from": "msee", "to": "probmodel"}, {"from": "msee", "to": "sqerrloss"}, {"from": "gtvmin", "to": "rerm"}, {"from": "gtvmin", "to": "gtv"}, {"from": "gtvmin", "to": "modelparam"}, {"from": "gtvmin", "to": "regularizer"}, {"from": "regression", "to": "prediction"}, {"from": "regression", "to": "label"}, {"from": "regression", "to": "feature"}, {"from": "regression", "to": "datapoint"}, {"from": "acc", "to": "datapoint"}, {"from": "acc", "to": "feature"}, {"from": "acc", "to": "label"}, {"from": "acc", "to": "labelspace"}, {"from": "acc", "to": "hypothesis"}, {"from": "acc", "to": "dataset"}, {"from": "acc", "to": "zerooneloss"}, {"from": "acc", "to": "loss"}, {"from": "acc", "to": "metric"}, {"from": "expert", "to": "ml"}, {"from": "expert", "to": "hypothesis"}, {"from": "expert", "to": "label"}, {"from": "expert", "to": "datapoint"}, {"from": "expert", "to": "feature"}, {"from": "expert", "to": "prediction"}, {"from": "expert", "to": "lossfunc"}, {"from": "expert", "to": "loss"}, {"from": "expert", "to": "iidasspt"}, {"from": "expert", "to": "bayesrisk"}, {"from": "expert", "to": "baseline"}, {"from": "expert", "to": "regret"}, {"from": "nfl", "to": "model"}, {"from": "nfl", "to": "localdataset"}, {"from": "nfl", "to": "fl"}, {"from": "fedprox", "to": "fl"}, {"from": "fedprox", "to": "algorithm"}, {"from": "fedprox", "to": "localmodel"}, {"from": "fedprox", "to": "modelparam"}, {"from": "fedprox", "to": "fedavg"}, {"from": "fedprox", "to": "stochGD"}, {"from": "fedprox", "to": "proxop"}, {"from": "relu", "to": "actfun"}, {"from": "relu", "to": "ann"}, {"from": "hypothesis", "to": "map"}, {"from": "hypothesis", "to": "function"}, {"from": "hypothesis", "to": "featurespace"}, {"from": "hypothesis", "to": "labelspace"}, {"from": "hypothesis", "to": "datapoint"}, {"from": "hypothesis", "to": "feature"}, {"from": "hypothesis", "to": "label"}, {"from": "hypothesis", "to": "prediction"}, {"from": "hypothesis", "to": "ml"}, {"from": "hypothesis", "to": "hypospace"}, {"from": "hypothesis", "to": "model"}, {"from": "effdim", "to": "dimension"}, {"from": "effdim", "to": "hypospace"}, {"from": "effdim", "to": "measure"}, {"from": "effdim", "to": "modelparam"}, {"from": "effdim", "to": "parameter"}, {"from": "effdim", "to": "linearmap"}, {"from": "effdim", "to": "weights"}, {"from": "effdim", "to": "bias"}, {"from": "effdim", "to": "ann"}, {"from": "labelspace", "to": "ml"}, {"from": "labelspace", "to": "datapoint"}, {"from": "labelspace", "to": "feature"}, {"from": "labelspace", "to": "label"}, {"from": "labelspace", "to": "regression"}, {"from": "labelspace", "to": "classification"}, {"from": "prediction", "to": "ml"}, {"from": "prediction", "to": "hypothesis"}, {"from": "prediction", "to": "map"}, {"from": "prediction", "to": "feature"}, {"from": "prediction", "to": "datapoint"}, {"from": "prediction", "to": "label"}, {"from": "empiricaldistribution", "to": "dataset"}, {"from": "empiricaldistribution", "to": "datapoint"}, {"from": "empiricaldistribution", "to": "featurevec"}, {"from": "empiricaldistribution", "to": "sigmaalgebra"}, {"from": "empiricaldistribution", "to": "featurespace"}, {"from": "empiricaldistribution", "to": "probdist"}, {"from": "empiricaldistribution", "to": "event"}, {"from": "empiricaldistribution", "to": "measurable"}, {"from": "empiricaldistribution", "to": "cdf"}, {"from": "empiricaldistribution", "to": "pmf"}, {"from": "empiricaldistribution", "to": "feature"}, {"from": "histogram", "to": "dataset"}, {"from": "histogram", "to": "datapoint"}, {"from": "histogram", "to": "sample"}, {"from": "bootstrap", "to": "ml"}, {"from": "bootstrap", "to": "dataset"}, {"from": "bootstrap", "to": "realization"}, {"from": "bootstrap", "to": "iid"}, {"from": "bootstrap", "to": "rv"}, {"from": "bootstrap", "to": "probdist"}, {"from": "bootstrap", "to": "empiricaldistribution"}, {"from": "bootstrap", "to": "datapoint"}, {"from": "bootstrap", "to": "model"}, {"from": "bootstrap", "to": "training"}, {"from": "bootstrap", "to": "erm"}, {"from": "bootstrap", "to": "hypothesis"}, {"from": "bootstrap", "to": "bias"}, {"from": "bootstrap", "to": "variance"}, {"from": "bootstrap", "to": "gengap"}, {"from": "bootstrap", "to": "histogram"}, {"from": "featurespace", "to": "feature"}, {"from": "featurespace", "to": "ml"}, {"from": "featurespace", "to": "featurevec"}, {"from": "featurespace", "to": "datapoint"}, {"from": "featurespace", "to": "euclidspace"}, {"from": "featurespace", "to": "featlearn"}, {"from": "featurespace", "to": "convex"}, {"from": "featurespace", "to": "graph"}, {"from": "missingdata", "to": "dataset"}, {"from": "missingdata", "to": "datapoint"}, {"from": "missingdata", "to": "device"}, {"from": "missingdata", "to": "feature"}, {"from": "missingdata", "to": "label"}, {"from": "missingdata", "to": "data"}, {"from": "missingdata", "to": "ml"}, {"from": "dataimputation", "to": "missingdata"}, {"from": "feature", "to": "datapoint"}, {"from": "featurevec", "to": "feature"}, {"from": "featurevec", "to": "vector"}, {"from": "featurevec", "to": "ml"}, {"from": "featurevec", "to": "euclidspace"}, {"from": "featurevec", "to": "vectorspace"}, {"from": "featurevec", "to": "kernelmethod"}, {"from": "label", "to": "datapoint"}, {"from": "label", "to": "labelspace"}, {"from": "data", "to": "ml"}, {"from": "data", "to": "dataset"}, {"from": "data", "to": "datapoint"}, {"from": "data", "to": "sample"}, {"from": "dataset", "to": "datapoint"}, {"from": "dataset", "to": "ml"}, {"from": "dataset", "to": "sample"}, {"from": "dataset", "to": "model"}, {"from": "dataset", "to": "training"}, {"from": "dataset", "to": "validation"}, {"from": "dataset", "to": "data"}, {"from": "dataset", "to": "feature"}, {"from": "dataset", "to": "label"}, {"from": "dataset", "to": "featurespace"}, {"from": "dataset", "to": "labelspace"}, {"from": "dataset", "to": "trustAI"}, {"from": "predictor", "to": "hypothesis"}, {"from": "predictor", "to": "map"}, {"from": "predictor", "to": "datapoint"}, {"from": "predictor", "to": "feature"}, {"from": "predictor", "to": "prediction"}, {"from": "predictor", "to": "label"}, {"from": "labeled datapoint", "to": "datapoint"}, {"from": "labeled datapoint", "to": "label"}, {"from": "samplespace", "to": "sample"}, {"from": "samplespace", "to": "outcome"}, {"from": "samplespace", "to": "randomexperiment"}, {"from": "samplespace", "to": "probspace"}, {"from": "realization", "to": "rv"}, {"from": "realization", "to": "outcome"}, {"from": "realization", "to": "probspace"}, {"from": "realization", "to": "measurable"}, {"from": "trainset", "to": "dataset"}, {"from": "trainset", "to": "datapoint"}, {"from": "trainset", "to": "erm"}, {"from": "trainset", "to": "hypothesis"}, {"from": "trainset", "to": "loss"}, {"from": "trainset", "to": "trainerr"}, {"from": "trainset", "to": "valerr"}, {"from": "trainset", "to": "ml"}, {"from": "trainset", "to": "hypospace"}, {"from": "netmodel", "to": "model"}, {"from": "netmodel", "to": "empgraph"}, {"from": "netmodel", "to": "localmodel"}, {"from": "netmodel", "to": "hypospace"}, {"from": "batch", "to": "stochGD"}, {"from": "batch", "to": "trainset"}, {"from": "batch", "to": "datapoint"}, {"from": "batch", "to": "gradient"}, {"from": "batch", "to": "trainerr"}, {"from": "batch", "to": "modelparam"}, {"from": "epoch", "to": "trainset"}, {"from": "epoch", "to": "algorithm"}, {"from": "epoch", "to": "model"}, {"from": "epoch", "to": "datapoint"}, {"from": "epoch", "to": "parameter"}, {"from": "epoch", "to": "prediction"}, {"from": "epoch", "to": "data"}, {"from": "epoch", "to": "underfitting"}, {"from": "epoch", "to": "overfitting"}, {"from": "netdata", "to": "data"}, {"from": "netdata", "to": "localdataset"}, {"from": "netdata", "to": "graph"}, {"from": "netdata", "to": "fl"}, {"from": "netdata", "to": "device"}, {"from": "trainerr", "to": "loss"}, {"from": "trainerr", "to": "hypothesis"}, {"from": "trainerr", "to": "label"}, {"from": "trainerr", "to": "datapoint"}, {"from": "trainerr", "to": "trainset"}, {"from": "trainerr", "to": "erm"}, {"from": "datapoint", "to": "data"}, {"from": "datapoint", "to": "rv"}, {"from": "datapoint", "to": "feature"}, {"from": "datapoint", "to": "measurable"}, {"from": "datapoint", "to": "label"}, {"from": "datapoint", "to": "ml"}, {"from": "datapoint", "to": "dataset"}, {"from": "valerr", "to": "hypothesis"}, {"from": "valerr", "to": "ml"}, {"from": "valerr", "to": "erm"}, {"from": "valerr", "to": "trainset"}, {"from": "valerr", "to": "loss"}, {"from": "valerr", "to": "valset"}, {"from": "valerr", "to": "validation"}, {"from": "validation", "to": "hypothesis"}, {"from": "validation", "to": "ml"}, {"from": "validation", "to": "erm"}, {"from": "validation", "to": "trainset"}, {"from": "validation", "to": "valset"}, {"from": "validation", "to": "datapoint"}, {"from": "validation", "to": "loss"}, {"from": "validation", "to": "valerr"}, {"from": "validation", "to": "overfitting"}, {"from": "validation", "to": "generalization"}, {"from": "quadfunc", "to": "function"}, {"from": "quadfunc", "to": "matrix"}, {"from": "quadfunc", "to": "vector"}, {"from": "valset", "to": "datapoint"}, {"from": "valset", "to": "risk"}, {"from": "valset", "to": "hypothesis"}, {"from": "valset", "to": "ml"}, {"from": "valset", "to": "erm"}, {"from": "valset", "to": "loss"}, {"from": "valset", "to": "validation"}, {"from": "valset", "to": "valerr"}, {"from": "valset", "to": "trainerr"}, {"from": "valset", "to": "hypospace"}, {"from": "testset", "to": "datapoint"}, {"from": "testset", "to": "model"}, {"from": "testset", "to": "erm"}, {"from": "testset", "to": "valset"}, {"from": "modelsel", "to": "ml"}, {"from": "modelsel", "to": "model"}, {"from": "modelsel", "to": "valerr"}, {"from": "linclass", "to": "datapoint"}, {"from": "linclass", "to": "feature"}, {"from": "linclass", "to": "label"}, {"from": "linclass", "to": "labelspace"}, {"from": "linclass", "to": "classifier"}, {"from": "linclass", "to": "decisionregion"}, {"from": "erm", "to": "optproblem"}, {"from": "erm", "to": "hypothesis"}, {"from": "erm", "to": "loss"}, {"from": "erm", "to": "emprisk"}, {"from": "erm", "to": "trainset"}, {"from": "erm", "to": "hypospace"}, {"from": "erm", "to": "model"}, {"from": "erm", "to": "dataset"}, {"from": "erm", "to": "ml"}, {"from": "erm", "to": "linmodel"}, {"from": "erm", "to": "datapoint"}, {"from": "erm", "to": "feature"}, {"from": "erm", "to": "label"}, {"from": "erm", "to": "linearmap"}, {"from": "erm", "to": "function"}, {"from": "erm", "to": "modelparam"}, {"from": "erm", "to": "optmethod"}, {"from": "sampleweighting", "to": "erm"}, {"from": "sampleweighting", "to": "hypothesis"}, {"from": "sampleweighting", "to": "loss"}, {"from": "sampleweighting", "to": "trainset"}, {"from": "sampleweighting", "to": "datapoint"}, {"from": "sampleweighting", "to": "prediction"}, {"from": "sampleweighting", "to": "outlier"}, {"from": "sampleweighting", "to": "emprisk"}, {"from": "sampleweighting", "to": "adaboost"}, {"from": "multilabelclass", "to": "label"}, {"from": "multilabelclass", "to": "classification"}, {"from": "multilabelclass", "to": "datapoint"}, {"from": "training", "to": "ml"}, {"from": "training", "to": "hypothesis"}, {"from": "training", "to": "model"}, {"from": "training", "to": "loss"}, {"from": "training", "to": "datapoint"}, {"from": "training", "to": "trainset"}, {"from": "training", "to": "parammodel"}, {"from": "training", "to": "modelparam"}, {"from": "training", "to": "erm"}, {"from": "ssl", "to": "datapoint"}, {"from": "ssl", "to": "hypothesis"}, {"from": "ssl", "to": "labeled datapoint"}, {"from": "ssl", "to": "ml"}, {"from": "objfunc", "to": "function"}, {"from": "objfunc", "to": "map"}, {"from": "objfunc", "to": "ml"}, {"from": "objfunc", "to": "modelparam"}, {"from": "objfunc", "to": "hypothesis"}, {"from": "objfunc", "to": "risk"}, {"from": "objfunc", "to": "loss"}, {"from": "objfunc", "to": "emprisk"}, {"from": "objfunc", "to": "trainset"}, {"from": "objfunc", "to": "gdmethod"}, {"from": "objfunc", "to": "minimum"}, {"from": "objfunc", "to": "maximum"}, {"from": "objfunc", "to": "model"}, {"from": "objfunc", "to": "erm"}, {"from": "objfunc", "to": "optproblem"}, {"from": "regularizer", "to": "hypothesis"}, {"from": "regularizer", "to": "hypospace"}, {"from": "regularizer", "to": "measure"}, {"from": "regularizer", "to": "prediction"}, {"from": "regularizer", "to": "datapoint"}, {"from": "regularizer", "to": "trainset"}, {"from": "regularizer", "to": "ridgeregression"}, {"from": "regularizer", "to": "map"}, {"from": "regularizer", "to": "lasso"}, {"from": "regularizer", "to": "loss"}, {"from": "regularizer", "to": "objfunc"}, {"from": "regularization", "to": "ml"}, {"from": "regularization", "to": "model"}, {"from": "regularization", "to": "effdim"}, {"from": "regularization", "to": "erm"}, {"from": "regularization", "to": "overfitting"}, {"from": "regularization", "to": "hypothesis"}, {"from": "regularization", "to": "trainset"}, {"from": "regularization", "to": "parammodel"}, {"from": "regularization", "to": "modelparam"}, {"from": "regularization", "to": "feature"}, {"from": "regularization", "to": "linreg"}, {"from": "regularization", "to": "loss"}, {"from": "regularization", "to": "objfunc"}, {"from": "regularization", "to": "penaltyterm"}, {"from": "regularization", "to": "trainerr"}, {"from": "regularization", "to": "risk"}, {"from": "regularization", "to": "dataaug"}, {"from": "regularization", "to": "datapoint"}, {"from": "regularization", "to": "realization"}, {"from": "regularization", "to": "rv"}, {"from": "regularization", "to": "featurevec"}, {"from": "regularization", "to": "gaussrv"}, {"from": "regularization", "to": "ridgeregression"}, {"from": "regularization", "to": "label"}, {"from": "regularization", "to": "validation"}, {"from": "regularization", "to": "lasso"}, {"from": "regularization", "to": "modelsel"}, {"from": "rerm", "to": "erm"}, {"from": "rerm", "to": "hypothesis"}, {"from": "rerm", "to": "model"}, {"from": "rerm", "to": "emprisk"}, {"from": "rerm", "to": "trainset"}, {"from": "rerm", "to": "overfitting"}, {"from": "rerm", "to": "regularization"}, {"from": "rerm", "to": "regularizer"}, {"from": "rerm", "to": "parameter"}, {"from": "rerm", "to": "objfunc"}, {"from": "rerm", "to": "loss"}, {"from": "rerm", "to": "label"}, {"from": "rerm", "to": "datapoint"}, {"from": "rerm", "to": "linmodel"}, {"from": "rerm", "to": "sqerrloss"}, {"from": "rerm", "to": "gaussrv"}, {"from": "rerm", "to": "featurevec"}, {"from": "rerm", "to": "generalization"}, {"from": "rerm", "to": "srm"}, {"from": "generalization", "to": "model"}, {"from": "generalization", "to": "trainset"}, {"from": "generalization", "to": "prediction"}, {"from": "generalization", "to": "datapoint"}, {"from": "generalization", "to": "ml"}, {"from": "generalization", "to": "ai"}, {"from": "generalization", "to": "erm"}, {"from": "generalization", "to": "hypothesis"}, {"from": "generalization", "to": "loss"}, {"from": "generalization", "to": "data"}, {"from": "generalization", "to": "probmodel"}, {"from": "generalization", "to": "iidasspt"}, {"from": "generalization", "to": "rv"}, {"from": "generalization", "to": "probdist"}, {"from": "generalization", "to": "risk"}, {"from": "generalization", "to": "emprisk"}, {"from": "generalization", "to": "gengap"}, {"from": "generalization", "to": "probability"}, {"from": "generalization", "to": "concentrationinequ"}, {"from": "generalization", "to": "convergence"}, {"from": "generalization", "to": "feature"}, {"from": "generalization", "to": "overfitting"}, {"from": "generalization", "to": "validation"}, {"from": "gengap", "to": "generalization"}, {"from": "gengap", "to": "hypothesis"}, {"from": "gengap", "to": "trainset"}, {"from": "gengap", "to": "datapoint"}, {"from": "gengap", "to": "probmodel"}, {"from": "gengap", "to": "risk"}, {"from": "gengap", "to": "loss"}, {"from": "gengap", "to": "emprisk"}, {"from": "gengap", "to": "probdist"}, {"from": "gengap", "to": "expectation"}, {"from": "gengap", "to": "validation"}, {"from": "gengap", "to": "valset"}, {"from": "gengap", "to": "erm"}, {"from": "gengap", "to": "lossfunc"}, {"from": "concentrationinequ", "to": "probability"}, {"from": "concentrationinequ", "to": "rv"}, {"from": "concentrationinequ", "to": "expectation"}, {"from": "lda", "to": "featlearn"}, {"from": "lda", "to": "classification"}, {"from": "lda", "to": "featuremap"}, {"from": "lda", "to": "feature"}, {"from": "lda", "to": "label"}, {"from": "lda", "to": "datapoint"}, {"from": "lda", "to": "dimred"}, {"from": "lda", "to": "selfsupervisedlearning"}, {"from": "randomprojection", "to": "projection"}, {"from": "randomprojection", "to": "matrix"}, {"from": "randomprojection", "to": "featurevec"}, {"from": "randomprojection", "to": "featlearn"}, {"from": "randomprojection", "to": "dimred"}, {"from": "randomprojection", "to": "iid"}, {"from": "randomprojection", "to": "rv"}, {"from": "randomprojection", "to": "probdist"}, {"from": "randomprojection", "to": "eucliddist"}, {"from": "randomprojection", "to": "dataset"}, {"from": "randomprojection", "to": "johnsonlindenstrausslemma"}, {"from": "randomprojection", "to": "map"}, {"from": "randomprojection", "to": "probability"}, {"from": "boosting", "to": "optmethod"}, {"from": "boosting", "to": "hypothesis"}, {"from": "boosting", "to": "map"}, {"from": "boosting", "to": "baselearner"}, {"from": "boosting", "to": "generalization"}, {"from": "boosting", "to": "gdmethod"}, {"from": "boosting", "to": "erm"}, {"from": "boosting", "to": "parammodel"}, {"from": "boosting", "to": "smooth"}, {"from": "boosting", "to": "lossfunc"}, {"from": "boosting", "to": "sequence"}, {"from": "boosting", "to": "gradstep"}, {"from": "boosting", "to": "learnrate"}, {"from": "boosting", "to": "gradient"}, {"from": "boosting", "to": "output"}, {"from": "boosting", "to": "ensemble"}, {"from": "boosting", "to": "adaboost"}, {"from": "boosting", "to": "gradientboosting"}, {"from": "mse", "to": "hypothesis"}, {"from": "mse", "to": "sqerrloss"}, {"from": "mse", "to": "dataset"}, {"from": "mse", "to": "risk"}, {"from": "mae", "to": "hypothesis"}, {"from": "mae", "to": "abserr"}, {"from": "mae", "to": "dataset"}, {"from": "mae", "to": "risk"}, {"from": "adaboost", "to": "boosting"}, {"from": "adaboost", "to": "algorithm"}, {"from": "adaboost", "to": "baselearner"}, {"from": "adaboost", "to": "prediction"}, {"from": "adaboost", "to": "sampleweighting"}, {"from": "adaboost", "to": "hypothesis"}, {"from": "adaboost", "to": "erm"}, {"from": "adaboost", "to": "sample"}, {"from": "adaboost", "to": "weights"}, {"from": "adaboost", "to": "datapoint"}, {"from": "adaboost", "to": "loss"}, {"from": "adaboost", "to": "iteration"}, {"from": "adaboost", "to": "gradstep"}, {"from": "adaboost", "to": "learnrate"}, {"from": "derivative", "to": "partialderivative"}, {"from": "partialderivative", "to": "function"}, {"from": "partialderivative", "to": "derivative"}, {"from": "partialderivative", "to": "differentiable"}, {"from": "partialderivative", "to": "gradient"}, {"from": "gradientboosting", "to": "gradient"}, {"from": "gradientboosting", "to": "boosting"}, {"from": "gradientboosting", "to": "algorithm"}, {"from": "gradientboosting", "to": "hypothesis"}, {"from": "gradientboosting", "to": "adaboost"}, {"from": "gradientboosting", "to": "gradstep"}, {"from": "gradientboosting", "to": "baselearner"}, {"from": "gradientboosting", "to": "erm"}, {"from": "gradientboosting", "to": "trainset"}, {"from": "gradientboosting", "to": "featurevec"}, {"from": "gradientboosting", "to": "label"}, {"from": "gradientboosting", "to": "partialderivative"}, {"from": "gradientboosting", "to": "lossfunc"}, {"from": "gradientboosting", "to": "prediction"}, {"from": "gradientboosting", "to": "gd"}, {"from": "gtv", "to": "measure"}, {"from": "gtv", "to": "localmodel"}, {"from": "gtv", "to": "modelparam"}, {"from": "gtv", "to": "graph"}, {"from": "gtv", "to": "discrepancy"}, {"from": "gtv", "to": "hypothesis"}, {"from": "gtv", "to": "map"}, {"from": "srm", "to": "rerm"}, {"from": "srm", "to": "model"}, {"from": "srm", "to": "countable"}, {"from": "srm", "to": "generalization"}, {"from": "srm", "to": "erm"}, {"from": "srm", "to": "regularizer"}, {"from": "srm", "to": "risk"}, {"from": "rlm", "to": "rerm"}, {"from": "datapoisoning", "to": "data"}, {"from": "datapoisoning", "to": "datapoint"}, {"from": "datapoisoning", "to": "ml"}, {"from": "datapoisoning", "to": "model"}, {"from": "datapoisoning", "to": "attack"}, {"from": "datapoisoning", "to": "backdoor"}, {"from": "datapoisoning", "to": "dosattack"}, {"from": "datapoisoning", "to": "featurevec"}, {"from": "datapoisoning", "to": "fl"}, {"from": "datapoisoning", "to": "trustAI"}, {"from": "backdoor", "to": "ml"}, {"from": "backdoor", "to": "training"}, {"from": "backdoor", "to": "trainset"}, {"from": "backdoor", "to": "datapoisoning"}, {"from": "backdoor", "to": "optmethod"}, {"from": "backdoor", "to": "erm"}, {"from": "backdoor", "to": "hypothesis"}, {"from": "backdoor", "to": "prediction"}, {"from": "backdoor", "to": "featurespace"}, {"from": "backdoor", "to": "featurevec"}, {"from": "backdoor", "to": "attack"}, {"from": "clustasspt", "to": "clustering"}, {"from": "clustasspt", "to": "datapoint"}, {"from": "clustasspt", "to": "dataset"}, {"from": "clustasspt", "to": "cluster"}, {"from": "dosattack", "to": "attack"}, {"from": "dosattack", "to": "datapoisoning"}, {"from": "dosattack", "to": "model"}, {"from": "dosattack", "to": "datapoint"}, {"from": "netexpfam", "to": "empgraph"}, {"from": "netexpfam", "to": "modelparam"}, {"from": "netexpfam", "to": "gtv"}, {"from": "scatterplot", "to": "datapoint"}, {"from": "scatterplot", "to": "minimum"}, {"from": "scatterplot", "to": "feature"}, {"from": "scatterplot", "to": "maximum"}, {"from": "scatterplot", "to": "label"}, {"from": "scatterplot", "to": "fmi"}, {"from": "scatterplot", "to": "featurevec"}, {"from": "scatterplot", "to": "dimred"}, {"from": "stepsize", "to": "learnrate"}, {"from": "learnrate", "to": "ml"}, {"from": "learnrate", "to": "hypothesis"}, {"from": "learnrate", "to": "parameter"}, {"from": "learnrate", "to": "gradstep"}, {"from": "learnrate", "to": "gdmethod"}, {"from": "learnrate", "to": "erm"}, {"from": "learnrate", "to": "objfunc"}, {"from": "learnrate", "to": "emprisk"}, {"from": "learnrate", "to": "trainset"}, {"from": "learnrate", "to": "modelparam"}, {"from": "learnrate", "to": "gradient"}, {"from": "learnrate", "to": "gd"}, {"from": "learnrate", "to": "stochGD"}, {"from": "learnrate", "to": "projgd"}, {"from": "learnrate", "to": "stepsize"}, {"from": "featuremap", "to": "feature"}, {"from": "featuremap", "to": "map"}, {"from": "featuremap", "to": "function"}, {"from": "featuremap", "to": "featurevec"}, {"from": "featuremap", "to": "datapoint"}, {"from": "featuremap", "to": "linmodel"}, {"from": "featuremap", "to": "kernelmethod"}, {"from": "featuremap", "to": "overfitting"}, {"from": "featuremap", "to": "interpretability"}, {"from": "featuremap", "to": "data"}, {"from": "featuremap", "to": "scatterplot"}, {"from": "featuremap", "to": "ml"}, {"from": "featuremap", "to": "parameter"}, {"from": "featuremap", "to": "layer"}, {"from": "featuremap", "to": "deepnet"}, {"from": "featuremap", "to": "erm"}, {"from": "featuremap", "to": "lossfunc"}, {"from": "featuremap", "to": "featlearn"}, {"from": "featuremap", "to": "pca"}, {"from": "lasso", "to": "srm"}, {"from": "lasso", "to": "weights"}, {"from": "lasso", "to": "linearmap"}, {"from": "lasso", "to": "trainset"}, {"from": "lasso", "to": "linreg"}, {"from": "lasso", "to": "norm"}, {"from": "lasso", "to": "sqerrloss"}, {"from": "simgraph", "to": "ml"}, {"from": "simgraph", "to": "datapoint"}, {"from": "simgraph", "to": "graph"}, {"from": "kld", "to": "measure"}, {"from": "kld", "to": "probdist"}, {"from": "LapMat", "to": "graph"}, {"from": "LapMat", "to": "matrix"}, {"from": "LapMat", "to": "edgeweight"}, {"from": "algconn", "to": "undirectedgraph"}, {"from": "algconn", "to": "eigenvalue"}, {"from": "algconn", "to": "LapMat"}, {"from": "algconn", "to": "connected"}, {"from": "algconn", "to": "graph"}, {"from": "cfwmaxmin", "to": "psd"}, {"from": "cfwmaxmin", "to": "matrix"}, {"from": "cfwmaxmin", "to": "evd"}, {"from": "cfwmaxmin", "to": "eigenvalue"}, {"from": "cfwmaxmin", "to": "optproblem"}, {"from": "kernel", "to": "datapoint"}, {"from": "kernel", "to": "featurevec"}, {"from": "kernel", "to": "featurespace"}, {"from": "kernel", "to": "function"}, {"from": "kernel", "to": "measure"}, {"from": "kernel", "to": "matrix"}, {"from": "kernel", "to": "psd"}, {"from": "kernel", "to": "hilbertspace"}, {"from": "kernel", "to": "vectorspace"}, {"from": "kernel", "to": "kernelmethod"}, {"from": "kernelmethod", "to": "kernel"}, {"from": "kernelmethod", "to": "ml"}, {"from": "kernelmethod", "to": "featurevec"}, {"from": "kernelmethod", "to": "datapoint"}, {"from": "kernelmethod", "to": "featurespace"}, {"from": "kernelmethod", "to": "classification"}, {"from": "kernelmethod", "to": "linmodel"}, {"from": "kernelmethod", "to": "label"}, {"from": "kernelmethod", "to": "decisionboundary"}, {"from": "kernelmethod", "to": "linclass"}, {"from": "cm", "to": "dataset"}, {"from": "cm", "to": "datapoint"}, {"from": "cm", "to": "featurevec"}, {"from": "cm", "to": "label"}, {"from": "cm", "to": "labelspace"}, {"from": "cm", "to": "hypothesis"}, {"from": "cm", "to": "matrix"}, {"from": "cm", "to": "prediction"}, {"from": "cm", "to": "classification"}, {"from": "transferlearning", "to": "learningtask"}, {"from": "transferlearning", "to": "multitask learning"}, {"from": "featuremtx", "to": "dataset"}, {"from": "featuremtx", "to": "datapoint"}, {"from": "featuremtx", "to": "featurevec"}, {"from": "featuremtx", "to": "feature"}, {"from": "featuremtx", "to": "matrix"}, {"from": "kmeans++", "to": "kmeans"}, {"from": "dbscan", "to": "clustering"}, {"from": "dbscan", "to": "algorithm"}, {"from": "dbscan", "to": "datapoint"}, {"from": "dbscan", "to": "featurevec"}, {"from": "dbscan", "to": "kmeans"}, {"from": "dbscan", "to": "softclustering"}, {"from": "dbscan", "to": "gmm"}, {"from": "dbscan", "to": "eucliddist"}, {"from": "dbscan", "to": "cluster"}, {"from": "dbscan", "to": "graph"}, {"from": "fl", "to": "ml"}, {"from": "fl", "to": "model"}, {"from": "fl", "to": "data"}, {"from": "cfl", "to": "localmodel"}, {"from": "cfl", "to": "device"}, {"from": "cfl", "to": "fl"}, {"from": "cfl", "to": "clustasspt"}, {"from": "cfl", "to": "empgraph"}, {"from": "cfl", "to": "cluster"}, {"from": "cfl", "to": "localdataset"}, {"from": "cfl", "to": "trainset"}, {"from": "cfl", "to": "model"}, {"from": "cfl", "to": "gtvmin"}, {"from": "cfl", "to": "modelparam"}, {"from": "cfl", "to": "graphclustering"}, {"from": "coreset", "to": "dataset"}, {"from": "coreset", "to": "datapoint"}, {"from": "coreset", "to": "weights"}, {"from": "coreset", "to": "ml"}, {"from": "coreset", "to": "clustering"}, {"from": "coreset", "to": "data"}, {"from": "outlier", "to": "ml"}, {"from": "outlier", "to": "iidasspt"}, {"from": "outlier", "to": "datapoint"}, {"from": "outlier", "to": "realization"}, {"from": "outlier", "to": "iid"}, {"from": "outlier", "to": "rv"}, {"from": "outlier", "to": "probdist"}, {"from": "outlier", "to": "data"}, {"from": "outlier", "to": "measure"}, {"from": "outlier", "to": "robustness"}, {"from": "outlier", "to": "stability"}, {"from": "outlier", "to": "huberreg"}, {"from": "outlier", "to": "probmodel"}, {"from": "membershipinferenceattack", "to": "ml"}, {"from": "membershipinferenceattack", "to": "hypothesis"}, {"from": "membershipinferenceattack", "to": "erm"}, {"from": "membershipinferenceattack", "to": "trainset"}, {"from": "membershipinferenceattack", "to": "attack"}, {"from": "membershipinferenceattack", "to": "privattack"}, {"from": "membershipinferenceattack", "to": "datapoint"}, {"from": "membershipinferenceattack", "to": "featurevec"}, {"from": "membershipinferenceattack", "to": "prediction"}, {"from": "machineunlearning", "to": "ml"}, {"from": "machineunlearning", "to": "hypothesis"}, {"from": "machineunlearning", "to": "erm"}, {"from": "machineunlearning", "to": "trainset"}, {"from": "machineunlearning", "to": "privattack"}, {"from": "machineunlearning", "to": "modelinversion"}, {"from": "machineunlearning", "to": "datapoint"}, {"from": "machineunlearning", "to": "privprot"}, {"from": "machineunlearning", "to": "ai"}, {"from": "machineunlearning", "to": "gdpr"}, {"from": "ensemble", "to": "ml"}, {"from": "ensemble", "to": "baselearner"}, {"from": "ensemble", "to": "erm"}, {"from": "ensemble", "to": "loss"}, {"from": "ensemble", "to": "model"}, {"from": "ensemble", "to": "trainset"}, {"from": "ensemble", "to": "prediction"}, {"from": "ensemble", "to": "regression"}, {"from": "ensemble", "to": "classification"}, {"from": "ensemble", "to": "output"}, {"from": "ensemble", "to": "hypothesis"}, {"from": "ensemble", "to": "bagging"}, {"from": "ensemble", "to": "randomforest"}, {"from": "ensemble", "to": "boosting"}, {"from": "ensemble", "to": "stacking"}, {"from": "stacking", "to": "ensemble"}, {"from": "stacking", "to": "baselearner"}, {"from": "stacking", "to": "dataset"}, {"from": "stacking", "to": "model"}, {"from": "stacking", "to": "lossfunc"}, {"from": "stacking", "to": "hypothesis"}, {"from": "stacking", "to": "prediction"}, {"from": "stacking", "to": "datapoint"}, {"from": "stacking", "to": "classification"}, {"from": "stacking", "to": "regression"}, {"from": "stacking", "to": "featlearn"}, {"from": "stacking", "to": "feature"}, {"from": "stacking", "to": "erm"}, {"from": "stacking", "to": "map"}, {"from": "stacking", "to": "featurevec"}, {"from": "stacking", "to": "bagging"}, {"from": "sample", "to": "ml"}, {"from": "sample", "to": "sequence"}, {"from": "sample", "to": "datapoint"}, {"from": "sample", "to": "samplesize"}, {"from": "sample", "to": "erm"}, {"from": "sample", "to": "model"}, {"from": "sample", "to": "hypothesis"}, {"from": "sample", "to": "loss"}, {"from": "sample", "to": "emprisk"}, {"from": "sample", "to": "feature"}, {"from": "sample", "to": "label"}, {"from": "sample", "to": "featurevec"}, {"from": "sample", "to": "realization"}, {"from": "sample", "to": "stochproc"}, {"from": "sample", "to": "iidasspt"}, {"from": "sample", "to": "iid"}, {"from": "sample", "to": "rv"}, {"from": "sample", "to": "probdist"}, {"from": "sample", "to": "dataset"}, {"from": "auc", "to": "measure"}, {"from": "auc", "to": "classifier"}, {"from": "auc", "to": "euclidspace"}, {"from": "auc", "to": "roc"}, {"from": "roc", "to": "labelspace"}, {"from": "roc", "to": "classifier"}, {"from": "roc", "to": "hypothesis"}, {"from": "roc", "to": "prediction"}, {"from": "roc", "to": "testset"}, {"from": "roc", "to": "function"}, {"from": "roc", "to": "auc"}, {"from": "posterior", "to": "ml"}, {"from": "posterior", "to": "probmodel"}, {"from": "posterior", "to": "data"}, {"from": "posterior", "to": "datapoint"}, {"from": "posterior", "to": "feature"}, {"from": "posterior", "to": "label"}, {"from": "posterior", "to": "rv"}, {"from": "posterior", "to": "probdist"}, {"from": "posterior", "to": "prediction"}, {"from": "posterior", "to": "featurevec"}, {"from": "posterior", "to": "condprobdist"}, {"from": "bagging", "to": "ensemble"}, {"from": "bagging", "to": "baselearner"}, {"from": "bagging", "to": "trainset"}, {"from": "bagging", "to": "hypothesis"}, {"from": "bagging", "to": "classification"}, {"from": "bagging", "to": "regression"}, {"from": "bagging", "to": "robustness"}, {"from": "bagging", "to": "bootstrap"}, {"from": "bootstrap aggregation", "to": "bagging"}, {"from": "decisionregion", "to": "hypothesis"}, {"from": "decisionregion", "to": "map"}, {"from": "decisionregion", "to": "label"}, {"from": "decisionregion", "to": "feature"}, {"from": "baselearner", "to": "ml"}, {"from": "baselearner", "to": "ensemble"}, {"from": "baselearner", "to": "bagging"}, {"from": "baselearner", "to": "stacking"}, {"from": "baselearner", "to": "boosting"}, {"from": "decisionboundary", "to": "hypothesis"}, {"from": "decisionboundary", "to": "map"}, {"from": "decisionboundary", "to": "featurevec"}, {"from": "decisionboundary", "to": "vector"}, {"from": "decisionboundary", "to": "decisionregion"}, {"from": "decisionboundary", "to": "neighborhood"}, {"from": "decisionboundary", "to": "function"}, {"from": "euclidnorm", "to": "norm"}, {"from": "euclidnorm", "to": "vector"}, {"from": "euclidnorm", "to": "euclidspace"}, {"from": "eucliddist", "to": "euclidnorm"}, {"from": "eucliddist", "to": "vector"}, {"from": "eucliddist", "to": "euclidspace"}, {"from": "normalequations", "to": "modelparam"}, {"from": "normalequations", "to": "linleastsquares"}, {"from": "euclidspace", "to": "vector"}, {"from": "eerm", "to": "srm"}, {"from": "eerm", "to": "regularization"}, {"from": "eerm", "to": "loss"}, {"from": "eerm", "to": "objfunc"}, {"from": "eerm", "to": "erm"}, {"from": "eerm", "to": "hypothesis"}, {"from": "eerm", "to": "map"}, {"from": "eerm", "to": "prediction"}, {"from": "eerm", "to": "datapoint"}, {"from": "eerm", "to": "trainset"}, {"from": "kmeans", "to": "clustering"}, {"from": "kmeans", "to": "datapoint"}, {"from": "kmeans", "to": "featurevec"}, {"from": "kmeans", "to": "hardclustering"}, {"from": "kmeans", "to": "dataset"}, {"from": "kmeans", "to": "cluster"}, {"from": "kmeans", "to": "mean"}, {"from": "kmeans", "to": "clustercentroid"}, {"from": "kmeans", "to": "scatterplot"}, {"from": "kmeans", "to": "optproblem"}, {"from": "kmeans", "to": "lloydalgorithm"}, {"from": "lloydalgorithm", "to": "algorithm"}, {"from": "lloydalgorithm", "to": "optmethod"}, {"from": "lloydalgorithm", "to": "clustercentroid"}, {"from": "lloydalgorithm", "to": "kmeans"}, {"from": "lloydalgorithm", "to": "objfunc"}, {"from": "lloydalgorithm", "to": "cluster"}, {"from": "lloydalgorithm", "to": "datapoint"}, {"from": "lloydalgorithm", "to": "clustering"}, {"from": "qlearning", "to": "reinforcementlearning"}, {"from": "qlearning", "to": "algorithm"}, {"from": "qlearning", "to": "fixedpointiter"}, {"from": "iteration", "to": "algorithm"}, {"from": "iteration", "to": "gdmethod"}, {"from": "iteration", "to": "gradstep"}, {"from": "iteration", "to": "fixedpointiter"}, {"from": "iteration", "to": "operator"}, {"from": "iteration", "to": "ml"}, {"from": "iteration", "to": "lloydalgorithm"}, {"from": "iteration", "to": "gd"}, {"from": "clustercentroid", "to": "clustering"}, {"from": "clustercentroid", "to": "dataset"}, {"from": "clustercentroid", "to": "cluster"}, {"from": "clustercentroid", "to": "datapoint"}, {"from": "clustercentroid", "to": "featurevec"}, {"from": "clustercentroid", "to": "kmeans"}, {"from": "xml", "to": "prediction"}, {"from": "xml", "to": "explanation"}, {"from": "xml", "to": "ml"}, {"from": "xml", "to": "model"}, {"from": "fmi", "to": "data"}, {"from": "samplemean", "to": "sample"}, {"from": "samplemean", "to": "mean"}, {"from": "samplemean", "to": "dataset"}, {"from": "samplemean", "to": "featurevec"}, {"from": "perceptron", "to": "algorithm"}, {"from": "perceptron", "to": "ml"}, {"from": "perceptron", "to": "probmodel"}, {"from": "perceptron", "to": "maxlikelihood"}, {"from": "perceptron", "to": "optproblem"}, {"from": "loo", "to": "kfoldcv"}, {"from": "loo", "to": "valset"}, {"from": "loo", "to": "datapoint"}, {"from": "loo", "to": "validation"}, {"from": "loo", "to": "valerr"}, {"from": "covmtx", "to": "covariance"}, {"from": "covmtx", "to": "matrix"}, {"from": "covmtx", "to": "rv"}, {"from": "covmtx", "to": "expectation"}, {"from": "samplecovmtx", "to": "dataset"}, {"from": "samplecovmtx", "to": "datapoint"}, {"from": "samplecovmtx", "to": "featurevec"}, {"from": "samplecovmtx", "to": "covariance"}, {"from": "samplecovmtx", "to": "matrix"}, {"from": "samplecovmtx", "to": "covmtx"}, {"from": "samplecovmtx", "to": "empiricaldistribution"}, {"from": "samplecovmtx", "to": "samplemean"}, {"from": "samplecovmtx", "to": "rv"}, {"from": "highdimregime", "to": "erm"}, {"from": "highdimregime", "to": "effdim"}, {"from": "highdimregime", "to": "model"}, {"from": "highdimregime", "to": "samplesize"}, {"from": "highdimregime", "to": "datapoint"}, {"from": "highdimregime", "to": "trainset"}, {"from": "highdimregime", "to": "linreg"}, {"from": "highdimregime", "to": "feature"}, {"from": "highdimregime", "to": "ml"}, {"from": "highdimregime", "to": "ann"}, {"from": "highdimregime", "to": "weights"}, {"from": "highdimregime", "to": "probability"}, {"from": "highdimregime", "to": "overfitting"}, {"from": "highdimregime", "to": "regularization"}, {"from": "covariance", "to": "rv"}, {"from": "covariance", "to": "probspace"}, {"from": "covariance", "to": "scatterplot"}, {"from": "covariance", "to": "realization"}, {"from": "covariance", "to": "probmodel"}, {"from": "covariance", "to": "expectation"}, {"from": "gmm", "to": "probmodel"}, {"from": "gmm", "to": "datapoint"}, {"from": "gmm", "to": "featurevec"}, {"from": "gmm", "to": "mvndist"}, {"from": "gmm", "to": "rv"}, {"from": "gmm", "to": "probability"}, {"from": "gmm", "to": "mean"}, {"from": "gmm", "to": "vector"}, {"from": "gmm", "to": "covmtx"}, {"from": "gmm", "to": "clustering"}, {"from": "maxlikelihood", "to": "datapoint"}, {"from": "maxlikelihood", "to": "realization"}, {"from": "maxlikelihood", "to": "iid"}, {"from": "maxlikelihood", "to": "rv"}, {"from": "maxlikelihood", "to": "probdist"}, {"from": "maxlikelihood", "to": "modelparam"}, {"from": "maxlikelihood", "to": "maximum"}, {"from": "maxlikelihood", "to": "dataset"}, {"from": "maxlikelihood", "to": "optproblem"}, {"from": "maxlikelihood", "to": "probmodel"}, {"from": "polyreg", "to": "regression"}, {"from": "polyreg", "to": "erm"}, {"from": "polyreg", "to": "hypothesis"}, {"from": "polyreg", "to": "map"}, {"from": "polyreg", "to": "label"}, {"from": "polyreg", "to": "feature"}, {"from": "polyreg", "to": "datapoint"}, {"from": "polyreg", "to": "hypospace"}, {"from": "polyreg", "to": "sqerrloss"}, {"from": "polyreg", "to": "labeled datapoint"}, {"from": "polyreg", "to": "trainset"}, {"from": "leastsquares", "to": "erm"}, {"from": "leastsquares", "to": "sqerrloss"}, {"from": "leastsquares", "to": "trainset"}, {"from": "leastsquares", "to": "hypothesis"}, {"from": "leastsquares", "to": "map"}, {"from": "leastsquares", "to": "model"}, {"from": "leastsquares", "to": "linmodel"}, {"from": "leastsquares", "to": "linreg"}, {"from": "designmatrix", "to": "matrix"}, {"from": "designmatrix", "to": "featuremtx"}, {"from": "designmatrix", "to": "featurevec"}, {"from": "designmatrix", "to": "datapoint"}, {"from": "designmatrix", "to": "dataset"}, {"from": "designmatrix", "to": "model"}, {"from": "designmatrix", "to": "training"}, {"from": "designmatrix", "to": "validation"}, {"from": "datamatrix", "to": "data"}, {"from": "datamatrix", "to": "matrix"}, {"from": "datamatrix", "to": "featuremtx"}, {"from": "datamatrix", "to": "dataset"}, {"from": "datamatrix", "to": "datapoint"}, {"from": "datamatrix", "to": "featurevec"}, {"from": "datamatrix", "to": "label"}, {"from": "labelvec", "to": "dataset"}, {"from": "labelvec", "to": "labeled datapoint"}, {"from": "labelvec", "to": "label"}, {"from": "labelvec", "to": "vector"}, {"from": "labelvec", "to": "datapoint"}, {"from": "inputvec", "to": "vector"}, {"from": "inputvec", "to": "featurevec"}, {"from": "inputvec", "to": "datapoint"}, {"from": "inputvec", "to": "feature"}, {"from": "inputvec", "to": "ml"}, {"from": "inputvec", "to": "output"}, {"from": "inputvec", "to": "label"}, {"from": "outputvec", "to": "output"}, {"from": "outputvec", "to": "vector"}, {"from": "outputvec", "to": "labelvec"}, {"from": "outputvec", "to": "dataset"}, {"from": "output", "to": "label"}, {"from": "output", "to": "datapoint"}, {"from": "targetvec", "to": "target"}, {"from": "targetvec", "to": "vector"}, {"from": "targetvec", "to": "labelvec"}, {"from": "targetvec", "to": "dataset"}, {"from": "target", "to": "label"}, {"from": "target", "to": "datapoint"}, {"from": "responsevec", "to": "response"}, {"from": "responsevec", "to": "vector"}, {"from": "responsevec", "to": "labelvec"}, {"from": "responsevec", "to": "dataset"}, {"from": "responsevec", "to": "targetvec"}, {"from": "response", "to": "label"}, {"from": "response", "to": "datapoint"}, {"from": "response", "to": "target"}, {"from": "linleastsquares", "to": "leastsquares"}, {"from": "linleastsquares", "to": "linreg"}, {"from": "linleastsquares", "to": "sqerrloss"}, {"from": "linleastsquares", "to": "hypothesis"}, {"from": "linleastsquares", "to": "map"}, {"from": "linleastsquares", "to": "linmodel"}, {"from": "linleastsquares", "to": "parameter"}, {"from": "linleastsquares", "to": "featuremtx"}, {"from": "linleastsquares", "to": "labelvec"}, {"from": "linleastsquares", "to": "trainset"}, {"from": "linleastsquares", "to": "optproblem"}, {"from": "linleastsquares", "to": "vector"}, {"from": "linleastsquares", "to": "columnspace"}, {"from": "linleastsquares", "to": "normalequations"}, {"from": "linleastsquares", "to": "projection"}, {"from": "linleastsquares", "to": "erm"}, {"from": "weightedleastsquares", "to": "leastsquares"}, {"from": "weightedleastsquares", "to": "erm"}, {"from": "weightedleastsquares", "to": "sqerrloss"}, {"from": "weightedleastsquares", "to": "trainset"}, {"from": "weightedleastsquares", "to": "hypothesis"}, {"from": "weightedleastsquares", "to": "map"}, {"from": "weightedleastsquares", "to": "weights"}, {"from": "weightedleastsquares", "to": "datapoint"}, {"from": "weightedleastsquares", "to": "outlier"}, {"from": "weightedleastsquares", "to": "model"}, {"from": "weightedleastsquares", "to": "linreg"}, {"from": "weightedleastsquares", "to": "linmodel"}, {"from": "linreg", "to": "regression"}, {"from": "linreg", "to": "hypothesis"}, {"from": "linreg", "to": "map"}, {"from": "linreg", "to": "label"}, {"from": "linreg", "to": "datapoint"}, {"from": "linreg", "to": "featurevec"}, {"from": "linreg", "to": "sqerrloss"}, {"from": "linreg", "to": "trainset"}, {"from": "linreg", "to": "erm"}, {"from": "linreg", "to": "modelparam"}, {"from": "linreg", "to": "optproblem"}, {"from": "linreg", "to": "outlier"}, {"from": "linreg", "to": "linmodel"}, {"from": "linreg", "to": "feature"}, {"from": "linreg", "to": "parameter"}, {"from": "linreg", "to": "dataset"}, {"from": "linreg", "to": "featuremtx"}, {"from": "linreg", "to": "vector"}, {"from": "linreg", "to": "zerogradientcondition"}, {"from": "linreg", "to": "inverse"}, {"from": "linreg", "to": "pseudoinverse"}, {"from": "linreg", "to": "ml"}, {"from": "linreg", "to": "gd"}, {"from": "linreg", "to": "gdmethod"}, {"from": "linreg", "to": "fixedpointiter"}, {"from": "linreg", "to": "matrix"}, {"from": "linreg", "to": "stability"}, {"from": "ridgeregression", "to": "regression"}, {"from": "ridgeregression", "to": "hypothesis"}, {"from": "ridgeregression", "to": "label"}, {"from": "ridgeregression", "to": "datapoint"}, {"from": "ridgeregression", "to": "featurevec"}, {"from": "ridgeregression", "to": "parameter"}, {"from": "ridgeregression", "to": "sqerrloss"}, {"from": "ridgeregression", "to": "labeled datapoint"}, {"from": "ridgeregression", "to": "trainset"}, {"from": "ridgeregression", "to": "penaltyterm"}, {"from": "ridgeregression", "to": "euclidnorm"}, {"from": "ridgeregression", "to": "regularization"}, {"from": "ridgeregression", "to": "overfitting"}, {"from": "ridgeregression", "to": "highdimregime"}, {"from": "ridgeregression", "to": "feature"}, {"from": "ridgeregression", "to": "training"}, {"from": "ridgeregression", "to": "linmodel"}, {"from": "ridgeregression", "to": "objfunc"}, {"from": "ridgeregression", "to": "erm"}, {"from": "ridgeregression", "to": "dataset"}, {"from": "ridgeregression", "to": "realization"}, {"from": "ridgeregression", "to": "iid"}, {"from": "ridgeregression", "to": "rv"}, {"from": "ridgeregression", "to": "probdist"}, {"from": "ridgeregression", "to": "map"}, {"from": "ridgeregression", "to": "dataaug"}, {"from": "expectation", "to": "featurevec"}, {"from": "expectation", "to": "realization"}, {"from": "expectation", "to": "rv"}, {"from": "expectation", "to": "probdist"}, {"from": "expectation", "to": "discreteRV"}, {"from": "expectation", "to": "probability"}, {"from": "logreg", "to": "regression"}, {"from": "logreg", "to": "hypothesis"}, {"from": "logreg", "to": "map"}, {"from": "logreg", "to": "classifier"}, {"from": "logreg", "to": "label"}, {"from": "logreg", "to": "featurevec"}, {"from": "logreg", "to": "datapoint"}, {"from": "logreg", "to": "logloss"}, {"from": "logreg", "to": "labeled datapoint"}, {"from": "logreg", "to": "trainset"}, {"from": "logloss", "to": "datapoint"}, {"from": "logloss", "to": "feature"}, {"from": "logloss", "to": "label"}, {"from": "logloss", "to": "hypothesis"}, {"from": "logloss", "to": "loss"}, {"from": "logloss", "to": "prediction"}, {"from": "logloss", "to": "labelspace"}, {"from": "logloss", "to": "classification"}, {"from": "logloss", "to": "classifier"}, {"from": "logloss", "to": "linmodel"}, {"from": "hingeloss", "to": "datapoint"}, {"from": "hingeloss", "to": "featurevec"}, {"from": "hingeloss", "to": "label"}, {"from": "hingeloss", "to": "loss"}, {"from": "hingeloss", "to": "hypothesis"}, {"from": "hingeloss", "to": "map"}, {"from": "hingeloss", "to": "prediction"}, {"from": "hingeloss", "to": "svm"}, {"from": "hingeloss", "to": "classification"}, {"from": "hingeloss", "to": "classifier"}, {"from": "iidasspt", "to": "iid"}, {"from": "iidasspt", "to": "probmodel"}, {"from": "iidasspt", "to": "datapoint"}, {"from": "iidasspt", "to": "rv"}, {"from": "hypospace", "to": "hypothesis"}, {"from": "hypospace", "to": "model"}, {"from": "hypospace", "to": "ml"}, {"from": "hypospace", "to": "map"}, {"from": "hypospace", "to": "feature"}, {"from": "hypospace", "to": "datapoint"}, {"from": "hypospace", "to": "prediction"}, {"from": "hypospace", "to": "label"}, {"from": "hypospace", "to": "featurespace"}, {"from": "hypospace", "to": "labelspace"}, {"from": "hypospace", "to": "erm"}, {"from": "hypospace", "to": "statasp"}, {"from": "hypospace", "to": "matrix"}, {"from": "hypospace", "to": "linmodel"}, {"from": "model", "to": "ml"}, {"from": "model", "to": "hypospace"}, {"from": "model", "to": "hypothesis"}, {"from": "model", "to": "map"}, {"from": "model", "to": "label"}, {"from": "model", "to": "feature"}, {"from": "model", "to": "datapoint"}, {"from": "model", "to": "probmodel"}, {"from": "model", "to": "probdist"}, {"from": "model", "to": "linearmap"}, {"from": "modelparam", "to": "parammodel"}, {"from": "modelparam", "to": "model"}, {"from": "modelparam", "to": "parameter"}, {"from": "modelparam", "to": "ml"}, {"from": "modelparam", "to": "hypothesis"}, {"from": "modelparam", "to": "vector"}, {"from": "modelparam", "to": "paramspace"}, {"from": "modelparam", "to": "map"}, {"from": "ai", "to": "reward"}, {"from": "ai", "to": "ml"}, {"from": "ai", "to": "model"}, {"from": "ai", "to": "prediction"}, {"from": "ai", "to": "lossfunc"}, {"from": "ai", "to": "trainset"}, {"from": "ai", "to": "loss"}, {"from": "ai", "to": "modelparam"}, {"from": "ai", "to": "reinforcementlearning"}, {"from": "reward", "to": "loss"}, {"from": "reward", "to": "prediction"}, {"from": "reward", "to": "hypothesis"}, {"from": "reward", "to": "ml"}, {"from": "reward", "to": "mab"}, {"from": "reward", "to": "reinforcementlearning"}, {"from": "clusteringerror", "to": "clustering"}, {"from": "clusteringerror", "to": "dataset"}, {"from": "clusteringerror", "to": "cluster"}, {"from": "clusteringerror", "to": "measure"}, {"from": "clusteringerror", "to": "datapoint"}, {"from": "clusteringerror", "to": "featurevec"}, {"from": "clusteringerror", "to": "eucliddist"}, {"from": "clusteringerror", "to": "clustercentroid"}, {"from": "clusteringerror", "to": "hardclustering"}, {"from": "clusteringerror", "to": "kmeans"}, {"from": "clusteringerror", "to": "probmodel"}, {"from": "clusteringerror", "to": "gmm"}, {"from": "clusteringerror", "to": "parameter"}, {"from": "clusteringerror", "to": "probdist"}, {"from": "clusteringerror", "to": "maxlikelihood"}, {"from": "hardclustering", "to": "clustering"}, {"from": "hardclustering", "to": "datapoint"}, {"from": "hardclustering", "to": "cluster"}, {"from": "hardclustering", "to": "softclustering"}, {"from": "hardclustering", "to": "dob"}, {"from": "hardclustering", "to": "featurevec"}, {"from": "hardclustering", "to": "kmeans"}, {"from": "hardclustering", "to": "data"}, {"from": "hardclustering", "to": "featlearn"}, {"from": "hardclustering", "to": "specclustering"}, {"from": "hardclustering", "to": "graph"}, {"from": "hardclustering", "to": "eigenvector"}, {"from": "hardclustering", "to": "LapMat"}, {"from": "hardclustering", "to": "feature"}, {"from": "softclustering", "to": "clustering"}, {"from": "softclustering", "to": "datapoint"}, {"from": "softclustering", "to": "cluster"}, {"from": "softclustering", "to": "dob"}, {"from": "softclustering", "to": "featurevec"}, {"from": "softclustering", "to": "probmodel"}, {"from": "softclustering", "to": "gmm"}, {"from": "softclustering", "to": "probability"}, {"from": "softclustering", "to": "data"}, {"from": "softclustering", "to": "featlearn"}, {"from": "softclustering", "to": "feature"}, {"from": "softclustering", "to": "specclustering"}, {"from": "kroneckerproduct", "to": "matrix"}, {"from": "kroneckerproduct", "to": "ml"}, {"from": "kroneckerproduct", "to": "model"}, {"from": "kroneckerproduct", "to": "vector"}, {"from": "clustering", "to": "datapoint"}, {"from": "clustering", "to": "cluster"}, {"from": "clustering", "to": "measure"}, {"from": "clustering", "to": "kmeans"}, {"from": "clustering", "to": "featurevec"}, {"from": "clustering", "to": "mean"}, {"from": "clustering", "to": "softclustering"}, {"from": "clustering", "to": "gmm"}, {"from": "clustering", "to": "mvndist"}, {"from": "cluster", "to": "datapoint"}, {"from": "cluster", "to": "measure"}, {"from": "cluster", "to": "featurevec"}, {"from": "cluster", "to": "eucliddist"}, {"from": "cluster", "to": "featurespace"}, {"from": "huberloss", "to": "loss"}, {"from": "huberloss", "to": "sqerrloss"}, {"from": "huberloss", "to": "abserr"}, {"from": "svm", "to": "classification"}, {"from": "svm", "to": "hypothesis"}, {"from": "svm", "to": "map"}, {"from": "svm", "to": "linreg"}, {"from": "svm", "to": "logreg"}, {"from": "svm", "to": "erm"}, {"from": "svm", "to": "linmodel"}, {"from": "svm", "to": "lossfunc"}, {"from": "svm", "to": "datapoint"}, {"from": "svm", "to": "featurespace"}, {"from": "svm", "to": "maximum"}, {"from": "svm", "to": "hingeloss"}, {"from": "svm", "to": "vector"}, {"from": "svm", "to": "classifier"}, {"from": "svm", "to": "loss"}, {"from": "svm", "to": "decisionboundary"}, {"from": "svm", "to": "trainset"}, {"from": "svm", "to": "ml"}, {"from": "svm", "to": "kernel"}, {"from": "eigenvalue", "to": "matrix"}, {"from": "eigenvalue", "to": "vector"}, {"from": "eigenvalue", "to": "eigenvector"}, {"from": "eigenvector", "to": "matrix"}, {"from": "eigenvector", "to": "vector"}, {"from": "eigenvector", "to": "eigenvalue"}, {"from": "evd", "to": "matrix"}, {"from": "evd", "to": "eigenvector"}, {"from": "evd", "to": "eigenvalue"}, {"from": "evd", "to": "diagonalizable"}, {"from": "svd", "to": "matrix"}, {"from": "tv", "to": "gtv"}, {"from": "cvxclustering", "to": "dataset"}, {"from": "cvxclustering", "to": "convex"}, {"from": "cvxclustering", "to": "clustering"}, {"from": "cvxclustering", "to": "vector"}, {"from": "cvxclustering", "to": "norm"}, {"from": "cvxclustering", "to": "cluster"}, {"from": "cvxclustering", "to": "datapoint"}, {"from": "gdmethod", "to": "gradient"}, {"from": "gdmethod", "to": "minimum"}, {"from": "gdmethod", "to": "maximum"}, {"from": "gdmethod", "to": "differentiable"}, {"from": "gdmethod", "to": "objfunc"}, {"from": "gdmethod", "to": "modelparam"}, {"from": "gdmethod", "to": "gd"}, {"from": "gdmethod", "to": "optmethod"}, {"from": "sgd", "to": "subgradient"}, {"from": "sgd", "to": "generalization"}, {"from": "sgd", "to": "gd"}, {"from": "sgd", "to": "function"}, {"from": "sgd", "to": "gradient"}, {"from": "sgd", "to": "objfunc"}, {"from": "sgd", "to": "emprisk"}, {"from": "sgd", "to": "modelparam"}, {"from": "sgd", "to": "hypothesis"}, {"from": "stochGD", "to": "gd"}, {"from": "stochGD", "to": "gradient"}, {"from": "stochGD", "to": "objfunc"}, {"from": "stochGD", "to": "stochastic"}, {"from": "stochGD", "to": "model"}, {"from": "stochGD", "to": "erm"}, {"from": "stochGD", "to": "trainset"}, {"from": "stochGD", "to": "datapoint"}, {"from": "stochGD", "to": "emprisk"}, {"from": "stochGD", "to": "function"}, {"from": "stochGD", "to": "modelparam"}, {"from": "stochGD", "to": "batch"}, {"from": "stochGD", "to": "parameter"}, {"from": "onlineGD", "to": "ml"}, {"from": "onlineGD", "to": "modelparam"}, {"from": "onlineGD", "to": "paramspace"}, {"from": "onlineGD", "to": "datapoint"}, {"from": "onlineGD", "to": "iid"}, {"from": "onlineGD", "to": "rv"}, {"from": "onlineGD", "to": "probdist"}, {"from": "onlineGD", "to": "risk"}, {"from": "onlineGD", "to": "hypothesis"}, {"from": "onlineGD", "to": "objfunc"}, {"from": "onlineGD", "to": "gd"}, {"from": "onlineGD", "to": "gradstep"}, {"from": "onlineGD", "to": "loss"}, {"from": "onlineGD", "to": "learnrate"}, {"from": "onlineGD", "to": "sqerrloss"}, {"from": "onlineGD", "to": "onlinelearning"}, {"from": "pca", "to": "dataset"}, {"from": "pca", "to": "datapoint"}, {"from": "pca", "to": "featurevec"}, {"from": "pca", "to": "featuremap"}, {"from": "pca", "to": "feature"}, {"from": "pca", "to": "minimum"}, {"from": "pca", "to": "erm"}, {"from": "pca", "to": "lossfunc"}, {"from": "pca", "to": "matrix"}, {"from": "pca", "to": "eigenvector"}, {"from": "pca", "to": "eigenvalue"}, {"from": "pca", "to": "samplecovmtx"}, {"from": "pca", "to": "samplemean"}, {"from": "pca", "to": "psd"}, {"from": "pca", "to": "evd"}, {"from": "pca", "to": "featlearn"}, {"from": "pca", "to": "dimred"}, {"from": "loss", "to": "ml"}, {"from": "loss", "to": "lossfunc"}, {"from": "loss", "to": "hypothesis"}, {"from": "loss", "to": "datapoint"}, {"from": "loss", "to": "emprisk"}, {"from": "lossfunc", "to": "loss"}, {"from": "lossfunc", "to": "function"}, {"from": "lossfunc", "to": "map"}, {"from": "lossfunc", "to": "datapoint"}, {"from": "lossfunc", "to": "feature"}, {"from": "lossfunc", "to": "label"}, {"from": "lossfunc", "to": "hypothesis"}, {"from": "lossfunc", "to": "prediction"}, {"from": "lossfunc", "to": "featurevec"}, {"from": "lossfunc", "to": "ml"}, {"from": "lossfunc", "to": "erm"}, {"from": "decisiontree", "to": "hypothesis"}, {"from": "decisiontree", "to": "map"}, {"from": "decisiontree", "to": "graph"}, {"from": "decisiontree", "to": "featurevec"}, {"from": "decisiontree", "to": "datapoint"}, {"from": "decisiontree", "to": "feature"}, {"from": "decisiontree", "to": "decisionregion"}, {"from": "decisiontree", "to": "vector"}, {"from": "decisiontree", "to": "featurespace"}, {"from": "API", "to": "ml"}, {"from": "API", "to": "model"}, {"from": "API", "to": "featurevec"}, {"from": "API", "to": "datapoint"}, {"from": "API", "to": "prediction"}, {"from": "API", "to": "feature"}, {"from": "API", "to": "risk"}, {"from": "API", "to": "modelinversion"}, {"from": "modelinversion", "to": "model"}, {"from": "modelinversion", "to": "privattack"}, {"from": "modelinversion", "to": "ml"}, {"from": "modelinversion", "to": "sensattr"}, {"from": "modelinversion", "to": "datapoint"}, {"from": "modelinversion", "to": "prediction"}, {"from": "modelinversion", "to": "classification"}, {"from": "modelinversion", "to": "gradient"}, {"from": "modelinversion", "to": "trustAI"}, {"from": "modelinversion", "to": "privprot"}, {"from": "samplesize", "to": "datapoint"}, {"from": "samplesize", "to": "sample"}, {"from": "samplesize", "to": "dataset"}, {"from": "samplesize", "to": "erm"}, {"from": "samplesize", "to": "trainset"}, {"from": "samplesize", "to": "model"}, {"from": "samplesize", "to": "effdim"}, {"from": "samplesize", "to": "iidasspt"}, {"from": "samplesize", "to": "overfitting"}, {"from": "skipconnection", "to": "deepnet"}, {"from": "skipconnection", "to": "layer"}, {"from": "skipconnection", "to": "dag"}, {"from": "ann", "to": "hypothesis"}, {"from": "ann", "to": "feature"}, {"from": "ann", "to": "datapoint"}, {"from": "ann", "to": "prediction"}, {"from": "ann", "to": "label"}, {"from": "ann", "to": "actfun"}, {"from": "ann", "to": "dag"}, {"from": "ann", "to": "deepnet"}, {"from": "ann", "to": "layer"}, {"from": "ann", "to": "modelparam"}, {"from": "randomforest", "to": "decisiontree"}, {"from": "randomforest", "to": "dataset"}, {"from": "gd", "to": "minimum"}, {"from": "gd", "to": "differentiable"}, {"from": "gd", "to": "function"}, {"from": "gd", "to": "gradient"}, {"from": "gd", "to": "stepsize"}, {"from": "gd", "to": "gradstep"}, {"from": "abserr", "to": "datapoint"}, {"from": "abserr", "to": "feature"}, {"from": "abserr", "to": "label"}, {"from": "abserr", "to": "loss"}, {"from": "abserr", "to": "hypothesis"}, {"from": "abserr", "to": "featurevec"}, {"from": "abserr", "to": "sqerrloss"}, {"from": "abserr", "to": "convex"}, {"from": "abserr", "to": "function"}, {"from": "abserr", "to": "prediction"}, {"from": "abserr", "to": "nonsmooth"}, {"from": "abserr", "to": "differentiable"}, {"from": "abserr", "to": "erm"}, {"from": "abserr", "to": "optmethod"}, {"from": "abserr", "to": "lossfunc"}, {"from": "abserr", "to": "sgd"}, {"from": "abserr", "to": "learnrate"}, {"from": "abserr", "to": "convergence"}, {"from": "abserr", "to": "outlier"}, {"from": "abserr", "to": "trainset"}, {"from": "abserr", "to": "ladregression"}, {"from": "device", "to": "data"}, {"from": "device", "to": "ml"}, {"from": "device", "to": "datapoint"}, {"from": "device", "to": "model"}, {"from": "huberreg", "to": "regression"}, {"from": "huberreg", "to": "erm"}, {"from": "huberreg", "to": "huberloss"}, {"from": "huberreg", "to": "measure"}, {"from": "huberreg", "to": "prediction"}, {"from": "huberreg", "to": "ladregression"}, {"from": "huberreg", "to": "linreg"}, {"from": "huberreg", "to": "parameter"}, {"from": "huberreg", "to": "robustness"}, {"from": "huberreg", "to": "abserr"}, {"from": "huberreg", "to": "smooth"}, {"from": "huberreg", "to": "sqerrloss"}, {"from": "ladregression", "to": "erm"}, {"from": "ladregression", "to": "abserr"}, {"from": "ladregression", "to": "huberreg"}, {"from": "ladregression", "to": "parammodel"}, {"from": "ladregression", "to": "median"}, {"from": "ladregression", "to": "dataset"}, {"from": "ladregression", "to": "outlier"}, {"from": "ladregression", "to": "sqerrloss"}, {"from": "ladregression", "to": "mean"}, {"from": "metric", "to": "measure"}, {"from": "metric", "to": "ml"}, {"from": "metric", "to": "model"}, {"from": "metric", "to": "lossfunc"}, {"from": "metric", "to": "acc"}, {"from": "metric", "to": "zerooneloss"}, {"from": "metric", "to": "testset"}, {"from": "metric", "to": "training"}, {"from": "metric", "to": "validation"}, {"from": "metric", "to": "loss"}, {"from": "bayesrisk", "to": "probmodel"}, {"from": "bayesrisk", "to": "ml"}, {"from": "bayesrisk", "to": "datapoint"}, {"from": "bayesrisk", "to": "rv"}, {"from": "bayesrisk", "to": "probdist"}, {"from": "bayesrisk", "to": "feature"}, {"from": "bayesrisk", "to": "label"}, {"from": "bayesrisk", "to": "risk"}, {"from": "bayesrisk", "to": "minimum"}, {"from": "bayesrisk", "to": "hypothesis"}, {"from": "bayesrisk", "to": "bayesestimator"}, {"from": "bayesestimator", "to": "probmodel"}, {"from": "bayesestimator", "to": "probdist"}, {"from": "bayesestimator", "to": "feature"}, {"from": "bayesestimator", "to": "label"}, {"from": "bayesestimator", "to": "datapoint"}, {"from": "bayesestimator", "to": "lossfunc"}, {"from": "bayesestimator", "to": "hypothesis"}, {"from": "bayesestimator", "to": "risk"}, {"from": "bayesestimator", "to": "minimum"}, {"from": "weights", "to": "hypospace"}, {"from": "weights", "to": "modelparam"}, {"from": "weights", "to": "feature"}, {"from": "weights", "to": "linmodel"}, {"from": "weights", "to": "ann"}, {"from": "weights", "to": "layer"}, {"from": "weights", "to": "activation"}, {"from": "probdist", "to": "ml"}, {"from": "probdist", "to": "datapoint"}, {"from": "probdist", "to": "iid"}, {"from": "probdist", "to": "realization"}, {"from": "probdist", "to": "rv"}, {"from": "probdist", "to": "probability"}, {"from": "probdist", "to": "pdf"}, {"from": "probdist", "to": "measure"}, {"from": "pdf", "to": "rv"}, {"from": "pdf", "to": "probability"}, {"from": "pdf", "to": "event"}, {"from": "pdf", "to": "LebesgueIntegral"}, {"from": "pdf", "to": "dimension"}, {"from": "pdf", "to": "probdist"}, {"from": "pdf", "to": "measurable"}, {"from": "pdf", "to": "vector"}, {"from": "parameter", "to": "ml"}, {"from": "parameter", "to": "model"}, {"from": "parameter", "to": "hypothesis"}, {"from": "parameter", "to": "map"}, {"from": "parameter", "to": "linmodel"}, {"from": "parameter", "to": "weights"}, {"from": "parameter", "to": "ann"}, {"from": "lln", "to": "convergence"}, {"from": "lln", "to": "iid"}, {"from": "lln", "to": "rv"}, {"from": "lln", "to": "mean"}, {"from": "lln", "to": "probdist"}, {"from": "stopcrit", "to": "ml"}, {"from": "stopcrit", "to": "algorithm"}, {"from": "stopcrit", "to": "modelparam"}, {"from": "stopcrit", "to": "trainerr"}, {"from": "stopcrit", "to": "gdmethod"}, {"from": "stopcrit", "to": "parameter"}, {"from": "stopcrit", "to": "parammodel"}, {"from": "stopcrit", "to": "linmodel"}, {"from": "stopcrit", "to": "deepnet"}, {"from": "jacobimethod", "to": "algorithm"}, {"from": "jacobimethod", "to": "matrix"}, {"from": "jacobimethod", "to": "fixedpointiter"}, {"from": "jacobimethod", "to": "optmethod"}, {"from": "renyidiv", "to": "probdist"}, {"from": "nonsmooth", "to": "function"}, {"from": "nonsmooth", "to": "smooth"}, {"from": "convex", "to": "euclidspace"}, {"from": "convex", "to": "function"}, {"from": "convex", "to": "epigraph"}, {"from": "smooth", "to": "function"}, {"from": "smooth", "to": "differentiable"}, {"from": "smooth", "to": "gradient"}, {"from": "smooth", "to": "optproblem"}, {"from": "smooth", "to": "objfunc"}, {"from": "smooth", "to": "gdmethod"}, {"from": "smooth", "to": "gradstep"}, {"from": "smooth", "to": "stepsize"}, {"from": "parammodel", "to": "model"}, {"from": "parammodel", "to": "parameter"}, {"from": "parammodel", "to": "probmodel"}, {"from": "parammodel", "to": "dimension"}, {"from": "parammodel", "to": "mvndist"}, {"from": "parammodel", "to": "samplespace"}, {"from": "parammodel", "to": "mean"}, {"from": "parammodel", "to": "vector"}, {"from": "parammodel", "to": "covmtx"}, {"from": "parammodel", "to": "ml"}, {"from": "parammodel", "to": "hypospace"}, {"from": "parammodel", "to": "modelparam"}, {"from": "parammodel", "to": "hypothesis"}, {"from": "parammodel", "to": "linmodel"}, {"from": "parammodel", "to": "ann"}, {"from": "parammodel", "to": "paramspace"}, {"from": "parammodel", "to": "map"}, {"from": "paramspace", "to": "parameter"}, {"from": "paramspace", "to": "ml"}, {"from": "paramspace", "to": "model"}, {"from": "paramspace", "to": "modelparam"}, {"from": "paramspace", "to": "vector"}, {"from": "paramspace", "to": "euclidspace"}, {"from": "paramspace", "to": "linmodel"}, {"from": "paramspace", "to": "deepnet"}, {"from": "paramspace", "to": "norm"}, {"from": "paramspace", "to": "hypothesis"}, {"from": "paramspace", "to": "map"}, {"from": "datanorm", "to": "data"}, {"from": "datanorm", "to": "featurevec"}, {"from": "datanorm", "to": "datapoint"}, {"from": "datanorm", "to": "ml"}, {"from": "datanorm", "to": "statasp"}, {"from": "datanorm", "to": "compasp"}, {"from": "datanorm", "to": "linreg"}, {"from": "datanorm", "to": "gdmethod"}, {"from": "datanorm", "to": "learnrate"}, {"from": "datanorm", "to": "convergence"}, {"from": "datanorm", "to": "norm"}, {"from": "datanorm", "to": "trainset"}, {"from": "datanorm", "to": "featuremap"}, {"from": "dataaug", "to": "data"}, {"from": "dataaug", "to": "datapoint"}, {"from": "dataaug", "to": "label"}, {"from": "dataaug", "to": "featurevec"}, {"from": "dataaug", "to": "stacking"}, {"from": "dataaug", "to": "regularization"}, {"from": "dataaug", "to": "featurespace"}, {"from": "dataaug", "to": "operator"}, {"from": "localdataset", "to": "dataset"}, {"from": "localdataset", "to": "datapoint"}, {"from": "localdataset", "to": "feature"}, {"from": "localdataset", "to": "label"}, {"from": "localdataset", "to": "ml"}, {"from": "localdataset", "to": "probmodel"}, {"from": "localdataset", "to": "empgraph"}, {"from": "localmodel", "to": "device"}, {"from": "localmodel", "to": "empgraph"}, {"from": "localmodel", "to": "model"}, {"from": "localmodel", "to": "hypospace"}, {"from": "mutualinformation", "to": "rv"}, {"from": "mutualinformation", "to": "probspace"}, {"from": "mutualinformation", "to": "measure"}, {"from": "mutualinformation", "to": "prediction"}, {"from": "mutualinformation", "to": "hypothesis"}, {"from": "mutualinformation", "to": "erm"}, {"from": "mutualinformation", "to": "ml"}, {"from": "zerogradientcondition", "to": "optproblem"}, {"from": "zerogradientcondition", "to": "smooth"}, {"from": "zerogradientcondition", "to": "convex"}, {"from": "zerogradientcondition", "to": "objfunc"}, {"from": "zerogradientcondition", "to": "vector"}, {"from": "zerogradientcondition", "to": "gradient"}, {"from": "zerogradientcondition", "to": "operator"}, {"from": "edgeweight", "to": "empgraph"}, {"from": "dataminprinc", "to": "data"}, {"from": "layer", "to": "deepnet"}, {"from": "layer", "to": "ann"}, {"from": "layer", "to": "actfun"}, {"from": "layer", "to": "activation"}, {"from": "layer", "to": "feature"}, {"from": "layer", "to": "datapoint"}, {"from": "layer", "to": "prediction"}, {"from": "activation", "to": "ann"}, {"from": "activation", "to": "actfun"}, {"from": "activation", "to": "deepnet"}, {"from": "cav", "to": "deepnet"}, {"from": "cav", "to": "layer"}, {"from": "cav", "to": "label"}, {"from": "cav", "to": "datapoint"}, {"from": "cav", "to": "featurevec"}, {"from": "cav", "to": "activation"}, {"from": "cav", "to": "featurespace"}, {"from": "cav", "to": "linclass"}, {"from": "cav", "to": "decisionboundary"}, {"from": "cav", "to": "hyperplane"}, {"from": "cav", "to": "vector"}, {"from": "cav", "to": "linmodel"}, {"from": "cav", "to": "trustAI"}, {"from": "cav", "to": "interpretability"}, {"from": "cav", "to": "transparency"}, {"from": "backpropagation", "to": "algorithm"}, {"from": "backpropagation", "to": "gradient"}, {"from": "backpropagation", "to": "objfunc"}, {"from": "backpropagation", "to": "modelparam"}, {"from": "backpropagation", "to": "ann"}, {"from": "backpropagation", "to": "loss"}, {"from": "backpropagation", "to": "batch"}, {"from": "backpropagation", "to": "datapoint"}, {"from": "backpropagation", "to": "partialderivative"}, {"from": "backpropagation", "to": "lossfunc"}, {"from": "backpropagation", "to": "layer"}, {"from": "backpropagation", "to": "weights"}, {"from": "backpropagation", "to": "prediction"}, {"from": "backpropagation", "to": "label"}, {"from": "backpropagation", "to": "parameter"}, {"from": "backpropagation", "to": "gradstep"}, {"from": "backpropagation", "to": "data"}, {"from": "backpropagation", "to": "gd"}, {"from": "backpropagation", "to": "optmethod"}, {"from": "vcdim", "to": "erm"}, {"from": "vcdim", "to": "hypospace"}, {"from": "vcdim", "to": "model"}, {"from": "vcdim", "to": "measure"}, {"from": "vcdim", "to": "dimension"}, {"from": "vcdim", "to": "dataset"}, {"from": "vcdim", "to": "label"}, {"from": "vcdim", "to": "featurevec"}, {"from": "vcdim", "to": "hypothesis"}, {"from": "vcdim", "to": "gengap"}, {"from": "vcdim", "to": "linmodel"}, {"from": "vcdim", "to": "feature"}, {"from": "vcdim", "to": "datapoint"}, {"from": "vcdim", "to": "linclass"}, {"from": "vcdim", "to": "featurespace"}, {"from": "vcdim", "to": "paramspace"}, {"from": "vcdim", "to": "decisiontree"}, {"from": "vcdim", "to": "ann"}, {"from": "vcdim", "to": "rademachercomplexity"}, {"from": "vcdim", "to": "generalization"}, {"from": "vcdim", "to": "ml"}, {"from": "vcdim", "to": "effdim"}, {"from": "metricspace", "to": "metric"}, {"from": "metricspace", "to": "function"}, {"from": "metricspace", "to": "euclidspace"}, {"from": "metricspace", "to": "undirectedgraph"}, {"from": "metricspace", "to": "eucliddist"}, {"from": "metricspace", "to": "featurespace"}, {"from": "rademachercomplexity", "to": "vcdim"}, {"from": "rademachercomplexity", "to": "measure"}, {"from": "rademachercomplexity", "to": "hypospace"}, {"from": "rademachercomplexity", "to": "dataset"}, {"from": "rademachercomplexity", "to": "expectation"}, {"from": "rademachercomplexity", "to": "rv"}, {"from": "rademachercomplexity", "to": "iid"}, {"from": "rademachercomplexity", "to": "probability"}, {"from": "rademachercomplexity", "to": "generalization"}, {"from": "rademachercomplexity", "to": "ml"}, {"from": "rademachercomplexity", "to": "effdim"}, {"from": "penaltyterm", "to": "erm"}, {"from": "penaltyterm", "to": "ml"}, {"from": "penaltyterm", "to": "modelparam"}, {"from": "penaltyterm", "to": "loss"}, {"from": "penaltyterm", "to": "emprisk"}, {"from": "penaltyterm", "to": "trainset"}, {"from": "penaltyterm", "to": "overfitting"}, {"from": "penaltyterm", "to": "gengap"}, {"from": "penaltyterm", "to": "objfunc"}, {"from": "penaltyterm", "to": "rerm"}, {"from": "penaltyterm", "to": "feature"}, {"from": "penaltyterm", "to": "label"}, {"from": "penaltyterm", "to": "training"}, {"from": "penaltyterm", "to": "regularization"}, {"from": "penaltyterm", "to": "parameter"}, {"from": "penaltyterm", "to": "datapoint"}, {"from": "penaltyterm", "to": "model"}, {"from": "penaltyterm", "to": "lossfunc"}, {"from": "penaltyterm", "to": "dataaug"}, {"from": "psd", "to": "symmetricmatrix"}, {"from": "psd", "to": "vector"}, {"from": "psd", "to": "spectraldecomp"}, {"from": "psd", "to": "eigenvalue"}, {"from": "psd", "to": "matrix"}, {"from": "psd", "to": "kernel"}, {"from": "psd", "to": "map"}, {"from": "psd", "to": "featurevec"}, {"from": "normalmatrix", "to": "eigenvector"}, {"from": "normalmatrix", "to": "diagonalizable"}, {"from": "spectraldecomp", "to": "normalmatrix"}, {"from": "spectraldecomp", "to": "vector"}, {"from": "spectraldecomp", "to": "eigenvalue"}, {"from": "spectraldecomp", "to": "eigenvector"}, {"from": "symmetricmatrix", "to": "matrix"}, {"from": "symmetricmatrix", "to": "normalmatrix"}, {"from": "transpose", "to": "matrix"}, {"from": "conjugatetranspose", "to": "matrix"}, {"from": "hermitian", "to": "normalmatrix"}, {"from": "dimension", "to": "vectorspace"}, {"from": "dimension", "to": "basis"}, {"from": "linearlyindep", "to": "vectorspace"}, {"from": "linearlyindep", "to": "vector"}, {"from": "linearlyindep", "to": "dimension"}, {"from": "linearlyindep", "to": "basis"}, {"from": "basis", "to": "vectorspace"}, {"from": "basis", "to": "linearlyindep"}, {"from": "basis", "to": "vector"}, {"from": "widematrix", "to": "matrix"}, {"from": "randomexperiment", "to": "outcome"}, {"from": "randomexperiment", "to": "samplespace"}, {"from": "randomexperiment", "to": "rv"}, {"from": "randomexperiment", "to": "function"}, {"from": "randomexperiment", "to": "probability"}, {"from": "randomexperiment", "to": "probspace"}, {"from": "randomexperiment", "to": "lln"}, {"from": "randomexperiment", "to": "clt"}, {"from": "randomexperiment", "to": "ml"}, {"from": "randomexperiment", "to": "trainset"}, {"from": "randomexperiment", "to": "data"}, {"from": "randomexperiment", "to": "datapoint"}, {"from": "randomexperiment", "to": "erm"}, {"from": "randomexperiment", "to": "stochGD"}, {"from": "randomexperiment", "to": "privprot"}, {"from": "randomexperiment", "to": "output"}, {"from": "randomexperiment", "to": "diffpriv"}, {"from": "pseudoinverse", "to": "matrix"}, {"from": "pseudoinverse", "to": "inverse"}, {"from": "pseudoinverse", "to": "ridgeregression"}, {"from": "pseudoinverse", "to": "dataset"}, {"from": "pseudoinverse", "to": "featuremtx"}, {"from": "pseudoinverse", "to": "labelvec"}, {"from": "pseudoinverse", "to": "modelparam"}, {"from": "tallmatrix", "to": "matrix"}, {"from": "mgf", "to": "rv"}, {"from": "mgf", "to": "expectation"}, {"from": "chernoffbound", "to": "concentrationinequ"}, {"from": "chernoffbound", "to": "markovsinequality"}, {"from": "chernoffbound", "to": "rv"}, {"from": "chernoffbound", "to": "mgf"}, {"from": "chernoffbound", "to": "chebyshevsinequality"}, {"from": "chernoffbound", "to": "hoeffdingsinequality"}, {"from": "rankdeficient", "to": "matrix"}, {"from": "rankdeficient", "to": "rank"}, {"from": "rankdeficient", "to": "fullrank"}, {"from": "rankdeficient", "to": "linreg"}, {"from": "rankdeficient", "to": "erm"}, {"from": "rankdeficient", "to": "featuremtx"}, {"from": "rankdeficient", "to": "dimension"}, {"from": "rankdeficient", "to": "vectorspace"}, {"from": "fullrank", "to": "matrix"}, {"from": "fullrank", "to": "rank"}, {"from": "fullrank", "to": "maximum"}, {"from": "fullrank", "to": "tallmatrix"}, {"from": "fullrank", "to": "rankdeficient"}, {"from": "fullrank", "to": "widematrix"}, {"from": "fullrank", "to": "dimension"}, {"from": "fullrank", "to": "linearmap"}, {"from": "fullrank", "to": "columnspace"}, {"from": "rank", "to": "matrix"}, {"from": "rank", "to": "maximum"}, {"from": "rank", "to": "linearlyindep"}, {"from": "rank", "to": "dimension"}, {"from": "rank", "to": "columnspace"}, {"from": "rank", "to": "linearmap"}, {"from": "inverse", "to": "matrix"}, {"from": "inverse", "to": "fullrank"}, {"from": "inverse", "to": "det"}, {"from": "inverse", "to": "linreg"}, {"from": "inverse", "to": "pseudoinverse"}, {"from": "matrix", "to": "modelparam"}, {"from": "matrix", "to": "linreg"}, {"from": "matrix", "to": "linearmap"}, {"from": "matrix", "to": "vectorspace"}, {"from": "matrix", "to": "basis"}, {"from": "matrix", "to": "dataset"}, {"from": "matrix", "to": "datapoint"}, {"from": "matrix", "to": "feature"}, {"from": "matrix", "to": "label"}, {"from": "matrix", "to": "linmodel"}, {"from": "hyperplane", "to": "subspace"}, {"from": "hyperplane", "to": "vectorspace"}, {"from": "hyperplane", "to": "euclidspace"}, {"from": "hyperplane", "to": "vector"}, {"from": "hyperplane", "to": "halfspace"}, {"from": "hyperplane", "to": "decisionboundary"}, {"from": "hyperplane", "to": "linclass"}, {"from": "normalvector", "to": "hyperplane"}, {"from": "halfspace", "to": "hyperplane"}, {"from": "subspace", "to": "vectorspace"}, {"from": "columnspace", "to": "matrix"}, {"from": "columnspace", "to": "subspace"}, {"from": "columnspace", "to": "euclidspace"}, {"from": "columnspace", "to": "vectorspace"}, {"from": "mvndist", "to": "probmodel"}, {"from": "mvndist", "to": "featurevec"}, {"from": "mvndist", "to": "probdist"}, {"from": "mvndist", "to": "vector"}, {"from": "mvndist", "to": "rv"}, {"from": "mvndist", "to": "mean"}, {"from": "mvndist", "to": "covmtx"}, {"from": "mvndist", "to": "pdf"}, {"from": "mvndist", "to": "stdnormvec"}, {"from": "mvndist", "to": "fullrank"}, {"from": "mvndist", "to": "diffentropy"}, {"from": "mvndist", "to": "gaussrv"}, {"from": "stdnormvec", "to": "vector"}, {"from": "stdnormvec", "to": "iid"}, {"from": "stdnormvec", "to": "gaussrv"}, {"from": "stdnormvec", "to": "mvndist"}, {"from": "stdnormvec", "to": "rv"}, {"from": "continuous", "to": "function"}, {"from": "continuous", "to": "metricspace"}, {"from": "continuous", "to": "euclidspace"}, {"from": "continuous", "to": "metric"}, {"from": "co-domain", "to": "domain"}, {"from": "co-domain", "to": "function"}, {"from": "co-domain", "to": "map"}, {"from": "cdf", "to": "rv"}, {"from": "cdf", "to": "pdf"}, {"from": "cdf", "to": "probdist"}, {"from": "weightedgraph", "to": "graph"}, {"from": "graph", "to": "directedgraph"}, {"from": "graph", "to": "weightedgraph"}, {"from": "graph", "to": "map"}, {"from": "graph", "to": "weights"}, {"from": "markovchain", "to": "stochproc"}, {"from": "markovchain", "to": "probspace"}, {"from": "markovchain", "to": "rv"}, {"from": "markovchain", "to": "condprobdist"}, {"from": "markovprop", "to": "markovchain"}, {"from": "em", "to": "algorithm"}, {"from": "em", "to": "optmethod"}, {"from": "em", "to": "maxlikelihood"}, {"from": "em", "to": "optproblem"}, {"from": "em", "to": "ml"}, {"from": "em", "to": "datapoint"}, {"from": "em", "to": "feature"}, {"from": "em", "to": "featurespace"}, {"from": "em", "to": "data"}, {"from": "em", "to": "probmodel"}, {"from": "em", "to": "rv"}, {"from": "em", "to": "pmf"}, {"from": "em", "to": "modelparam"}, {"from": "em", "to": "gmm"}, {"from": "em", "to": "posterior"}, {"from": "em", "to": "objfunc"}, {"from": "em", "to": "iteration"}, {"from": "em", "to": "function"}, {"from": "em", "to": "majmin"}, {"from": "ppca", "to": "pca"}, {"from": "ppca", "to": "probmodel"}, {"from": "ppca", "to": "datapoint"}, {"from": "ppca", "to": "dimred"}, {"from": "ppca", "to": "em"}, {"from": "condprobdist", "to": "stochproc"}, {"from": "condprobdist", "to": "rv"}, {"from": "condprobdist", "to": "probdist"}, {"from": "condprobdist", "to": "conditionalexpect"}, {"from": "condprobdist", "to": "function"}, {"from": "condprobdist", "to": "measurable"}, {"from": "condprobdist", "to": "sigmaalgebra"}, {"from": "linearmap", "to": "map"}, {"from": "linearmap", "to": "function"}, {"from": "linearmap", "to": "vector"}, {"from": "linearmap", "to": "matrix"}, {"from": "linearmap", "to": "linmodel"}, {"from": "linearmap", "to": "domain"}, {"from": "linearmap", "to": "co-domain"}, {"from": "linearmap", "to": "vectorspace"}, {"from": "vector", "to": "vectorspace"}, {"from": "vector", "to": "ml"}, {"from": "vector", "to": "euclidspace"}, {"from": "vector", "to": "function"}, {"from": "vector", "to": "kernelmethod"}, {"from": "vector", "to": "map"}, {"from": "vector", "to": "linearmap"}, {"from": "vectorspace", "to": "vector"}, {"from": "vectorspace", "to": "euclidspace"}, {"from": "vectorspace", "to": "ml"}, {"from": "vectorspace", "to": "dataset"}, {"from": "vectorspace", "to": "hypospace"}, {"from": "vectorspace", "to": "probspace"}, {"from": "vectorspace", "to": "rv"}, {"from": "vectorspace", "to": "linmodel"}, {"from": "vectorspace", "to": "linearmap"}, {"from": "stochastic", "to": "ml"}, {"from": "stochastic", "to": "stochGD"}, {"from": "stochastic", "to": "uncertainty"}, {"from": "stochastic", "to": "probmodel"}, {"from": "stochproc", "to": "stochastic"}, {"from": "stochproc", "to": "rv"}, {"from": "stochproc", "to": "probspace"}, {"from": "stochproc", "to": "graph"}, {"from": "stochproc", "to": "ergraph"}, {"from": "stochproc", "to": "sbm"}, {"from": "stochproc", "to": "stochalgorithm"}, {"from": "stochproc", "to": "stochGD"}, {"from": "stochproc", "to": "sequence"}, {"from": "stochproc", "to": "uncertainty"}, {"from": "stochproc", "to": "probmodel"}, {"from": "characteristicfunc", "to": "function"}, {"from": "characteristicfunc", "to": "rv"}, {"from": "characteristicfunc", "to": "probdist"}, {"from": "entropy", "to": "uncertainty"}, {"from": "entropy", "to": "rv"}, {"from": "entropy", "to": "discreteRV"}, {"from": "entropy", "to": "pmf"}, {"from": "entropy", "to": "diffentropy"}, {"from": "entropy", "to": "continuous"}, {"from": "entropy", "to": "probmodel"}, {"from": "diffentropy", "to": "rv"}, {"from": "diffentropy", "to": "pdf"}, {"from": "diffentropy", "to": "entropy"}, {"from": "diffentropy", "to": "mean"}, {"from": "diffentropy", "to": "covmtx"}, {"from": "diffentropy", "to": "uncertainty"}, {"from": "diffentropy", "to": "probmodel"}, {"from": "domain", "to": "function"}, {"from": "domain", "to": "co-domain"}, {"from": "domain", "to": "map"}, {"from": "function", "to": "domain"}, {"from": "function", "to": "co-domain"}, {"from": "function", "to": "output"}, {"from": "map", "to": "function"}, {"from": "event", "to": "rv"}, {"from": "event", "to": "probspace"}, {"from": "event", "to": "measurable"}, {"from": "event", "to": "probability"}, {"from": "event", "to": "preimage"}, {"from": "event", "to": "sigmaalgebra"}, {"from": "event", "to": "samplespace"}, {"from": "event", "to": "outcome"}, {"from": "event", "to": "datapoint"}, {"from": "event", "to": "iidasspt"}, {"from": "event", "to": "probmodel"}, {"from": "countable", "to": "injective"}, {"from": "countable", "to": "function"}, {"from": "pmf", "to": "discreteRV"}, {"from": "pmf", "to": "function"}, {"from": "pmf", "to": "rv"}, {"from": "pmf", "to": "probability"}, {"from": "pmf", "to": "dataset"}, {"from": "pmf", "to": "datapoint"}, {"from": "pmf", "to": "realization"}, {"from": "pmf", "to": "iid"}, {"from": "pmf", "to": "entropy"}, {"from": "pmf", "to": "probdist"}, {"from": "pmf", "to": "probmodel"}, {"from": "discreteRV", "to": "rv"}, {"from": "discreteRV", "to": "function"}, {"from": "discreteRV", "to": "outcome"}, {"from": "discreteRV", "to": "randomexperiment"}, {"from": "discreteRV", "to": "measurable"}, {"from": "discreteRV", "to": "countable"}, {"from": "discreteRV", "to": "probability"}, {"from": "discreteRV", "to": "probdist"}, {"from": "rv", "to": "function"}, {"from": "rv", "to": "outcome"}, {"from": "rv", "to": "randomexperiment"}, {"from": "rv", "to": "measurable"}, {"from": "rv", "to": "domain"}, {"from": "rv", "to": "samplespace"}, {"from": "rv", "to": "probspace"}, {"from": "rv", "to": "co-domain"}, {"from": "rv", "to": "discreteRV"}, {"from": "rv", "to": "countable"}, {"from": "rv", "to": "vector"}, {"from": "rv", "to": "euclidspace"}, {"from": "rv", "to": "probability"}, {"from": "outcome", "to": "algorithm"}, {"from": "outcome", "to": "randomexperiment"}, {"from": "outcome", "to": "samplespace"}, {"from": "probspace", "to": "probability"}, {"from": "probspace", "to": "randomexperiment"}, {"from": "probspace", "to": "samplespace"}, {"from": "probspace", "to": "outcome"}, {"from": "probspace", "to": "sigmaalgebra"}, {"from": "probspace", "to": "event"}, {"from": "probspace", "to": "probdist"}, {"from": "probspace", "to": "function"}, {"from": "probspace", "to": "countable"}, {"from": "probspace", "to": "sequence"}, {"from": "probspace", "to": "probmodel"}, {"from": "probspace", "to": "ml"}, {"from": "integrable", "to": "measurable"}, {"from": "integrable", "to": "function"}, {"from": "integrable", "to": "measurespace"}, {"from": "integrable", "to": "LebesgueIntegral"}, {"from": "integrable", "to": "rv"}, {"from": "integrable", "to": "samplespace"}, {"from": "integrable", "to": "probspace"}, {"from": "integrable", "to": "expectation"}, {"from": "integrable", "to": "measure"}, {"from": "measurespace", "to": "measure"}, {"from": "measurespace", "to": "sigmaalgebra"}, {"from": "measurespace", "to": "measurable"}, {"from": "measurespace", "to": "euclidspace"}, {"from": "measurespace", "to": "LebesgueIntegral"}, {"from": "measurespace", "to": "rv"}, {"from": "measurespace", "to": "probspace"}, {"from": "measurespace", "to": "samplespace"}, {"from": "measurespace", "to": "probdist"}, {"from": "measure", "to": "sigmaalgebra"}, {"from": "measure", "to": "function"}, {"from": "measure", "to": "measurable"}, {"from": "measure", "to": "countable"}, {"from": "LebesgueIntegral", "to": "integrable"}, {"from": "LebesgueIntegral", "to": "function"}, {"from": "LebesgueIntegral", "to": "simplefunction"}, {"from": "LebesgueIntegral", "to": "domain"}, {"from": "LebesgueIntegral", "to": "measure"}, {"from": "conditionalexpect", "to": "rv"}, {"from": "conditionalexpect", "to": "probspace"}, {"from": "conditionalexpect", "to": "sigmaalgebra"}, {"from": "conditionalexpect", "to": "outcome"}, {"from": "conditionalexpect", "to": "randomexperiment"}, {"from": "conditionalexpect", "to": "expectation"}, {"from": "conditionalexpect", "to": "measurable"}, {"from": "conditionalpmf", "to": "discreteRV"}, {"from": "conditionalpmf", "to": "probspace"}, {"from": "conditionalpmf", "to": "conditionalexpect"}, {"from": "conditionalpmf", "to": "sigmaalgebra"}, {"from": "conditionalpmf", "to": "rv"}, {"from": "conditionalpmf", "to": "pmf"}, {"from": "iid", "to": "rv"}, {"from": "iid", "to": "probdist"}, {"from": "iid", "to": "event"}, {"from": "iid", "to": "datapoint"}, {"from": "iid", "to": "iidasspt"}, {"from": "preimage", "to": "function"}, {"from": "measurable", "to": "randomexperiment"}, {"from": "measurable", "to": "fmi"}, {"from": "measurable", "to": "samplespace"}, {"from": "measurable", "to": "outcome"}, {"from": "measurable", "to": "ml"}, {"from": "measurable", "to": "sigmaalgebra"}, {"from": "measurable", "to": "sigmafield"}, {"from": "measurable", "to": "probability"}, {"from": "sigmaalgebra", "to": "randomexperiment"}, {"from": "sigmaalgebra", "to": "samplespace"}, {"from": "sigmaalgebra", "to": "sigmafield"}, {"from": "sigmaalgebra", "to": "countable"}, {"from": "sigmaalgebra", "to": "rv"}, {"from": "sigmaalgebra", "to": "probspace"}, {"from": "sigmafield", "to": "sigmaalgebra"}, {"from": "injective", "to": "function"}, {"from": "injective", "to": "domain"}, {"from": "injective", "to": "co-domain"}, {"from": "injective", "to": "output"}, {"from": "typicalset", "to": "pmf"}, {"from": "majmin", "to": "optproblem"}, {"from": "majmin", "to": "convex"}, {"from": "majmin", "to": "nonsmooth"}, {"from": "majmin", "to": "objfunc"}, {"from": "majmin", "to": "erm"}, {"from": "majmin", "to": "modelparam"}, {"from": "majmin", "to": "model"}, {"from": "majmin", "to": "optmethod"}, {"from": "majmin", "to": "sequence"}, {"from": "majmin", "to": "iteration"}, {"from": "majmin", "to": "function"}, {"from": "majmin", "to": "gdmethod"}, {"from": "majmin", "to": "em"}, {"from": "markovsinequality", "to": "rv"}, {"from": "markovsinequality", "to": "expectation"}, {"from": "markovsinequality", "to": "probability"}, {"from": "markovsinequality", "to": "function"}, {"from": "markovsinequality", "to": "LebesgueIntegral"}, {"from": "markovsinequality", "to": "pdf"}, {"from": "markovsinequality", "to": "concentrationinequ"}, {"from": "chebyshevsinequality", "to": "rv"}, {"from": "chebyshevsinequality", "to": "expectation"}, {"from": "chebyshevsinequality", "to": "variance"}, {"from": "chebyshevsinequality", "to": "probability"}, {"from": "chebyshevsinequality", "to": "markovsinequality"}, {"from": "chebyshevsinequality", "to": "concentrationinequ"}, {"from": "hoeffdingsinequality", "to": "concentrationinequ"}, {"from": "hoeffdingsinequality", "to": "probability"}, {"from": "hoeffdingsinequality", "to": "rv"}, {"from": "hoeffdingsinequality", "to": "mean"}, {"from": "hoeffdingsinequality", "to": "chebyshevsinequality"}, {"from": "hoeffdingsinequality", "to": "ml"}, {"from": "hoeffdingsinequality", "to": "erm"}, {"from": "hoeffdingsinequality", "to": "mab"}, {"from": "hoeffdingsinequality", "to": "expectation"}, {"from": "hoeffdingsinequality", "to": "probspace"}, {"from": "hoeffdingsinequality", "to": "markovsinequality"}, {"from": "rgg", "to": "probmodel"}, {"from": "rgg", "to": "graph"}, {"from": "rgg", "to": "metricspace"}, {"from": "rgg", "to": "probdist"}, {"from": "rgg", "to": "realization"}, {"from": "rgg", "to": "iid"}, {"from": "rgg", "to": "rv"}, {"from": "rgg", "to": "metric"}, {"from": "rgg", "to": "norm"}, {"from": "rgg", "to": "eucliddist"}, {"from": "rgg", "to": "sbm"}, {"from": "rgg", "to": "ergraph"}, {"from": "banachfixedpoint", "to": "contractop"}, {"from": "banachfixedpoint", "to": "metricspace"}, {"from": "banachfixedpoint", "to": "fixedpointiter"}, {"from": "banachfixedpoint", "to": "sequence"}, {"from": "banachfixedpoint", "to": "cauchysequence"}, {"from": "diagonalizable", "to": "matrix"}, {"from": "diagonalizable", "to": "eigenvalue"}, {"from": "diagonalizable", "to": "eigenvector"}, {"from": "diagonalizable", "to": "evd"}, {"from": "schurdecomp", "to": "matrix"}, {"from": "schurdecomp", "to": "eigenvalue"}, {"from": "schurdecomp", "to": "diagonalizable"}, {"from": "schurdecomp", "to": "eigenvector"}, {"from": "schurdecomp", "to": "evd"}, {"from": "unitary", "to": "matrix"}, {"from": "innerproduct", "to": "vectorspace"}, {"from": "innerproduct", "to": "function"}, {"from": "innerproduct", "to": "norm"}, {"from": "innerproduct", "to": "metric"}, {"from": "innerproduct", "to": "vector"}, {"from": "innerproduct", "to": "metricspace"}, {"from": "trace", "to": "matrix"}, {"from": "trace", "to": "linearmap"}, {"from": "trace", "to": "eigenvalue"}, {"from": "stddev", "to": "rv"}, {"from": "stddev", "to": "variance"}, {"from": "stddev", "to": "expectation"}, {"from": "sequence", "to": "function"}, {"from": "sequence", "to": "ml"}, {"from": "sequence", "to": "algorithm"}, {"from": "sequence", "to": "dataset"}, {"from": "convergence", "to": "sequence"}, {"from": "convergence", "to": "metricspace"}, {"from": "convergence", "to": "metric"}, {"from": "convergence", "to": "cauchysequence"}, {"from": "johnsonlindenstrausslemma", "to": "featuremap"}, {"from": "johnsonlindenstrausslemma", "to": "eucliddist"}, {"from": "johnsonlindenstrausslemma", "to": "featurevec"}, {"from": "johnsonlindenstrausslemma", "to": "dataset"}, {"from": "johnsonlindenstrausslemma", "to": "datapoint"}, {"from": "johnsonlindenstrausslemma", "to": "featurespace"}, {"from": "johnsonlindenstrausslemma", "to": "matrix"}, {"from": "johnsonlindenstrausslemma", "to": "iid"}, {"from": "johnsonlindenstrausslemma", "to": "gaussrv"}, {"from": "johnsonlindenstrausslemma", "to": "probability"}, {"from": "johnsonlindenstrausslemma", "to": "norm"}, {"from": "johnsonlindenstrausslemma", "to": "vectorspace"}, {"from": "johnsonlindenstrausslemma", "to": "euclidspace"}, {"from": "johnsonlindenstrausslemma", "to": "dimred"}, {"from": "johnsonlindenstrausslemma", "to": "pca"}, {"from": "statespace", "to": "ml"}, {"from": "statespace", "to": "probmodel"}, {"from": "statespace", "to": "reinforcementlearning"}, {"from": "statespace", "to": "featurevec"}, {"from": "statespace", "to": "hypothesis"}, {"from": "statespace", "to": "action"}, {"from": "differentiable", "to": "function"}, {"from": "differentiable", "to": "gradient"}, {"from": "gradient", "to": "function"}, {"from": "gradient", "to": "vector"}, {"from": "subgradient", "to": "function"}, {"from": "subgradient", "to": "vector"}, {"from": "strcvx", "to": "differentiable"}, {"from": "strcvx", "to": "function"}, {"from": "strcvx", "to": "convex"}, {"from": "strictlyconvex", "to": "function"}, {"from": "strictlyconvex", "to": "convex"}, {"from": "strictlyconvex", "to": "domain"}, {"from": "strictlyconvex", "to": "strcvx"}, {"from": "directedcycle", "to": "directedgraph"}, {"from": "directedcycle", "to": "sequence"}, {"from": "directedcycle", "to": "connected"}, {"from": "directedcycle", "to": "dag"}, {"from": "dag", "to": "directedgraph"}, {"from": "dag", "to": "directedcycle"}, {"from": "dag", "to": "sequence"}, {"from": "dag", "to": "ml"}, {"from": "dag", "to": "model"}, {"from": "dag", "to": "ann"}, {"from": "dag", "to": "decisiontree"}, {"from": "directedgraph", "to": "graph"}, {"from": "undirectedgraph", "to": "graph"}, {"from": "simplefunction", "to": "function"}, {"from": "simplefunction", "to": "measurable"}, {"from": "simplefunction", "to": "LebesgueIntegral"}, {"from": "gradstep", "to": "differentiable"}, {"from": "gradstep", "to": "function"}, {"from": "gradstep", "to": "vector"}, {"from": "gradstep", "to": "gradient"}, {"from": "gradstep", "to": "stepsize"}, {"from": "gradstep", "to": "neighborhood"}, {"from": "gradstep", "to": "generalization"}, {"from": "gradstep", "to": "parameter"}, {"from": "gradstep", "to": "learnrate"}, {"from": "gradstep", "to": "convex"}, {"from": "gradstep", "to": "proxop"}, {"from": "mirrordescent", "to": "optmethod"}, {"from": "mirrordescent", "to": "gradstep"}, {"from": "mirrordescent", "to": "differentiable"}, {"from": "mirrordescent", "to": "objfunc"}, {"from": "mirrordescent", "to": "euclidnorm"}, {"from": "mirrordescent", "to": "learnrate"}, {"from": "mirrordescent", "to": "bregmandivergence"}, {"from": "mirrordescent", "to": "strictlyconvex"}, {"from": "mirrordescent", "to": "function"}, {"from": "mirrordescent", "to": "convex"}, {"from": "mirrordescent", "to": "proxop"}, {"from": "bregmandivergence", "to": "convex"}, {"from": "bregmandivergence", "to": "differentiable"}, {"from": "bregmandivergence", "to": "function"}, {"from": "bregmandivergence", "to": "domain"}, {"from": "bregmandivergence", "to": "metric"}, {"from": "bregmandivergence", "to": "learnrate"}, {"from": "bregmandivergence", "to": "gradstep"}, {"from": "bregmandivergence", "to": "modelparam"}, {"from": "bregmandivergence", "to": "norm"}, {"from": "bregmandivergence", "to": "proxop"}, {"from": "mdp", "to": "reinforcementlearning"}, {"from": "mdp", "to": "stochproc"}, {"from": "mdp", "to": "statespace"}, {"from": "mdp", "to": "actionspace"}, {"from": "mdp", "to": "function"}, {"from": "mdp", "to": "probdist"}, {"from": "mdp", "to": "reward"}, {"from": "mdp", "to": "sequence"}, {"from": "mdp", "to": "rv"}, {"from": "mdp", "to": "markovprop"}, {"from": "mdp", "to": "condprobdist"}, {"from": "mdp", "to": "prediction"}, {"from": "reinforcementlearning", "to": "onlinelearning"}, {"from": "reinforcementlearning", "to": "hypothesis"}, {"from": "reinforcementlearning", "to": "modelparam"}, {"from": "reinforcementlearning", "to": "featurevec"}, {"from": "reinforcementlearning", "to": "datapoint"}, {"from": "reinforcementlearning", "to": "prediction"}, {"from": "reinforcementlearning", "to": "reward"}, {"from": "reinforcementlearning", "to": "lossfunc"}, {"from": "reinforcementlearning", "to": "ml"}, {"from": "action", "to": "ai"}, {"from": "action", "to": "reward"}, {"from": "action", "to": "featurevec"}, {"from": "action", "to": "hypothesis"}, {"from": "action", "to": "onlinelearning"}, {"from": "action", "to": "prediction"}, {"from": "action", "to": "mab"}, {"from": "action", "to": "reinforcementlearning"}, {"from": "action", "to": "lossfunc"}, {"from": "actionspace", "to": "action"}, {"from": "mab", "to": "uncertainty"}, {"from": "mab", "to": "reward"}, {"from": "mab", "to": "probdist"}, {"from": "mab", "to": "ml"}, {"from": "mab", "to": "reinforcementlearning"}, {"from": "mab", "to": "regret"}, {"from": "regret", "to": "hypothesis"}, {"from": "regret", "to": "baseline"}, {"from": "regret", "to": "loss"}, {"from": "regret", "to": "expert"}, {"from": "personaldata", "to": "data"}, {"from": "profiling", "to": "data"}, {"from": "profiling", "to": "ml"}, {"from": "profiling", "to": "gdpr"}, {"from": "aisystem", "to": "ai"}, {"from": "aisystem", "to": "model"}, {"from": "aisystem", "to": "prediction"}, {"from": "aisystem", "to": "algorithm"}, {"from": "aisystem", "to": "robustness"}, {"from": "aisystem", "to": "transparency"}, {"from": "aisystem", "to": "data"}, {"from": "gdpr", "to": "data"}, {"from": "gdpr", "to": "ml"}, {"from": "gdpr", "to": "dataminprinc"}, {"from": "gdpr", "to": "transparency"}, {"from": "gdpr", "to": "explainability"}, {"from": "gdpr", "to": "profiling"}, {"from": "highriskaisystem", "to": "aisystem"}, {"from": "deepfake", "to": "aisystem"}, {"from": "deepfake", "to": "event"}, {"from": "transparency", "to": "trustAI"}, {"from": "transparency", "to": "ml"}, {"from": "transparency", "to": "explainability"}, {"from": "transparency", "to": "ai"}, {"from": "transparency", "to": "prediction"}, {"from": "transparency", "to": "model"}, {"from": "transparency", "to": "logreg"}, {"from": "transparency", "to": "classification"}, {"from": "transparency", "to": "decisiontree"}]);
    const container = document.getElementById('mynetwork');
    const data = { nodes, edges };

    // ---------------------------
    // Options
    // ---------------------------
    const options = {
      nodes: {
        shape: 'dot',
        scaling: { min: 5, max: 30 },
        font: { size: 14, face: 'Inter, Arial, sans-serif' }
      },
      edges: {
        arrows: 'to',
        color: '#999',
        smooth: true
      },
      physics: {
        enabled: true,
        solver: 'forceAtlas2Based',
        stabilization: {
          enabled: true,
          iterations: 1800,
          updateInterval: 25,
          fit: true
        }
      },
      interaction: {
        hover: true,
        tooltipDelay: 120,
        navigationButtons: true,
        keyboard: true
      }
    };

    const network = new vis.Network(container, data, options);

    // ---------------------------
    // Overlay helpers
    // ---------------------------
    const statusEl = document.getElementById("status");
    const barEl = document.getElementById("bar");
    function setStatus(msg) { statusEl.textContent = msg; }
    function setProgress(frac) { barEl.style.width = Math.max(0, Math.min(1, frac)) * 100 + "%"; }

    // ---------------------------
    // Roaming camera utilities
    // ---------------------------
    const ROAM_ENABLED = true;
    const CURATED_TOUR = [];        // term keys, may be empty
    const AUTO_TOUR_K = 10;
    const FREEZE_INTERACTION = true;

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function filterExisting(ids) {
      const existing = new Set(nodes.getIds());
      return ids.filter(x => existing.has(x));
    }

    // Default tour: top-K by in-degree (many terms refer to it)
    function pickTourNodesByInDegree(k) {
      const all = nodes.get(); // contains fields like {id,label,value,inDeg}
      all.sort((a,b) => (b.inDeg || 0) - (a.inDeg || 0));

      // Take top-k, but try to reduce near-duplicates by sampling every other from top 2k
      const top = all.slice(0, Math.min(all.length, k * 2));
      const pick = [];
      for (let i=0; i<top.length && pick.length<k; i+=2) pick.push(top[i].id);
      if (pick.length < k) {
        for (let i=1; i<top.length && pick.length<k; i+=2) pick.push(top[i].id);
      }
      return pick;
    }

    async function focusNode(nodeId, scale, ms) {
      const pos = network.getPositions([nodeId])[nodeId];
      if (!pos) return;
      network.selectNodes([nodeId]);
      network.focus(nodeId, {
        scale: scale,
        animation: { duration: ms, easingFunction: "easeInOutQuad" }
      });
      await sleep(ms + 140);
    }

    async function microRoam(nodeId, baseScale) {
      const pos = network.getPositions([nodeId])[nodeId];
      if (!pos) return;

      const jitter = [
        { dx:  40, dy: -20, s: baseScale * 1.05 },
        { dx: -30, dy:  25, s: baseScale * 0.98 },
        { dx:  20, dy:  30, s: baseScale * 1.03 },
      ];

      for (const j of jitter) {
        network.moveTo({
          position: { x: pos.x + j.dx, y: pos.y + j.dy },
          scale: j.s,
          animation: { duration: 900, easingFunction: "easeInOutQuad" }
        });
        await sleep(980);
      }
    }

    async function roamTour() {
      setStatus("Roaming… (auto camera)");
      setProgress(1.0);

      // Start with a wide view
      network.unselectAll();
      network.fit({
        animation: { duration: 900, easingFunction: "easeInOutQuad" }
      });
      await sleep(1050);

      let tour = [];
      if (CURATED_TOUR && CURATED_TOUR.length > 0) {
        tour = filterExisting(CURATED_TOUR);
      } else {
        tour = pickTourNodesByInDegree(AUTO_TOUR_K);
      }

      if (tour.length === 0) {
        setStatus("No tour nodes found.");
        return;
      }

      // Pleasant zoom schedule (varies shots)
      const scales = [2.4, 1.9, 2.8, 1.7, 2.2, 3.0, 1.8, 2.5, 2.0, 2.7];

      for (let i = 0; i < tour.length; i++) {
        const nodeId = tour[i];
        const sc = scales[i % scales.length];

        await focusNode(nodeId, sc, 1200);
        await microRoam(nodeId, sc);

        // Every 3 nodes, zoom out to re-contextualize
        if ((i + 1) % 3 === 0) {
          network.unselectAll();
          network.fit({
            animation: { duration: 900, easingFunction: "easeInOutQuad" }
          });
          await sleep(1050);
        }
      }

      // End on a wide shot
      network.unselectAll();
      network.fit({
        animation: { duration: 1200, easingFunction: "easeInOutQuad" }
      });
      setStatus("Done. (Layout frozen)");
    }

    // ---------------------------
    // Stabilization callbacks
    // ---------------------------
    network.on("stabilizationProgress", function (params) {
      const frac = params.iterations / Math.max(1, params.total);
      setProgress(frac);
      setStatus(`Stabilizing layout… ${Math.round(frac * 100)}%`);
    });

    network.once("stabilizationIterationsDone", async function () {
      setStatus("Stabilized. Freezing layout…");
      setProgress(1.0);

      // Freeze node positions (no more motion)
      network.setOptions({ physics: { enabled: false } });

      // Optional: prevent accidental dragging/zoom during recording
      if (FREEZE_INTERACTION) {
        network.setOptions({
          interaction: {
            dragNodes: false,
            dragView: false,
            zoomView: false,
            navigationButtons: false,
            keyboard: false
          }
        });
      }

      await sleep(250);

      if (ROAM_ENABLED) {
        roamTour();
      } else {
        setStatus("Stabilized. (Roam disabled)");
      }
    });
  </script>
</body>
</html>