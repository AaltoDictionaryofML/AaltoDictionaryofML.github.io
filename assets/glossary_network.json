{
  "nodes": [
    {
      "id": "pseudoinverse",
      "name": "pseudoinverse",
      "desc": "The Moore–Penrose pseudoinverse of a generalizes the notion of an . The pseudoinverse arises naturally in for a with and . The learned by are given by We can then define the pseudoinverse via the limit \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "randomexperiment",
      "name": "random experiment",
      "desc": "A random experiment is a physical (or abstract) process that produces an outcome from a set of possibilities. This set of all possible outcomes is referred to as the of the experiment. The key characteristic of a random experiment is that its outcome is unpredictable (or uncertain). Any measurement or observation of the outcome is a , i.e., a of the outcome . theory uses a as a mathematical structure for the study of random experiments. A key conceptual property of a random experiment is that it can be repeated under identical conditions. Strictly speaking, repeating a random experiment a given number of times defines a new random experiment. The outcomes of this new experiment are length- sequences of outcomes from the original experiment (see Fig. ). While the outcome of a single experiment is uncertain, the long-run behaviour of the outcomes of repeated experiments tends to become increasingly predictable. This informal claim can be made precise via fundamental results of theory, such as the and the . [H] [>=Stealth, node distance=1.5cm and 2cm, every node/.style={font= }] (experiment) [draw, rectangle, rounded corners, minimum width=2.6cm, align=center] {random\\ }; (omega) [right=of experiment] { }; (rightpad) at ( ); (experiment) -- (omega); (sequence) [below=of experiment, yshift=-0.5cm] { }; (sequence1) [below=of sequence, yshift=-0.5cm] { }; (experiment.south) -- node[midway, right, xshift=3pt] {repeat times} (sequence.north); (sequence.south) -- node[midway, right, xshift=3pt] { } (sequence1.north); (experiment.south) -- (sequence.north) coordinate[pos=0.6] (repeatpoint); ; {A random experiment produces an outcome from a set of possibilities (i.e., a ) . Repeating the experiment times yields another random experiment, whose outcomes are sequences . One example of a random experiment arising in many applications is the gathering of a . } Examples for random experiments arising in applications include the following: collection: The collected in -based methods can be interpreted as , i.e., as of the outcome of a random experiment. uses a random experiment at each iteration to select a subset of the . methods use random experiments to perturb the outputs of an method to ensure . See also: , , , .",
      "deg": 23
    },
    {
      "id": "dimension",
      "name": "dimension",
      "desc": "The dimension of a is the cardinality of any of . Strictly speaking, this definition applies only to finite-dimensional , i.e., those that possess a finite . [H] [scale=1] (O) at (0,0); (O) -- (1.8,0) node[below right] { }; (O) -- (0,1.6) node[above left] { }; (0,0) -- (1.2,1.2) node[above right] { }; (0,0) -- (-1.2,1.2) node[above left] { }; (O) -- (2.0,0.6) node[above right] { }; (O) -- (0.4,1.8) node[left] { }; {Three , , for the .} For such spaces, all have the same cardinality, which is the dimension of the space . \\\\ See also: , .",
      "deg": 8
    },
    {
      "id": "linearlyindep",
      "name": "linearly independent",
      "desc": "A subset of a is linearly independent if there is no non-trivial linear combination of these that equals the zero . In other words, \\\\ See also: , , , .",
      "deg": 5
    },
    {
      "id": "basis",
      "name": "basis",
      "desc": "A basis of a is a set of such that any vector can be expressed as a linear combination of the basis , i.e.,",
      "deg": 5
    },
    {
      "id": "widematrix",
      "name": "wide matrix",
      "desc": "A is referred to as wide if it has more columns than rows, i.e., .\\\\ See also: .",
      "deg": 2
    },
    {
      "id": "tallmatrix",
      "name": "tall matrix",
      "desc": "A is referred to as tall if it has more rows than columns, i.e., when .\\\\ See also: .",
      "deg": 2
    },
    {
      "id": "imagesegmentation",
      "name": "image segementation",
      "desc": "Image segementation refers to the task of the pixels of an image into few segments.\\\\ See also: .",
      "deg": 1
    },
    {
      "id": "mgf",
      "name": "moment generating function (MGF)",
      "desc": "Consider The MGF of a real-valued is defined as for any for which this exists . As its name indicates, the MGF allows to compute the moments for . In particular, the -th moment is obtained by evaluating the -th derivative of for , i.e., . This fact can be verified by the following identities: {t} & = \\{ (t x) \\} \\\\ & {=} \\! \\{ _{k=0}^{ } {t^{k}}{k!} x^{k} \\} \\\\ & {=} _{k=0}^{ } {t^{k}}{k!}\\, \\! \\{ x^{k} \\}. Here, step is due to the Taylor series expansion of and step is valid when the MGF exists for all in some interval . [ht] [ width=9cm, height=4.2cm, domain=-1:1, samples=200, xlabel={ }, ylabel={}, ytick= , ytick={-1,-0.5,0,0.5,1}, yticklabels={ , , , , }, xtick={-1,-0.5,0,0.5,1}, xticklabels={ , , , , }, xmin=-1, xmax=1, legend style={at={(1.5,0.02)},anchor=south east} ] ; ; ; {The first few powers of a . The MGF encodes the moments of which are the of the powers for .} The MGF is a useful tool for the study of sums of independent . As a case in point, if and are independent , then the MGF of their sum typically satisfies , i.e., the MGF of the sum is typically the pointwise product of the individual MGFs .",
      "deg": 2
    },
    {
      "id": "chernoffbound",
      "name": "Chernoff bound",
      "desc": "TBC .",
      "deg": 0
    },
    {
      "id": "rankdeficient",
      "name": "rank-deficient",
      "desc": "A is rank-deficient if it is not , i.e., when . [htbp] [x=2cm] (0,0) -- (1,0) node[below] { }; (0,0) -- (0,1) node[above] { }; [shift={(3.2,0)}] (A) at (0.2,0.0); (B) at (2.0,0.0); (0,0) -- (A) node[below,yshift=-2pt] { }; (0,0) -- (B) node[above,yshift=2pt] { }; (1.6,0.5) to[bend left] node[midway, above] { } (2.7,0.5); {Example of a rank-deficient . } In , the solution of the problem is not unique whenever the is such that the is rank-deficient.\\\\ See also: , , .",
      "deg": 8
    },
    {
      "id": "fullrank",
      "name": "full-rank",
      "desc": "A is full-rank if it has maximum . For a tall , i.e., when , being full-rank means that its is equal to . [H] [every node/.style={font= }] at (0,2) { }; ; at (4.5,2) { }; { square}; at (0,-1.0) { }; { full-rank }; at (4.5,-1.0) { }; { }; {Examples of full-rank and .} A square matrix is full-rank if and only if it is invertible. \\\\ See also: , , , .",
      "deg": 9
    },
    {
      "id": "rank",
      "name": "rank",
      "desc": "The rank of a , denoted as is the maximum number of linearly independent columns of . Equivalently, the rank can be defined as the of the . The rank of a can neither exceed the number of rows nor the number of columns of , i.e., . \\\\ See also: , , , .",
      "deg": 6
    },
    {
      "id": "inverse",
      "name": "inverse matrix",
      "desc": "An inverse is defined for a square that is of full rank, meaning its columns are linearly independent. In this case, is said to be invertible, and its inverse satisfies A square is invertible if and only if its is non-zero. Inverse are fundamental in solving systems of linear equations and in the closed-form solution of , . The concept of an inverse can be extended to that are not square or does not have full . One may define a ``left inverse'' satisfying or a ``right inverse'' satisfying . For general rectangular or singular , the Moore–Penrose provides a unified concept of a generalized inverse . [H] [x=2cm,y=2cm] (0,0) -- (1,0) node[below right] { }; (0,0) -- (0,1) node[above left] { }; [shift={(2.0,0)}] (A) at (1.5,0.5); (B) at (-0.2,1.2); (0,0) -- (A) node[pos=0.5, below right] { }; (0,0) -- (B) node[above right] { }; [shift={(4.9,0)}] (0,0) -- (1,0) node[pos=0.5, below] { }; (0,0) -- (0,1) node[above] { }; (1.2,0.4) to node[above] { } (1.8,0.4); (3.8,0.4) to node[below] { } (4.4,0.4); {A represents a linear transformation of . The inverse represents the inverse transformation. } See also: , , , .",
      "deg": 9
    },
    {
      "id": "matrix",
      "name": "matrix",
      "desc": "A matrix of size is a 2-D array of numbers, which is denoted by Here, denotes the matrix entry in the th row and the th column. Matrices are useful representations of various mathematical objects , including the following: Systems of linear equations: We can use a matrix to represent a system of linear equations One important example of systems of linear equations is the optimality condition for the within . : Consider a -dimensional and a -dimensional . If we fix a basis for and a basis for , each matrix naturally defines a (see Fig. ) such that : We can use a matrix to represent a . Each row corresponds to a single , and each column corresponds to a specific or of a . [H] [x=2cm] (0,0) -- (1,0) node[below] { }; (0,0) -- (0,1) node[above] { }; [shift={(3.2,0)}] (0,0) -- (1,0) node[below] { }; (0,0) -- (0,1) node[above] { }; (A) at (0.2,-1.0); (B) at (0.4,1.2); (0,0) -- (A) node[below,right] { }; (0,0) -- (B) node[right,xshift=1pt] { }; (1.6,0.5) to[bend left] node[midway, above] { } (2.7,0.5); {A matrix defines a between two . } See also: , , .",
      "deg": 45
    },
    {
      "id": "stratification",
      "name": "stratification",
      "desc": "The process of splitting a into subsets, so called , according to some key attribute is called stratification . The goal is to ensure that a method performs well for each defined by these attributes. For example, in a medical , we may want to stratify a patient by age groups to ensure that an model performs well across all age groups. [H] [font= ,x=1.7cm] at (0.5* , +0.2) { }; at ({0.5* }, {-( + )+ +0.2}) {train/val split without }; at (0.5* , {-2*( + )+ +0.2}) {with }; {0} {-( + )} {-2*( + )} { } { } {(1- )* } (0, ) rectangle ++( , ); ( , ) -- ++(0, ); at (0.5* , +0.5* ) { }; at ({ +0.5* }, { +0.5* }) { }; (0, ) rectangle ++( , ); { } {(1- )* } ( , ) rectangle ++( , ); ( , ) -- ++(0, ); (0, ) rectangle ++( , ); { } ( , ) -- ++(0, ); { } {(1- )* } ( , ) rectangle ++( , ); { + } {(1- )* } ( , ) rectangle ++( , ); {Stratification ensures that both the and the (shaded grey) have similar distributions of a binary key attribute .} When splitting a into a and a , stratification ensures that both sets have similar distributions of the key attribute. Without stratification, using a small may underrepresent or even completely miss with a rare attribute, leading to misleading performance estimates.\\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "stratum",
      "name": "stratum",
      "desc": "A stratum is a subset of that all possess a shared property (which could be a or a ). For example, in a weather , all measurements from the same weather station form one stratum.\\\\[0.5em] \\\\ { time,station,value,units\\\\ 2023-06-01 12:00,Helsinki,18.2,degC\\\\ 2023-06-01 13:00,Helsinki,18.5,degC\\\\ 2023-06-01 14:00,Helsinki,19.0,degC\\\\ 2023-06-01 12:00,Oulu,12.1,degC\\\\ 2023-06-01 13:00,Oulu,12.4,degC\\\\ 2023-06-01 14:00,Oulu,12.7,degC\\\\ 2023-06-01 12:00,Tampere,15.3,degC\\\\ 2023-06-01 13:00,Tampere,15.6,degC\\\\ 2023-06-01 14:00,Tampere,16.0,degC } Here, the rows for each station ( , , ) represent different strata.\\\\ See also: , , .",
      "deg": 7
    },
    {
      "id": "det",
      "name": "determinant",
      "desc": "The determinant of a square is a of its columns , i.e., it satisfies the following properties : Normalized: Multilinear: ( ^{(1)},\\, ,\\, + ,\\, ,\\, ^{( )} ) & = ( ^{(1)},\\, ,\\, ,\\, ,\\, ^{( )} ) \\\\ & + ( ^{(1)},\\, ,\\, ,\\, ,\\, ^{( )} ) Antisymmetric: We can interpret a as a linear transformation on . The determinant characterizes how volumes in (and their orientation) are altered by this transformation (see Fig. ) , . In particular, preserves orientation, reverses orientation, and collapses volume entirely, indicating that is non-invertible. The determinant also satisfies , and if is diagonalizable with , then . For the special cases (i.e., two-dimensional or 2-D) and (i.e., three-dimensional or 3-D), the determinant can be interpreted as an oriented area or volume spanned by the column of . [H] [x=2cm] (0,0) -- (1,0) node[below right] { }; (0,0) -- (0,1) node[above left] { }; [shift={(2.8,0)}] (A) at (1.5,0.5); (B) at (-0.2,1.2); (0,0) -- (A) node[below right] { }; (0,0) -- (B) node[above left] { }; (0,0) -- (A) -- ( ) -- (B) -- cycle; (A) -- ( ); (B) -- ( ); at (0.8,0.6) { }; (0.4,0.0) arc[start angle=0, end angle=35, radius=0.6]; (1.3,0.5) -- (2.4,0.5) node[midway, above] { }; {We can interpret a square as a linear transformation of into itself. The determinant characterizes how this transformation alters an oriented volume. } See also: , .",
      "deg": 6
    },
    {
      "id": "hessian",
      "name": "Hessian",
      "desc": "Consider a for which the second-order partial derivatives exist at . Then, the Hessian of at is defined as the of second-order partial derivatives of at , If the second-order partial derivatives are in a around , then the Hessian is a symmetric , i.e., for all . If additionally is , then the Hessian is a . [H] [x=0.5cm] [ hide axis, xmin=3, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.5, above right, yshift=3pt] { }; node[pos=0, below left] { }; node[pos=0, below left, yshift=10pt] { }; coordinates {(6, {2 + sin(deg(6))})}; coordinates {(6,0) (6,2.4)}; at (axis cs:6, -0.2) { }; {-1.5} {3} {2 + sin(deg( ))} {2 + sin(deg( ))} { A that is sufficiently at a point can be locally approximated by a which allows for a more accurate approximation compared to a linear . } The Hessian can be used to compute a that approximates locally around . \\\\ See also: , , , .",
      "deg": 10
    },
    {
      "id": "continuous",
      "name": "continuous",
      "desc": "A is continuous at a point if for every there is a such that for all with , it holds that . In other words, we can make arbitrarily close to by choosing sufficiently close to . If is continuous at every point , then is said to be continuous on . The notion of a continuous can be naturally extended to between general spaces .\\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "linearmap",
      "name": "linear map",
      "desc": "A linear is a that satisfies additivity, i.e., , and homogeneity, i.e., , for all and scalars . In particular, . Any linear can be represented as a multiplication for some . The collection of real-valued linear for a given dimension constitute a , which is used in many methods. \\\\ See also: , , , , , .",
      "deg": 17
    },
    {
      "id": "vector",
      "name": "vector",
      "desc": "A vector is an element of a . In the context of , a particularly important example of a is the , where is the (finite) dimension of the space. A vector can be represented as a list or one-dimensional (1-D) array of real numbers, i.e., with for . The value is the th entry of the vector . It can also be useful to view a vector as a that maps each index to a value , i.e., . This perspective is particularly useful for the study of . See Fig. for the two views of a vector. [H] [c]{0.48 } 2, --1, 3, 0, --2, 1 { } {0.48 } [ width=6.5cm, height=5cm, title={}, xlabel={index }, ylabel={ }, ymin=-3.5, ymax=3.5, xmin=0.5, xmax=6.5, xtick={1,2,3,4,5,6}, ytick={-3,-2,-1,0,1,2,3}, axis x line=bottom, axis y line=left, grid=both, major grid style={dotted, gray!60}, enlargelimits=0.1 ] +[ycomb, thick, mark=*] coordinates { (1,2) (2,-1) (3,3) (4,0) (5,-2) (6,1) }; at (2,-2.5) {(b)}; {Two equivalent views of a vector . (a) As a numeric array. (b) As a .} See also: , , .",
      "deg": 54
    },
    {
      "id": "vectorspace",
      "name": "vector space",
      "desc": "A space (also called linear space) is a collection of elements, called , along with the following two operations (see also Fig. ): 1) addition (denoted by ) of two ; and 2) multiplication (denoted by ) of a with a scalar that belongs to some number field (with a typical choice for this field being ). The defining property of a space is that it is closed under two specific operations. First, if , then . Second, if and , then . [H] [>=Stealth, scale=1.2] (O) at (0,0); (V) at (2,1.5); (W) at (1,3); (VplusW) at (3,4.5); (HalfV) at (1,0.75); (O) -- (V) node[pos=1, right] { }; (O) -- (W) node[pos=1, left] { }; (O) -- (VplusW) node[pos=0.99, above right] { }; (V) -- (VplusW); (W) -- (VplusW); (O) -- (HalfV) node[midway, right] { }; (O) circle (2pt) node[below left] { }; (V) circle (2pt); (W) circle (2pt); (VplusW) circle (2pt); (HalfV) circle (2pt); {A space is a collection of such that scaling and adding them always yields another in .} A common example of a space is the , which is widely used in to represent . We can also use to represent, either exactly or approximately, the used by an method. Another example of a space, which is naturally associated with every , is the collection of all real-valued , . \\\\ See also: , , , .",
      "deg": 23
    },
    {
      "id": "stochastic",
      "name": "stochastic",
      "desc": "We refer to a method as stochastic if it involves a random component or is governed by probabilistic laws. methods use randomness to reduce computational complexity (e.g., see ) or to capture in . \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "stochproc",
      "name": "stochastic process",
      "desc": "A process is a collection of defined on a common and indexed by some set , , . The index set typically represents time or space, allowing us to represent random phenomena that evolve across time or spatial dimensions—for example, sensor noise or financial time series. processes are not limited to temporal or spatial settings. For instance, random such as the or the can also be viewed as processes. Here, the index set consists of node pairs that index whose values encode the presence or weight of an edge between two nodes. Moreover, processes naturally arise in the analysis of , such as , which construct a sequence of . \\\\ See also: , , , , .",
      "deg": 15
    },
    {
      "id": "characteristicfunc",
      "name": "characteristic function",
      "desc": "The characteristic of a real-valued is the The characteristic uniquely determines the of . \\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "entropy",
      "name": "entropy",
      "desc": "Entropy quantifies the or unpredictability associated with a . For a discrete taking on values in a finite set with a mass , the entropy is defined as Entropy is maximized when all outcomes are equally likely, and minimized (i.e., zero) when the outcome is deterministic. A of the concept of entropy for continuous is . \\\\ See also: , .",
      "deg": 10
    },
    {
      "id": "diffentropy",
      "name": "differential entropy",
      "desc": "For a real-valued with a , the differential is defined as Differential can be negative and lacks some properties of for discrete-valued , such as invariance under a change of variables . Among all with a given and , is maximized by . \\\\ See also: , .",
      "deg": 10
    },
    {
      "id": "minimum",
      "name": "minimum",
      "desc": "Given a set of real numbers, the minimum is the smallest of those numbers. Note that for some sets, such as the set of negative real numbers, the minimum does not exist.",
      "deg": 14
    },
    {
      "id": "co-domain",
      "name": "co-domain",
      "desc": "The co-domain of a is the set into which maps elements of its domain . \\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "domain",
      "name": "domain",
      "desc": "The domain of a is the set from which takes its inputs. \\\\ See also: , , .",
      "deg": 7
    },
    {
      "id": "function",
      "name": "function",
      "desc": "A function between two sets and assigns each element exactly one element . We write this as where is the domain and the co-domain of . That is, a function defines a unique output for every input (see Fig. ). [H] [>=stealth, node distance=1.2cm and 2.5cm] {dot/.style={circle, fill=black, inner sep=1.2pt}} (A) [dot, label=left: ] {}; (B) [dot, below=of A, label=left: ] {}; (C) [dot, below=of B, label=left: ] {}; (1) [dot, right=4cm of A, label=right: ] {}; (2) [dot, below=of 1, label=right: ] {}; (3) [dot, below=of 2, label=right: ] {}; ; ; (A) -- (2); (B) -- (1); (C) -- (2); {A function mapping each element of the domain to exactly one element of the co-domain . }",
      "deg": 62
    },
    {
      "id": "map",
      "name": "map",
      "desc": "We use the term map as a synonym for . \\\\ See also: .",
      "deg": 46
    },
    {
      "id": "attention",
      "name": "attention",
      "desc": "Some applications involve composed of smaller units, referred to as . For example, a sentence consists of words, an image of pixel patches, and a network of nodes. In general, the that constitute a single are not independent of one another. Instead, each of a depends (or pays attention) to specific other . provide a principled framework for representing and analyzing such dependencies . Attention mechanisms use a more direct approach without explicit reference to a . The idea is to represent the relationship between two tokens and using a parameterized , where the are learned via a variant of . Practical attention mechanisms differ in their precise choice of attention as well as in the precise variant used to learn the . One widely used family of attention mechanisms defines the parameters in terms of two associated with each token , i.e., a query and a key . For a given token with query , and another token with key , the quantity quantifies the extent to which token attends to (or depends on) token (see Fig. ). [H] [>=stealth, node distance=0.2cm and 0.2cm, every node/.style={inner sep=2pt, font= }, baseline] (w1) [draw, fill=gray!10, rounded corners] {All}; (w2) [draw, fill=gray!10, right=of w1, rounded corners] {human}; (w3) [draw, fill=gray!10, right=of w2, rounded corners] {beings}; (w4) [draw, fill=gray!10, right=of w3, rounded corners] {are}; (w5) [draw, fill=gray!10, right=of w4, rounded corners] {born}; (w6) [draw, fill=gray!10, right=of w5, rounded corners] {free}; (w7) [draw, fill=gray!10, right=of w6, rounded corners] {and}; (w8) [draw, fill=blue!20, right=of w7, rounded corners] {equal}; (labeli) { \\\\ }; (labelii) { \\\\ }; (eqTop) [above=1.8cm of w8] {}; (w8.north) .. controls +(up:1.0cm) and +(up:1.0cm) .. (w6.north); (w8.north) .. controls +(up:1.2cm) and +(up:1.0cm) .. (w5.north); (w8.north) .. controls +(up:1.8cm) and +(up:1.0cm) .. node[midway, text=black, above] { } (w1.north); {Attention mechanisms learn a parameterized to measure how much token attends to token . One widely used construction of uses query and key , denoted by and , assigned to each token . } See also: , , .",
      "deg": 12
    },
    {
      "id": "transformer",
      "name": "transformer",
      "desc": "In the context of , the term transformer refers to an that uses some form of mechanism to capture dependencies among . The mechansim is what sets transformers apart from previous used for sequential such as . A transformer often combines several that are combined via more traditional architectures. \\\\ See also: , .",
      "deg": 10
    },
    {
      "id": "rnn",
      "name": "recurrent neural network (RNN)",
      "desc": "A RNN is a specific type of that is designed for processing that consists of a sequence of . An RNN maintains an internal hidden state that is updated recurrently as new are processed. This recurrent dependence allows information to propagate across time steps, making RNNs suitable for tasks such as speech recognition, language modeling, or time series prediction. However, their inherently sequential computation limits parallelization and is challenging for . Variants like the long short-term memory (LSTM) and gated recurrent unit (GRU) mitigate these problems.",
      "deg": 5
    },
    {
      "id": "llm",
      "name": "large language model (LLM)",
      "desc": "A LLM is an umbrella term for methods that use high-dimensional (with billions of ) trained on large collections of text . LLMs are used to analyze or generate sequences of which constitute text . Many current LLMs use some variant of a that is trained via self-supervised learning: The training is based on the task of predicting a few words that are intentionally removed from a large text corpus. Thus, we can construct simply by selecting some words from a given text as and the remaining words as of . This construction requires very little human supervision and allows for generating sufficiently large for LLMs.\\\\ See also: , , .",
      "deg": 13
    },
    {
      "id": "selfsupervisedlearning",
      "name": "self-supervised learning",
      "desc": "Self-supervised learning uses some of the of a as its . For example, if a consists of a sentence within a text document, we an use the last word of the sentence as the which is to be predicted from all the previous words (which form the of the ). A main application of self-supervised learning is in for the training of from large collections of text . \\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "optproblem",
      "name": "optimization problem",
      "desc": "An optimization problem is a mathematical structure consisting of an defined over an optimization variable , together with a feasible set . The co-domain is assumed to be ordered, meaning that for any two elements , we can determine whether , , or . The goal of optimization is to find those values for which the objective is extremal—i.e., minimal or maximal , , . \\\\ See also: .",
      "deg": 16
    },
    {
      "id": "optmethod",
      "name": "optimization method",
      "desc": "An optimization method is an that reads in a representation of an and delivers an (approximate) solution as its output , , . \\\\ See also: , .",
      "deg": 17
    },
    {
      "id": "convexopt",
      "name": "convex optimization",
      "desc": "Convex optimization studies the formulation, properties, and efficient solution methods for . A (defined on the ) consists of a and a constraint set for the optimization variable . It can be written compactly as Alternatively, a can be expressed in terms of constraint as _{ ^{ }} & f( ) \\\\ & g_{ }( ) 0, =1,\\, ,\\,k. [>=stealth, scale=1.0] (-3,0) -- (5.2,0) node[below] { }; (0,-0.2) -- (0,4.2) node[left] { }; plot ({ },{exp(- )}); (-1,3) -- (-1,{exp(1)}) -- plot[domain=-1:3] ({ },{exp(- )}) -- (3,3) -- cycle; (0,1) circle (1.6pt) node[left] { }; plot ({ },{(2/exp(1)) - (1/exp(1))* }); (1,{1/exp(1)}) circle (1.2pt); at (2.6,2.5) { }; [below,yshift=-3pt] at (0,-0.2) { }; {A can be represented by a set that consists of objective values and constraint values that are achievable, i.e., by some . The optimal value of the is the smallest for which . } The formulation lends, in turn, to the epigraph form of with the set \\{ ( ,t) & ^{ } : f( ) t, \\, \\\\ & g_{ }( ) c_{ }, \\, = 1, ,k, ^{ } \\}. It can be shown that, since are , is a set . The set fully characterizes the ~ and can be interpreted as the of the ~ restricted to the feasible region defined by the constraint .\\\\ See also: , , .",
      "deg": 7
    },
    {
      "id": "newtonmethod",
      "name": "Newton's method",
      "desc": "Newton's method is an iterative for finding local or of a . Like , Newton's method also computes a new estimate by optimizing a local approximation of around the current estimate . In contrast to , which use the to build a local linear approximation, Newton's method uses the to build a local quadratic approximation. In particular, starting from an initial estimate , Newton's method iteratively updates the estimate according to Here, is the , and is the of the . Since using a as local approximation is more accurate than using a linear (which is a special case of a ), Newton's method tends to converge faster than (see Fig. ). However, this faster comes at the increased computational complexity of the iterations. Indeed, each iteration of Newton's method requires the inversion of the . [H] [samples=200,smooth] (-5,-2) rectangle (5,5); plot[domain=0:360] ({1.5*cos( )*sqrt(20/(sin(2* )+2))},{1.5*sin( )*sqrt(20/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(16/(sin(2* )+2))},{1.5*sin( )*sqrt(16/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(12/(sin(2* )+2))},{1.5*sin( )*sqrt(12/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(8/(sin(2* )+2))},{1.5*sin( )*sqrt(8/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(4/(sin(2* )+2))},{1.5*sin( )*sqrt(4/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(1/(sin(2* )+2))},{1.5*sin( )*sqrt(1/(sin(2* )+2))}); plot[domain=0:360] ({1.5*cos( )*sqrt(0.0625/(sin(2* )+2))},{1.5*sin( )*sqrt(0.0625/(sin(2* )+2))}); (-3.5,4.5) -- (-3.3,3.8); (-3.3,3.8) -- (-3,3.1); (-3,3.1) -- (-2.6,2.4); (-2.6,2.4) -- (-2.1,1.8); (-2.1,1.8) -- (-1.5,1.3); (-1.5,1.3) -- (-0.9,0.9); (-0.9,0.9) -- (-0.4,0.5); (-0.4,0.5) -- (-0.1,0.2); at (-3.5,4.5) {start}; at (0.5,3) { }; (-3.5,4.5) -- (-2,2.5); (-2,2.5) -- (-0.8,0.8); (-0.8,0.8) -- (0,0.1); at (1.5,4) {Newton's method}; at (0,0) [circle,fill,inner sep=1pt,label=below: ] {}; {Comparison of (blue) and Newton's method (red) paths toward the of a . } See also: , , , .",
      "deg": 14
    },
    {
      "id": "hilbertspace",
      "name": "Hilbert space",
      "desc": "A Hilbert space is a complete inner product space. Thus, is a equipped with an inner product . The inner product induces a norm via . Furthermore, is complete in the sense that every in converges to a limit that is also contained in . [H] [scale=3] (0,0) circle (1); (0,0) -- (1,0) node[below right] { }; (0,0) -- ({cos( )},{sin( )}) node[above] { }; (P) at ({cos( )},0); ({cos( )},{sin( )}) -- (P); (0,0) -- (P) node[pos=0.5,below] { }; ( ) -- (P) -- ( ); at ({cos(- )},{sin(- )}) { }; {For two unit-norm vectors the inner product is the expantion coefficient for the projection of onto the subspace spanned by . The absolute value measures the norm of this projection. } One important example of a Hilbert space is the with the inner product \\\\ See also: .",
      "deg": 5
    },
    {
      "id": "cauchysequence",
      "name": "Cauchy sequence",
      "desc": "A Cauchy is a in a such that the elements become arbitrarily close to each other eventually. In other words , [x=1cm,y=4cm] (-0.3,{ - }) rectangle ( +0.6,{ + }); (4.5,{ - }) -- (4.5,{ + }) node[above, right] { }; (-0.3, ) -- ( +0.6, ) node[right] { }; (0,1.0000) circle (1.2pt) node [right] { }; (1,1.5000) circle (1.2pt); (2,1.4167) circle (1.2pt); (3,1.4142) circle (1.2pt); (4,1.41421) circle (1.2pt); (5,1.4142136) circle (1.2pt); (6,1.41421356) circle (1.2pt); ( ,0.88) -- ( ,1.655); at ( ,0.8) { }; at (5,0.9) { }; {A Cauchy in the . This is generated by a used to approximate . For all , the elements lie within a band of width . Note that the does not converge in since . } Fig.\\ shows a Cauchy sequence in the of rational numbers. \\\\ See also: , .",
      "deg": 5
    },
    {
      "id": "nonexpansiveop",
      "name": "non-expansive operator",
      "desc": "An operator defined on a Hilbert space is called non-expansive if it does not increase distances. In other words, {2} {2} , ' . See also: , .",
      "deg": 3
    },
    {
      "id": "fixedpointiter",
      "name": "fixed-point iteration",
      "desc": "A fixed-point iteration is an iterative method for solving an . It constructs a by repeatedly applying an operator , i.e., ^{( +1)} = ^{( )} =0, \\,1, \\, . The operator is chosen such that any of its fixed points is a solution to the given . For example, given a and , the fixed points of the coincide with the minimizers of . In general, for a given with solution , there are many different whose fixed points are . Clearly, we should use an in that reduces the distance to a solution such that { { ^{( +1)} - }{2}}_{ { }{=} { ^{( )} - }{2}} { ^{( )} - }{2}. Thus, we require to be at least a , i.e., the iteration should not result in worse that have a larger distance to a solution . Furthermore, each iteration should also make some progress, i.e., reduce the distance to a solution . This requirement can be made precise using the notion of a , . The is a if, for some , {2} {2} , '. For a , the fixed-point iteration generates a sequence that converges quite rapidly. In particular , { ^{( )} - }{2} ^{ } { ^{(0)} - }{2}. Here, is the distance between the initialization and the solution . It turns out that a fixed-point iteration with a firmly non-expansive operator is guaranteed to converge to a fixed-point of . Fig. depicts examples of a firmly non-expansive operator, a non-expansive operator, and a . All of these operators are defined on the 1-D space . Another example of a firmly non-expansive operator is the of a , . {rgb}{0.0, 0.5, 0.0} [H] [scale=1.5] (-2,0) -- (2,0) node[right] { }; (0,-2) -- (0,2) node[above] { }; at (2.1,2.2) { }; at (1.9,-1.5) { }; at (1.5,1.2) { }; (1,-2) -- (1,2); (-2,1) -- (2,1); (-2,-1) -- (2,-1); (-1,-2) -- (-1,2); at (1,0) { }; at (0,-1) { }; plot( ,{0.5* + 1}); plot( ,{- }); plot( ,{-1}); plot( ,{ }); plot( ,{1}); {Example of a non-expansive operator , a firmly non-expansive operator , and a . } See also: , , , , , , .",
      "deg": 17
    },
    {
      "id": "ergraph",
      "name": "Erd s–R\\'enyi graph (ER graph)",
      "desc": "An ER {Erd s–R\\'enyi graph (ER graph)} is a for defined over a given node set . One way to define the ER is via the collection of binary , for each pair of different nodes . A specific of an ER contains an edge if and only if . The ER is parameterized by the number of nodes and the . \\\\ See also: , , , , , .",
      "deg": 7
    },
    {
      "id": "attack",
      "name": "attack",
      "desc": "An attack on an system refers to an intentional action—either active or passive—that compromises the system's integrity, availability, or confidentiality. Active attacks involve perturbing components such as (via ) or communication links between within an application. Passive attacks, such as , aim to infer without modifying the system. Depending on their goal, we distinguish among , attacks, and . \\\\ See also: , , , , .",
      "deg": 14
    },
    {
      "id": "privattack",
      "name": "privacy attack",
      "desc": "A privacy on an system aims to infer of individuals by exploiting partial access to a trained . One form of a privacy is .\\\\ See also: , , , , .",
      "deg": 13
    },
    {
      "id": "epigraph",
      "name": "epigraph",
      "desc": "The epigraph of a real-valued is the set of points lying on or above its (see Fig. ), i.e., A is if and only if its epigraph is a set , . [H] [scale=1.0] [ axis lines = middle, xlabel = , ylabel = {}, xmin=-2, xmax=2, ymin=0, ymax=4.5, samples=100, domain=-1.5:1.5, thick, width=8cm, height=6cm, grid=none, axis on top, ] node [pos=0.85, anchor=south west, xshift=5pt] { }; ; (axis cs:-1.5,4) -- (axis cs:1.5,4); [ blue!20, opacity=0.6, draw=none, ] fill between [ of=f and top, soft clip={domain=-1.5:1.5}, ]; at (axis cs:-1.0,2.3) { }; {Epigraph of the (i.e., the shaded area). } See also: , .",
      "deg": 5
    },
    {
      "id": "nullspace",
      "name": "nullspace",
      "desc": "The nullspace of a , denoted by , is the set of all such that Consider a method that uses the to transform a of a into a new . The nullspace characterizes all directions in the original along which the transformation remains unchanged. In other words, adding any from the nullspace to a does not affect the transformed representation . This property can be exploited to enforce invariances in the (computed from ). Fig.\\ illustrates one such invariance. It shows rotated versions of two handwritten digits, which approximately lie along 1-D curves in the original . These curves are aligned with a direction . To ensure that the trained is invariant to such rotations, we can choose the transformation such that . This ensures that , and hence the resulting , is approximately insensitive to rotations of the input image. [H] { Rotated handwritings of two different digits. The rotations are approximately aligned along straight lines parallel to the . For a binary distinguishing between these digits, a natural choice is a linear with a whose nullspace contains , i.e., . } See also: , , . \\\\ Python demo: {click me}",
      "deg": 10
    },
    {
      "id": "maximum",
      "name": "maximum",
      "desc": "The maximum of a set of real numbers is the greatest element in that set, if such an element exists. A set has a maximum if it is bounded above and attains its . \\\\ See also: .",
      "deg": 9
    },
    {
      "id": "supremum",
      "name": "supremum (or least upper bound)",
      "desc": "The supremum of a set of real numbers is the smallest number that is greater than or equal to every element in the set. More formally, a real number is the supremum of a set if: 1) is an upper bound of ; and 2) no number smaller than is an upper bound of . Every non-empty set of real numbers that is bounded above has a supremum, even if it does not contain its supremum as an element .",
      "deg": 1
    },
    {
      "id": "discrepancy",
      "name": "discrepancy",
      "desc": "Consider an application with represented by an . methods use a discrepancy measure to compare from at nodes , connected by an edge in the . \\\\ See also: , , .",
      "deg": 8
    },
    {
      "id": "FedRelax",
      "name": "federated relaxed (FedRelax)",
      "desc": "An . \\\\ See also: , .",
      "deg": 2
    },
    {
      "id": "fedavg",
      "name": "federated averaging (FedAvg)",
      "desc": "FedAvg refers to a family of iterative . It uses a server-client setting and alternates between clientwise retraining, followed by the aggregation of updated at the server . The local update at client at time starts from the current provided by the server and typically amounts to executing few iterations of . After completing the local updates, they are aggregated by the server (e.g., by averaging them). Fig. illustrates the execution of a single iteration of FedAvg. [H] [>=Stealth, node distance=1cm and 1.5cm, every node/.style={font= }] = [circle, fill=black, minimum size=6pt, inner sep=0pt] = [circle, draw=black, minimum size=6pt, inner sep=0pt] (label1) at (0,3.5) {broadcast}; (label2) {local update}; (label3) {aggregate}; (s1) at (label1 |- 0,2.5) {}; (c1l) at ( ) {}; (c1r) at ( ) {}; (dots1) at ( ) { }; (s1) -- (c1l) node[midway,left] { }; (s1) -- (c1r) node[midway,right] { }; (s1) -- (dots1); (s2) at (label2 |- 0,2.5) {}; (c2l) at ( ) {}; (c2r) at ( ) {}; (dots2) at ( ) { }; ; ; (s3) at (label3 |- 0,2.5) {}; ; (c3l) at ( ) {}; (c3r) at ( ) {}; (dots3) at ( ) { }; (c3l) -- (s3) node[midway,left] { }; (c3r) -- (s3) node[midway,right] { }; (dots3) -- (s3); {Illustration of a single iteration of FedAvg, which consists of broadcasting by the server, performing local updates at clients, and aggregating the updates by the server. } See also: , , , .",
      "deg": 6
    },
    {
      "id": "FedGD",
      "name": "federated gradient descent (FedGD)",
      "desc": "An that can be implemented as message passing across an . \\\\ See also: , , , , .",
      "deg": 5
    },
    {
      "id": "FedSGD",
      "name": "federated stochastic gradient descent (FedSGD)",
      "desc": "An that can be implemented as message passing across an . \\\\ See also: , , , , , .",
      "deg": 6
    },
    {
      "id": "hfl",
      "name": "horizontal federated learning (HFL)",
      "desc": "HFL uses constitut\\-ed by different but uses the same to characterize them . For example, weather forecasting uses a network of spatially distributed weather (observation) stations. Each weather station measures the same quantities, such as daily temperature, air pressure, and precipitation. However, different weather stations measure the characteristics or of different spatiotemporal regions. Each spatiotemporal region represents an individual , each characterized by the same (e.g., daily temperature or air pressure).\\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "dimred",
      "name": "dimensionality reduction",
      "desc": "Dimensionality reduction refers to methods that learn a transformation of a (typically large) set of raw into a smaller set of informative . Using a smaller set of is beneficial in several ways: It typically reduces the of , as reducing the number of often reduces the of a . Using fewer means less computation for the training of . As a case in point, methods need to invert a whose size is determined by the number of . Dimensionality reduction is also instrumental for visualization. For example, we can learn a transformation that delivers two , which we can use, in turn, as the coordinates of a . Fig.\\ depicts the of handwritten digits that are placed using transformed . Here, the are naturally represented by a large number of greyscale values (one value for each pixel). [H] [scale=1] (-0.5,0) -- (5.5,0) node[right] { }; (0,-0.5) -- (0,4.5) node[above] { }; / / in { 1.2/0.5/3, 0.8/2.0/8, 2.5/1.8/1, 3.8/3.5/6, 4.2/0.7/9, 2.8/3.0/7, 1.5/3.8/2 }{ at ( , ) { }; } {Example of dimensionality reduction: High-dimensional image data (e.g., high-resolution images of handwritten digits) embedded into 2-D using learned and visualized in a .} See also: , , , , , .",
      "deg": 18
    },
    {
      "id": "diagnosis",
      "name": "diagnosis",
      "desc": "Consider an -based method that resulted in a trained (or learned ) . We can diagnose the method by comparing the with the incurred by on the and the . [htbp] [ycomb] plot coordinates{(0,3)}; [below] at (0,0) { } ; plot coordinates{(5,5)}; [below] at (5,0) { } ; (-1,2) -- (7,2) node[right,text width=5cm]{ \\\\ (e.g., , existing ML methods or human performance)}; {We can diagnose a -based method by comparing its with its . Ideally both are on the same level as a . } \\\\ See also: , , , .",
      "deg": 13
    },
    {
      "id": "ml",
      "name": "machine learning (ML)",
      "desc": "ML aims to predict a from the of a . ML methods achieve this by learning a from a (or ) through the minimization of a , . One precise formulation of this principle is . Different ML methods are obtained from different design choices for (i.e., their and ), the , and the . \\\\ See also: , , .",
      "deg": 133
    },
    {
      "id": "reinforcementlearning",
      "name": "reinforcement learning (RL)",
      "desc": "RL refers to an setting where we can only evaluate the usefulness of a single (i.e., a choice of ) at each time step . In particular, RL methods apply the current to the of the newly received . The usefulness of the resulting is quantified by a signal (see Fig. ). [H] [scale=1] (-2, 0) -- (6, 0); at (6.3, 0) { }; plot ( -3, {-0.2*( )^2 + 2}); at (0-3, {-0.2*(0)^2 + 2}) { }; (1.5-3, {-0.2*(1.5)^2 + 2}) circle (2pt); at (1.5-3, -0.3) { }; (1.5-3, 0) -- (1.5-3, {-0.2*(1.5)^2 + 2}); plot ( , {-0.15*( - 2)^2 + 3}); at (3, {-0.15*(3 - 2)^2 + 3}) { }; (2, {-0.15*(2 - 2)^2 + 3}) circle (2pt); at (2, -0.3) { }; (2, 0) -- (2, {-0.15*(3 - 2)^2 + 3}); plot ( +2, {-0.1*( - 4)^2 + 1.5}); at (4.5+2, {-0.1*(4.5 - 4)^2 + 1.5}) { }; (3.5+2, {-0.1*(3.5 - 4)^2 + 1.5}) circle (2pt); at (3.5+2, -0.3) { }; (3.5+2, 0) -- (3.5+2, {-0.1*(3.5 - 4)^2 + 1.5}); {Three consecutive time steps with corresponding . During time step , an RL method can evaluate the only for one specific , resulting in the signal . } In general, the depends also on the previous for . The goal of RL is to learn , for each time step , such that the (possibly discounted) cumulative is maximized , . \\\\ See also: , , .",
      "deg": 14
    },
    {
      "id": "featlearn",
      "name": "feature learning",
      "desc": "Consider an application with characterized by raw . learning refers to the task of learning a that reads in the of a and delivers new from a new . Different learning methods are obtained for different design choices of , for a of potential , and for a quantitative measure of the usefulness of a specific . For example, uses , with , and a measures the usefulness of a specific by the linear reconstruction error incurred on a such that \\\\ See also: , , , .",
      "deg": 17
    },
    {
      "id": "autoencoder",
      "name": "autoencoder",
      "desc": "An autoencoder is an method that simultaneously learns an encoder and a decoder . Different autoencoders use different , e.g., with different architectures. The special case of an autoeencoder using (vector-valued) for results in . [H] [>=Latex, thick, node distance=1.6cm] (x) { }; (enc) { }; (z) { }; (dec) { }; (xhat) { }; (x) -- (enc); (enc) -- node[above] { } (z); (z) -- (dec); (dec) -- node[above] { } (xhat); The training of the encoder and decoder can be implemented via using a that measures the deviation of the reconstructed from the original . \\\\ See also: , .",
      "deg": 11
    },
    {
      "id": "vfl",
      "name": "vertical federated learning (VFL)",
      "desc": "VFL refers to applications where have access to different of the same set of . Formally, the underlying global is We denote by , for , the complete for the . Each observes only a subset of , resulting in a with Some of the may also have access to the , for , of the global (see Fig. ). [H] [every node/.style={anchor=base}] / in {1/1, 2/2, 4/ } { {-1.2*( -1)} (x 1) at (0, ) { }; (x 2) at (1.6, ) { }; (dots ) at (3.2, ) { }; (x 3) at (4.8, ) { }; (y ) at (6.4, ) { }; } (-0.6,0.6) rectangle (6.9,-4.2); at (3.1,0.9) { }; (-0.9,0.9) rectangle (2.1,-4.0); at (0.25,1.0) { }; ( ) rectangle ( ); at ( ) { }; {VFL uses that are derived from the of a common global . The differ in the choice of used to characterize the . } One potential application of VFL is to enable collaboration between different healthcare providers. Each provider collects distinct types of measurements—such as blood values, electrocardiography, and lung X-rays—for the same patients. Another application is a national social insurance system, where health records, financial indicators, consumer behavior, and mobility are collected by different institutions. VFL enables joint learning across these parties while allowing well-defined levels of . \\\\ See also: , .",
      "deg": 11
    },
    {
      "id": "interpretability",
      "name": "interpretability",
      "desc": "An method is interpretable for a human user if they can comprehend the decision process of the method. One approach to develop a precise definition of interpretability is via the concept of simulatability, i.e., the ability of a human to mentally simulate the behavior , , , , . The idea is as follows: If a human user understands an method, then they should be able to anticipate its on a . We illustrate such a in Fig. , which also depicts two learned and . The method producing the is interpretable to a human user familiar with the concept of a . Since corresponds to a , the user can anticipate the of on the . In contrast, the method delivering is not interpretable, because its behavior is no longer aligned with the user’s . [H] [x=1.5cm, y=1cm] (0,0.5) -- (7.7,0.5) node[below, xshift=-1cm] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ + }); plot ({ },{ + -( -4)*0.5}); at (7.2, { 7.2 + }) { }; at (7.2, { 7.2 + - 0.5*(7.2 - 4)}) { }; / / / in { 1.2/1.0/blue/6, 1.4/1.0/blue/6, 1.7/1.0/blue/6, 2.2/3.9/blue/12, 2.6/4.2/blue/12, 3.0/4.4/blue/12 }{ (pt) at ( , ); at (pt) {}; }, color= , thick] ( , { + }) -- (pt); } / / / in { 5.7/2.6/red/12, 5.9/2.6/red/12, 6.2/2.6/red/12 }{ (pt) at ( ,{ + }); at (pt) {}; } (4.2, 1.7) circle (0.1cm) node [black,xshift=0.2cm,anchor=west] { }; (4.2, 1.2) circle (0.1cm) node [black,xshift=0.2cm,anchor=west] { }; {We can assess the interpretability of trained and by comparing their to pseudo- generated by a human user for . } The notion of interpretability is closely related to the notion of , as both aim to make methods more understandable for humans. In the context of Fig. , interpretability of an method requires that the human user can anticipate its on an arbitrary . This contrasts with , where the user is supported by external —such as saliency or reference examples from the —to understand the of on a specific . \\\\ See also: , , , .",
      "deg": 18
    },
    {
      "id": "multitask learning",
      "name": "multitask learning",
      "desc": "Multitask learning aims to leverage relations between different . Consider two obtained from the same of webcam snapshots. The first task is to predict the presence of a human, while the second task is to predict the presence of a car. It may be useful to use the same structure for both tasks and only allow the of the final output to be different. \\\\ See also: , , , , .",
      "deg": 7
    },
    {
      "id": "learningtask",
      "name": "learning task",
      "desc": "Consider a consisting of multiple . For example, can be a collection of images in an image database. A learning task is defined by specifying those properties (or attributes) of a that are used as its and . Given a choice of and , a learning task leads to an instance of and can thus be represented by the associated for . Importantly, multiple distinct learning tasks can be constructed from the same by selecting different sets of and (see Fig. ). [H] [t]{0.95 } [t]{0.45 } Task 1 ( ): \\\\ are the RGB values of all image pixels, and the is the number of cows depicted. [t]{0.45 } Task 2 ( ): \\\\ include the average green intensity of the image, and the indicates whether cows should be moved to another location (i.e., yes/no). {Two learning tasks constructed from a single image . These tasks differ in selection and choice of (i.e., the objective), but are both derived from the same .} Different learning tasks arising from the same underlying are often coupled. For example, when a is used to generate , statistical dependencies among different induce dependencies among the corresponding learning tasks. In general, solving learning tasks jointly, e.g., using methods, tends to be more effective than solving them independently (thereby ignoring dependencies among learning tasks) , , . \\\\ See also: , .",
      "deg": 15
    },
    {
      "id": "explainability",
      "name": "explainability",
      "desc": "We define the (subjective) explainability of an method as the level of simulatability of the delivered by an system to a human user. Quantitative measures for the (subjective) explainability of a trained can be constructed by comparing its with the provided by a user on a , . Alternatively, we can use for and measure the explainability of a trained via the conditional (or differential) of its , given the user's , . \\\\ See also: , .",
      "deg": 12
    },
    {
      "id": "lime",
      "name": "local interpretable model-agnostic explanations (LIME)",
      "desc": "Consider a trained (or learned ) , which maps the of a to the . LIME is a technique for explaining the behavior of , locally around a with . The is given in the form of a local approximation of (see Fig. ). This approximation can be obtained by an instance of with a carefully designed . In particular, the consists of with centered around and the (pseudo-) . Note that we can use a different for the approximation from the original . For example, we can use a to locally approximate a . Another widely used choice for is the . [H] [ axis lines=middle, xlabel={ }, ylabel={ }, xtick= , ytick= , xmin=0, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.85, above right,yshift=3pt] { }; coordinates {(3,0) (3,6)}; node[pos=0.9, above] { }; coordinates {(3, {2 + sin(deg(3))})}; at (axis cs:3,-0.3) { }; {To explain a trained , around a given , we can use a local approximation . } See also: , , , , , , , .",
      "deg": 15
    },
    {
      "id": "linmodel",
      "name": "linear model",
      "desc": "Consider an application involving , each represented by a numeric . A linear defines a consisting of all real-valued from to such that \\{ : ^{ } ( ) = ^{ } ^{ } \\}. Each value of defines a different , corresponding to the number of used to compute the . The choice of is often guided not only by (e.g., fewer features reduce computation) and (e.g., more features typically reduce and ), but also by . A linear using a small number of well-chosen is generally considered more interpretable , . The linear is attractive because it can typically be trained using scalable , . Moreover, linear often permit rigorous statistical analysis, including fundamental limits on the achievable . They are also useful for analyzing more complex nonlinear such as . For instance, a can be viewed as the composition of a —implemented by the input and hidden —and a linear in the output . Similarly, a can be interpreted as applying a one-hot-encoded based on , followed by a linear that assigns a to each region. More generally, any trained that is at some can be locally approximated by a . Fig.~ illustrates such a local linear approximation, defined by the . Note that the is only defined where is . To ensure in the context of , one may prefer whose associated is Lipschitz continuous. A classic result in mathematical analysis—Rademacher’s Theorem—states that if is Lipschitz continuous with some constant over an open set , then is almost everywhere in . [H] [x=0.5cm] [ hide axis, xmin=-3, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.5, above right, yshift=3pt] { }; node[pos=0.95, above right] { }; coordinates {(6, {2 + sin(deg(6))})}; coordinates {(6,0) (6,2.4)}; at (axis cs:6, -0.2) { }; {-1.5} {3} {2 + sin(deg( ))} {2 + sin(deg( ))} coordinates {( , ) ( , )}; (axis cs: , ) -- (axis cs: ,0); (axis cs: , ) -- (axis cs: ,0); (axis cs: , ) -- (axis cs:0, ); (axis cs: , ) -- (axis cs:0, ); (axis cs: ,-0.4) -- node[below] { } (axis cs: ,-0.4); (axis cs:-2.4, ) -- node[left] { } (axis cs:-2.4, ); { A trained that is at a point can be locally approximated by a . This local approximation is determined by the .} See also: , , , , .",
      "deg": 53
    },
    {
      "id": "gradstep",
      "name": "gradient step",
      "desc": "Given a real-valued and a , the step updates by adding the scaled negative to obtain the new (see Fig. ) - f( ). Mathematically, the step is an operator that is paramet\\-rized by the and the . [H] [scale=0.8] (-4,0) grid (4,4); plot ( , {(1/4)* }); plot ( , {2* - 4}); (4,4) -- node[right] { } (4,2); (4,4) -- node[above] { } (2,4); (4,2) -- node[below] { } (3,2) ; at (-4.1, 4.1) { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; {The basic step maps a given to the updated . It defines an operator .} Note that the step optimizes locally—in a whose size is determined by the —a linear approximation to the . A natural of is to locally optimize the itself—instead of its linear approximation—such that = _{ ' ^{ }} f( ')\\!+\\! { } {2}^2. We intentionally use the same symbol for the in as we used for the in . The larger the we choose in , the more progress the update will make toward reducing the value . Note that, much like the step , the update also defines an operator that is parameterized by the and the . For a , this operator is known as the of . \\\\ See also: , , , , , , , , , , .",
      "deg": 27
    },
    {
      "id": "operator",
      "name": "operator",
      "desc": "An operator is a with and having a specific mathematical structure such as a , or a . Many methods involve operators with and being an . \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "contractop",
      "name": "contraction operator",
      "desc": "An operator is a contraction if, for some , {2} {2} , ' ^{ }.",
      "deg": 2
    },
    {
      "id": "proxop",
      "name": "proximal operator",
      "desc": "Given a , we define its proximal operator as , As illustrated in Fig. , evaluating the proximal operator amounts to minimizing a penalized variant of . The penalty term is the scaled squared Euclidean distance to a given (which is the input to the proximal operator). The proximal operator can be interpreted as a of the , which is defined for a . Indeed, taking a with at the current is the same as applying the proximal operator of the and using . [H] [scale=0.8] plot ( , {(1/4)* }) node[above right] { }; plot ( , {2*( - 2)*( - 2)}) node[below right] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; {The proximal operator updates a by minimizing a penalized version of the . The penalty term is the scaled squared Euclidean distance between the optimization variable and the given . } See also: , , , , , , .",
      "deg": 11
    },
    {
      "id": "proximable",
      "name": "proximable",
      "desc": "A for which the can be computed efficiently is sometimes referred to as proximable or simple . \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "connected",
      "name": "connected",
      "desc": "An is connected if for every non-empty subset we can find at least one edge connecting a node in with some node in . [H] (A1) at (0, 1.5) {}; ; (B1) [below right=0.8cm and 0.5cm of A1] {}; (C1) [below left=0.8cm and 0.5cm of A1] {}; [line width=1 pt] (A1) -- (B1); [xshift=3.5cm] (A2) at (0, 1.5) {}; ; (B2) [below right=0.8cm and 0.5cm of A2] {}; (C2) [below left=0.8cm and 0.5cm of A2] {}; [line width=1 pt] (A2) -- (B2); [line width=1 pt] (B2) -- (C2); See also: , .",
      "deg": 2
    },
    {
      "id": "mvndist",
      "name": "multivariate normal distribution",
      "desc": "The multivariate normal distribution, which is denoted by , is a fundamental for numerical of fixed dimension . It defines a family of over -valued ~ , , . Each distribution in this family is fully specified by its and . When the is invertible, the corresponding is characterized by the following : Note that this is only defined when is invertible. More generally, any admits the following representation: where is a and satisfies . This representation remains valid even when is singular, in which case is not full rank~ . The family of multivariate normal distributions is exceptional among for numerical quantities, at least for the following reasons. First, the family is closed under affine transformations, i.e., Second, the maximizes the among all distributions with the same ~ . \\\\ See also: , , , , .",
      "deg": 18
    },
    {
      "id": "stdnormvec",
      "name": "standard normal vector",
      "desc": "A standard normal is a random whose entries are . It is a special case of a , . \\\\ See also: , , , , .",
      "deg": 6
    },
    {
      "id": "earlystopping",
      "name": "early stopping",
      "desc": "Consider an -based method that uses an iterative (such as ) to learn via minimizing the on a given . Early stopping refers to terminating the iterations even if they still substantially decrease the on the . Instead of monitoring the (which is the on the ), early stopping monitors the incurred by the in each iteration. Early stopping can be interpreted as an implementation of via pruning. Indeed, terminating an iterative after a small number of iterations restricts the set of that can be reached from the initialization (see Fig.\\ ). [htbp] [>=Stealth, scale=2] (0,0) circle (0.6pt) node[above] { }; at (-0.4,0) { }; at (-1.2,0) { }; at (-2,0) { }; (0,0) ellipse (0.8 and 0.4); (0,0) ellipse (1.6 and 0.8); (0,0) -- (0.8,0.) node [pos=0.6,above] { step}; (0.0,0.0) -- (0,-0.8) node [pos=0.9,right] { steps}; {A for using a defines a nested of effective . The effective is determined by all that can be reached from the initialization within . } \\\\ See also: , , .",
      "deg": 15
    },
    {
      "id": "statasp",
      "name": "statistical aspects",
      "desc": "By statistical aspects of an method, we refer to (properties of) the of its output under a for the fed into the method. \\\\ See also: , , , .",
      "deg": 8
    },
    {
      "id": "compasp",
      "name": "computational aspects",
      "desc": "By computational aspects of an method, we mainly refer to the computational resources required for its implementation. For example, if an method uses iterative optimization techniques to solve , then its computational aspects include: 1) how many arithmetic operations are needed to implement a single iteration (i.e., a ); and 2) how many iterations are needed to obtain useful . One important example of an iterative optimization technique is . \\\\ See also: , , , , .",
      "deg": 8
    },
    {
      "id": "zerooneloss",
      "name": "loss",
      "desc": "The measures the quality of a that delivers a (e.g., via thresholding ) for the of a with . It is equal to if the is correct, i.e., when . It is equal to if the is wrong, i.e., when . \\\\ See also: , , , , , , .",
      "deg": 9
    },
    {
      "id": "probability",
      "name": "probability",
      "desc": "We assign a probability value, typically chosen in the interval , to each that can occur in a , , , . \\\\ See also: , .",
      "deg": 28
    },
    {
      "id": "underfitting",
      "name": "underfitting",
      "desc": "Consider an method that applies to learn a that minimizes the on a given . The method is said to underfit if it fails to achieve a sufficiently low on the . Underfitting typically occurs when the chosen is too simple to capture the underlying relationship between and . [H] [scale=1.0] plot({ },{ + }); at (6.5,{ 6.5+ }) { }; / / in {1/0.6/2.4, 2/1.2/2.1, 3/1.8/2.0, 4/2.4/2.3, 5/3.0/3.1, 6/3.6/4.0, 7/4.2/5.2, 8/4.8/6.0, 9/5.4/6.3, 10/6.0/6.1} { (p ) at ( , ) {}; ( ,{ + }) -- (p ); } {No linear can capture the relation between and for the depicted . Thus, any method that uses a will underfit this .} For example, a method using a on with a highly non-linear relation between and will not be able to learn a with small average on the , let alone a small . \\\\ See also: , , , .",
      "deg": 14
    },
    {
      "id": "overfitting",
      "name": "overfitting",
      "desc": "Consider an method that uses to learn a with the on a given . Such a method is overfitting the if it learns a with a on the that a significantly smaller than the average outside the . In other words, if a method overfits it has a large . \\\\ See also: , , , .",
      "deg": 23
    },
    {
      "id": "gdpr",
      "name": "general data protection regulation (GDPR)",
      "desc": "The GDPR was enacted by the European Union (EU), effective from 25 May 2018 . It safeguards the privacy and rights of individuals in the EU. The GDPR has significant implications for how are collected, stored, and used in applications. Key provisions include the following: : systems should only use the necessary amount of personal for their purpose. and : systems should enable their users to understand how the systems make decisions that impact the users. subject rights: Users should get an opportunity to access, rectify, and delete their personal , as well as to object to automated decision-making and profiling. Accountability: Organizations must ensure robust security and demonstrate compliance through documentation and regular audits. See also: , , , , .",
      "deg": 9
    },
    {
      "id": "normaldist",
      "name": "normal distribution",
      "desc": "See .",
      "deg": 2
    },
    {
      "id": "gaussrv",
      "name": "Gaussian random variable (Gaussian RV)",
      "desc": "A standard Gaussian is a real-valued with , , p(x) = { } \\,(-x^2/2). Given a standard , we can construct a general with and via . The of a is referred to as , denoted by . \\\\ A random with and can be constructed as , , where is a of standard Gaussian , and is any satisfying . The of a Gaussian random is referred to as the , denoted by . \\\\ We can interpret a random as a indexed by the set . A is a over an arbitray index set such that any restriction to a finite subset yields a random . \\\\ are widely used in the statistical analysis of methods. Their significance arises partly from the which provides conditions under which the average of many independent (not necessarily themselves) tends toward a . \\\\ The is also distinct in that it represents . Among all -valued with a given , the maximizes . This makes a natural choice for capturing or the lack of (domain) knowledge. \\\\ See also: , , , , .",
      "deg": 28
    },
    {
      "id": "gaussian",
      "name": "Gaussian",
      "desc": "See .",
      "deg": 2
    },
    {
      "id": "clt",
      "name": "central limit theorem (CLT)",
      "desc": "Consider a sequence of , for , each with zero and finite . The CLT states that the normalized sum converges in distribution to a with zero and as . One elegant way to derive the CLT is via the of the normalized sum . Let (with the imaginary unit ) be the common of each sum and , and let denote the of . Define an operator acting on such that This captures the effect of recursively adding an and rescaling. Iteratively applying leads to of toward the fixed point which is the of a with zero and . of the CLT allow for dependent or nonidentically distributed . [H] [ width=10cm, height=6cm, xlabel={}, ylabel={}, legend style={at={(0.97,0.97)}, anchor=north west}, domain=-3:3, ylabel style={ yshift=10pt }, samples=400, ymin=-0.2, ymax=1.1, axis lines=middle, clip=false, grid=both, ] ; ; ; ; at (axis cs:-0.08,1.05) { }; at (axis cs: 3.2,0.1) { }; { of normalized sums of for compared to the Gaussian limit.} See also: , .",
      "deg": 11
    },
    {
      "id": "GaussProc",
      "name": "Gaussian process (GP)",
      "desc": "A GP is a collection of indexed by input values from some input space such that, for any finite subset , the corresponding have a joint For a fixed input space , a GP is fully specified (or parameterized) by: 1) a ; and 2) a .\\\\ { Example.} We can interpret the temperature distribution across Finland (at a specific point in time) as the of a GP , where each input denotes a geographic location. Temperature observations from weather stations provide values at specific locations (see Fig. ). A GP allows us to predict the temperature nearby weather stations and to quantify the of these . [H] [ axis equal, hide axis, scale=1.2, xmin=17, xmax=32, ymin=55, ymax=71, clip=true ] table [x=lon, y=lat, col sep=comma] {assets/finland_border.csv}; table [x=lon, y=lat, col sep=comma] {assets/fmi_stations_subset.csv}; (axis cs:19,59) -- (axis cs:25.5,59) node[anchor=west] {longitude (lon)}; (axis cs:19,59) -- (axis cs:19,65.5) node[anchor=south] {latitude (lat)}; {For a given point in time, we can interpret the current temperature distribution over Finland as a of a GP indexed by geographic coordinates and sampled at weather stations. The weather stations are indicated by blue dots. } See also: , , .",
      "deg": 11
    },
    {
      "id": "trustAI",
      "name": "trustworthy artificial intelligence (trustworthy AI)",
      "desc": "Besides the and , a third main design aspect of methods is their trustworthiness . The EU has put forward seven key requirements (KRs) for trustworthy (which typically build on methods) : [label= )] KR1 – Human agency and oversight; KR2 – Technical and safety; KR3 – Privacy and governance; KR4 – ; KR5 – Diversity, non-discrimination and fairness; KR6 – Societal and environmental well-being; KR7 – Accountability. See also: , , , , , , .",
      "deg": 17
    },
    {
      "id": "sqerrloss",
      "name": "squared error loss",
      "desc": "The squared error measures the error of a when predicting a numeric from the of a . It is defined as { } ( - _{= } )^{2}. \\\\ See also: , , , , , .",
      "deg": 23
    },
    {
      "id": "projection",
      "name": "projection",
      "desc": "Consider a subset of the -dimensional . We define the projection of a onto as { } = _{ ' } {2}. In other words, is the in that is closest to . The projection is only well defined for subsets for which the above exists . \\\\ See also: , , .",
      "deg": 5
    },
    {
      "id": "projgd",
      "name": "projected gradient descent (projected GD)",
      "desc": "Consider an -based method that uses a parameterized with . Even if the of is , we cannot use basic , as it does not take into account constraints on the optimization variable (i.e., the ). Projected extends basic to address this issue. A single iteration of projected consists of first taking a and then projecting the result back onto the . See Fig. for a visual illustration. [H] [scale=0.9] [right] at (-5.1,1.7) { } ; plot ( , {(1/8)* }); [fill] (2.83,1) circle [radius=0.1] node[right] { }; (2.83,1) -- node[midway,above] { } (-1.5,1); (-1.5,1) --(-1.5,-1.5) node [below, left]{ } ; (-1.5,-1.5) -- node[midway,above] {} (1,-1.5) ; [fill] (1,-1.5) circle [radius=0.1] node[below] { }; (1,-1.5) -- (3,-1.5) node[midway, above] { }; {Projected augments a basic with a back onto the constraint set .} See also: , , , , , , , , .",
      "deg": 10
    },
    {
      "id": "diffpriv",
      "name": "differential privacy (DP)",
      "desc": "Consider some method that reads in a (e.g., the used for ) and delivers some output . The output could be either the learned or the for specific . DP is a precise measure of incurred by revealing the output. Roughly speaking, an method is differentially private if the of the output remains largely unchanged if the of one in the is changed. Note that DP builds on a for an method, i.e., we interpret its output as the of a . The randomness in the output can be ensured by intentionally adding the of an auxiliary (i.e., adding noise) to the output of the method. \\\\ See also: , , , .",
      "deg": 18
    },
    {
      "id": "robustness",
      "name": "robustness",
      "desc": "Robustness is a key requirement for . It refers to the property of an system to maintain acceptable performance even when subjected to different forms of perturbations. These perturbations may affect the of a in order to manipulate the delivered by a trained . Robustness also includes the of -based methods against perturbations of the . Such perturbations can occur within . \\\\ See also: , , , .",
      "deg": 18
    },
    {
      "id": "stability",
      "name": "stability",
      "desc": "Mathematically, a method is a map from a given to an output . As a case in point, consider an -based method that maps a to the learned which achieve the minimum average on the . Instead of the learned , the output could also be the obtained from the trained . Stability refers to the desirable property of that small changes in the input result in small changes in the output . The notion of stability is intimately related to the notion of . In particular, there are formal notions of stability that allow to bound the (see ). To build intuition, consider the three depicted in Fig. , each of which is equally likely under the same -generating . Since the optimal are determined by this underlying , an accurate method should return the same (or very similar) output for all three . In other words, any useful must be robust to variability in from the same , i.e., it must be stable. [H] [ axis lines=none, xlabel={ }, ylabel={}, legend pos=north west, ymin=0, ymax=10, xtick={1,2,3,4,5}, grid style=dashed, every axis plot/.append style={very thick} ] +[only marks,mark=*] coordinates { (1,2) (2,4) (3,3) (4,5) (5,7) }; +[only marks,mark=square*] coordinates { (1,3) (2,2) (3,6) (4,4) (5,5) }; +[only marks,mark=triangle*] coordinates { (1,5) (2,7) (3,4) (4,6) (5,3) }; {Three , , and , each sampled independently from the same -generating . A stable method should return similar outputs when trained on any of these . } See also: , .",
      "deg": 18
    },
    {
      "id": "privprot",
      "name": "privacy protection",
      "desc": "Consider some method that reads in a and delivers some output . The output could be the learned or the obtained for a specific with . Many important applications involve representing humans. Each is characterized by , potentially a , and a (e.g., a recent medical diagnosis). Roughly speaking, privacy protection means that it should be impossible to infer, from the output , any of the of in . Mathematically, privacy protection requires non-invertibility of the . In general, just making non-invertible is typically insufficient for privacy protection. We need to make sufficiently non-invertible. \\\\ See also: , , , , , , , , .",
      "deg": 13
    },
    {
      "id": "privleakage",
      "name": "privacy leakage",
      "desc": "Consider an application that processes a and delivers some output, such as the obtained for new . Privacy leakage arises if the output carries information about a private (or sensitive) of a of (such as a human). Based on a for the generation, we can measure the privacy leakage via the between the output and the sensitive . Another quantitative measure of privacy leakage is . The relations between different measures of privacy leakage have been studied in the literature (see ). \\\\ See also: , , , .",
      "deg": 12
    },
    {
      "id": "probmodel",
      "name": "probabilistic model",
      "desc": "A probabilistic interprets the generation of as with a joint . This joint typically involves that have to be manually chosen or learned via statistical inference methods such as estimation . \\\\ See also: , , , , , , .",
      "deg": 45
    },
    {
      "id": "mean",
      "name": "mean",
      "desc": "The mean of a , which takes on values in a , is its . It is defined as the Lebesgue integral of with respect to the underlying (e.g., see or ), i.e., We also use the term to refer to the average of a finite . However, these two definitions are essentially the same. Indeed, we can use a to construct a discrete on the . Here, the index is chosen uniformly at random, for all . The mean of is precisely the average . For a with finite second-order moment, i.e., is well-defined and fnite, the mean is characterized as the solution of the following minimization problem : For the , associated with a , this reduces to with on . \\\\ See also: , , , .",
      "deg": 25
    },
    {
      "id": "median",
      "name": "median",
      "desc": "A median of a real-valued is any number such that and (see Fig. ) . [H] [ axis lines=middle, xlabel={}, ylabel={}, ymin=0, ymax=1.1, xmin=-2, xmax=6, xtick= , ytick={0,1/2,1}, domain=-2:6, samples=200, width=10cm, height=6cm, smooth, enlargelimits=true, clip=false ] node[pos=0.5, above, yshift=15pt] { }; (axis cs:1,0) -- (axis cs:1,0.5); (axis cs:-2,0.5) -- (axis cs:1,0.5); (axis cs:1,0.5) circle (2pt); at (axis cs:1,0) { }; at (axis cs:6.3,0) { }; {The median of a real-valued is any number that partitions into two rays with equal . } We can define the median of a via a specific that is naturally associated with . In particular, this is defined on the via . Here, the index is chosen uniformly at random, i.e., for all . If the is integrable, any median of solves the : For a the above (constructed from a ), this is on using . Like the , the median of a can also be used to estimate of an underlying . Compared with the , the median is more robust to . For example, a median of a with more than one does not change even if we arbitrarily increase the largest element of (see Fig. ). In contrast, the will increase arbitrarily. [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/4 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptA ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (7.5, -4) {(a)}; [xshift=12cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 7.5) -- (10.5, 7.5) node[right] { }; (0.5, 3) -- (10.5, 3) node[right] { }; at (ptB7) { }; at (7.5, -4) {(b)}; {The median is robust against contamination. (a) Original . (b) Noisy including an . } See also: , , , .",
      "deg": 15
    },
    {
      "id": "variance",
      "name": "variance",
      "desc": "The variance of a real-valued is defined as the of the squared difference between and its . We extend this definition to -valued as . \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "nn",
      "name": "nearest neighbor (NN)",
      "desc": "NN methods learn a whose value is solely determined by the NNs within a given . Different methods use different for determining the NNs. If are characterized by numeric , we can use their Euclidean distances as the . \\\\ See also: , .",
      "deg": 7
    },
    {
      "id": "neighborhood",
      "name": "neighborhood",
      "desc": "Consider some space with . The neighborhood of a point is the set of other points having a sufficiently small distance to . For example, the -neighborhood of is defined as If is an undirected , which is a special case of a space, the neighborhood of a node is the set of its . \\\\ See also: , .",
      "deg": 6
    },
    {
      "id": "neighbor",
      "name": "neighbor",
      "desc": "A neighbor of a node within an undirected is a node that is connected via an edge to node . \\\\ See also: .",
      "deg": 4
    },
    {
      "id": "bias",
      "name": "bias",
      "desc": "Consider a -based method that learns a from a given . The analysis of the method is often based on a (such as the ) for the generation. Here, and, in turn, the learnt are viewed as ( of) . Any property of , such as specific in a , or the error for a fixed , then also becomes a . The squared bias of a numeric property is Here, is a reference which could be defined by for a fixed test with and . \\\\ See also: , , , .",
      "deg": 20
    },
    {
      "id": "classification",
      "name": "classification",
      "desc": "Classification is the task of determining a discrete-valued for a given , based solely on its . The belongs to a finite set, such as or , and represents the category to which the corresponding belongs. \\\\ See also: , , .",
      "deg": 19
    },
    {
      "id": "privfunnel",
      "name": "privacy funnel",
      "desc": "The privacy funnel is a method for learning a that provides privacy-friendly of a . \\\\ See also: , , , .",
      "deg": 6
    },
    {
      "id": "condnr",
      "name": "condition number",
      "desc": "The condition number of a positive definite is the ratio between the largest and the smallest of . The condition number is useful for the analysis of methods. The computational complexity of for crucially depends on the condition number of the , with the of the . Thus, from a computational perspective, we prefer of such that has a condition number close to . \\\\ See also: , , , , , , , , .",
      "deg": 9
    },
    {
      "id": "classifier",
      "name": "classifier",
      "desc": "A classifier is a (i.e., a ) used to predict a taking on values from a finite . We might use the value itself as a for the . However, it is customary to use a that delivers a numeric quantity. The is then obtained by a simple thresholding step. For example, in a binary problem with a , we might use a real-valued as a classifier. A can then be obtained via thresholding, =1 ( )\\! \\!0 =-1 We can characterize a classifier by its , for every possible value . \\\\ See also: , , .",
      "deg": 16
    },
    {
      "id": "emprisk",
      "name": "empirical risk",
      "desc": "The empirical of a on a is the average incurred by when applied to the in . \\\\ See also: , , , , .",
      "deg": 20
    },
    {
      "id": "nodedegree",
      "name": "node degree",
      "desc": "The degree of a node in an undirected is the number of its , i.e., . \\\\ See also: , .",
      "deg": 2
    },
    {
      "id": "token",
      "name": "token",
      "desc": "A is a basic unit of information obtained by splitting a sequence of symbols, such as a text string, into smaller parts. In , tokens often correspond to words, subwords, or characters that form the of a . Tokenization transforms raw text (e.g., ``The cat sleeps'') into a sequence of tokens (e.g., [``The'', ``cat'', ``sleeps'']), which can then be mapped to numerical .",
      "deg": 9
    },
    {
      "id": "nlp",
      "name": "natural language processing (NLP)",
      "desc": "NLP studies methods for the the analysis and generation of human language. Typical NLP tasks include text , machine translation, sentiment analysis, and question answering. Modern NLP systems represent language as sequences of and train that capture contextual dependencies, such as -based methods.\\\\ See also: , .",
      "deg": 10
    },
    {
      "id": "directedcyble",
      "name": "directed cycle",
      "desc": "A directed cycle in a is a sequence of distinct nodes such that . In a directed cycle, following the direction of each edge eventually leads back to the starting node, creating a closed loop. [H] [>=Latex, node distance=1.4cm, thick] (a1) at (90:1.5); (a2) at (210:1.5); (a3) at (330:1.5); (a1) circle (2pt) node[above=3pt] { }; (a2) circle (2pt) node[below left=3pt] { }; (a3) circle (2pt) node[below right=3pt] { }; (a1) -- (a2); (a2) -- (a3); (a3) -- (a1); ; ; ; The presence of a directed cycle prevents a from being a . \\\\ See also: , .",
      "deg": 2
    },
    {
      "id": "dag",
      "name": "directed acyclic graph (DAG)",
      "desc": "A DAG is a which contains no directed cycles. Formally, a DAG satisfies that for any sequence of distinct nodes , the presence of directed edges implies that . [H] [>=Latex, node distance=1.4cm, thick, every node/.style={circle, fill=black, inner sep=1.5pt}] (a1) {}; (a2) {}; (a3) {}; (a1) -- (a2); (a2) -- (a3); (b1) {}; (b2) {}; (b3) {}; (b1) -- (b2); (b2) -- (b3); (b3) to (b1); {Left: A DAG defined on three nodes . Right: Another on the same nodes that is not a DAG since it contains a directed cycle.} The absence of directed cycles allows for a topological ordering of nodes such that all edges point from earlier to later nodes in this order. Several , such as or , are naturally represented as DAGs. \\\\ See also: , , .",
      "deg": 8
    },
    {
      "id": "directedgraph",
      "name": "directed graph",
      "desc": "A directed contains edges that possess an orientiation (or direction). Mathematically, a directed consists of nodes and a set of directed edges. [H] [>=stealth, node distance=1.8cm] (i) {}; (ip) [right=of i] {}; (i) -- (ip); {The edges of a directed have an orientation (or direction). We can indicate the orientaton by an arrow head.} We can represent a directed edge from node to node by an ordered pair . Directed are widely used to model interconnected systems or networks, such as transportation systems, electronic circuits, and biological processes . \\\\ See also: .",
      "deg": 3
    },
    {
      "id": "undirectedgraph",
      "name": "undirected graph",
      "desc": "See . \\\\ See also: .",
      "deg": 4
    },
    {
      "id": "simplefunction",
      "name": "simple function",
      "desc": "A simple is a which takes on only finite many values. In other words, with the indicator of a subset and arbitrary coefficents . The subsets in the above decomposition must be and form a partition of . \\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "measurespace",
      "name": "measure space",
      "desc": "A measure space is a triple consisting of a set , a of subsets of , and a measure . The measure assigns a non-negative number to each set , generalizing the notions of length, area, or volume in . Measure spaces provide the mathematical foundation for the or the definition of as measurable mappings between measure spaces. A is a special case of a measure space where the total measure of the sample space is normalized to one, i.e., . In this case, is called a .\\\\ See also: , , .",
      "deg": 8
    },
    {
      "id": "integrable",
      "name": "integrable",
      "desc": "A defined on a is called integrable if the of its absolute value is finite, i.e., In this case, the is well-defined and finite. A defined on the of a is integrable if which ensures that the exists and is finite. \\\\ See also: , .",
      "deg": 9
    },
    {
      "id": "measure",
      "name": "measure",
      "desc": "A measure on a set equipped with a is a that assigns a nonnegative value to each set such that : , and for any collection of pairwise disjoint sets in , (this property if referred to as `` additivity'').",
      "deg": 5
    },
    {
      "id": "LebesgueIntegral",
      "name": "Lebesgue integral",
      "desc": "The Lebesgue integral assigns each integrable a number which is referred to as the integral of . The integral of can be interpreted as the volume that is enclosed by the in the space . We can compute it be increasingly accurate approximations by . [H] [scale=1.5] (-0.2,0) -- (3.4,0) node[right] { }; plot( ,{0.5+0.3* +0.1* }) node[right] { }; (0,0) -- plot[domain=0:3] ( ,{0.5+0.3* +0.1* }) -- (3,0) -- cycle; (0,0) rectangle (1,0.5); at (0.5,-0.2) { }; (1,0) rectangle (2,0.9); (2,0) rectangle (3,1.5); (0,0.5)--(1,0.5); (1,0.9)--(2,0.9); (2,1.5)--(3,1.5); at (0.8,0.5) {}; in {0,1,2,3} ( ,0) -- ( ,2.5); at (0,-0.05) { }; at (1,-0.05) { }; at (2,-0.05) { }; at (3,-0.05) { }; at (1.6,3.0) { }; [anchor=west] at (3.2,1.5) { }; It is useful to think of the Lebesgue integral as a that maps an integrable to the value of its integral, The precise defintion of this , including its which are the integrable , is a corner-stone of measure theory . \\\\ See also: .",
      "deg": 8
    },
    {
      "id": "cdf",
      "name": "cumulative distribution function (cdf)",
      "desc": "The cdf of a real-valued is \\\\ See also: , , .",
      "deg": 4
    },
    {
      "id": "weightedgraph",
      "name": "weighted graph",
      "desc": "A whose edges are assigned numeric weights. Typically, these edge weights are non-negative real numbers. For example, if a graph represents a road network with nodes being intersections and edges representing road segments, the edge weight could represent the capacity (measured in maximum vehicles per hour) of the road segment . \\\\ See also: .",
      "deg": 1
    },
    {
      "id": "graph",
      "name": "graph",
      "desc": "A graph is a pair that consists of a node set and an edge set . In its most general form, a graph is specified by a that assigns each edge a pair of nodes . Unless specified otherwise, the term graph refers to an undirected graph. A simple undirected graph is obtained by identifying each edge with a set that contains two different nodes . Weighted graphs also specify numeric for each edge . \\\\ See also: , .",
      "deg": 25
    },
    {
      "id": "uncertainty",
      "name": "uncertainty",
      "desc": "In the context of , uncertainty refers to the presence of multiple plausible outcomes or based on available . For example, the produced by a trained often reflects a range of possible values for the true of a given . The broader this range, the greater the associated uncertainty. theory allows us to represent, quantify, and reason about uncertainty in a mathematically rigorous manner. \\\\ See also: , , , .",
      "deg": 21
    },
    {
      "id": "ucb",
      "name": "upper confidence bound (UCB)",
      "desc": "Consider an application that requires selecting, at each time step , an action from a finite set of alternatives . The utility of selecting action is quantified by a numeric signal . A widely used for this type of sequential decision-making problem is the setting . In this , the is viewed as the of a with unknown . Ideally, we would always choose the action with the largest expected , but these are unknown and must be estimated from observed . Simply choosing the action with the largest estimate can lead to suboptimal outcomes due to estimation . The UCB strategy addresses this by selecting actions not only based on their estimated but also by incorporating a term that reflects the in these estimates—favoring actions with a high-potential and high . Theoretical guarantees for the performance of UCB strategies, including logarithmic bounds, are established in . \\\\ See also: , , , , .",
      "deg": 14
    },
    {
      "id": "mab",
      "name": "multiarmed bandit (MAB)",
      "desc": "An MAB problem is a precise formulation of a sequential decision-making task under . At each discrete time step , a learner selects one of several possible actions—called arms—from a finite set . Pulling arm at time yields a that is drawn from an unknown . We obtain different classes of MAB problems by placing different restrictions on this . In the simplest setting, the does not depend on . Given an MAB problem, the goal is to construct methods that maximize the cumulative over time by strategically balancing exploration (i.e., gathering information about uncertain arms) and exploitation (i.e., selecting arms known to perform well). MAB problems form an important special case of problems , . \\\\ See also: , .",
      "deg": 8
    },
    {
      "id": "optimism in the face of uncertainty",
      "name": "optimism in the face of uncertainty",
      "desc": "methods learn according to some performance criterion . However, they usually cannot access directly but rely on an estimate (or approximation) of . As a case in point, -based methods use the average on a given (i.e., the ) as an estimate for the of a . Using a , one can construct a confidence interval for each choice for the . One simple construction is , , with being a measure of the (expected) deviation of from . We can also use other constructions for this interval as long as they ensure that with a sufficiently high . An optimist chooses the according to the most favorable—yet still plausible—value of the performance criterion (see Fig. ). Two examples of methods that use such an optimistic construction of an are and methods for sequential decision making . [H] [x=3cm, y=1cm] (-1, 5) -- plot[domain=-2:1, samples=100] ({ +1}, { + 1}) -- plot[domain=1:-2, samples=100] ({ +1}, { - 0.5}) -- cycle; at (2, 4) { }; plot ({ +1}, { -0.5}) node[right] { }; plot ({ }, { }); (1, -0.5) -- (1, 1) node[midway, right] { }; { methods learn by using some estimate of for the ultimate performance criterion . Using a , one can use to construct confidence intervals , which contain with a high probability. The best plausible performance measure for a specific choice of is . } See also: , , , .",
      "deg": 16
    },
    {
      "id": "empgraph",
      "name": "federated learning network (FL network)",
      "desc": "An network consists of an undirected weighted . The nodes of represent that can access a and train a . The edges of represent communication links between as well as statistical similarities between their . A principled approach to train the is . The solutions of are local that optimally balance the incurred on with their across the edges of . \\\\ See also: , , , .",
      "deg": 18
    },
    {
      "id": "norm",
      "name": "norm",
      "desc": "A norm is a that maps each ( ) element of a to a nonnegative real number. This must be homogeneous and definite, and it must satisfy the triangle inequality . \\\\ See also: , , .",
      "deg": 11
    },
    {
      "id": "dualnorm",
      "name": "dual norm",
      "desc": "Every defined on a has an associated dual , which is denoted by and defined as . The dual measures the largest possible inner product between and any in the unit ball of the original . For further details, see . \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "geometricmedian",
      "name": "geometric median (GM)",
      "desc": "The GM of a set of input in is a point that minimizes the sum of distances to the such that _{ ^{ }} _{ =1}^{ } { - ^{( )}}{2}. Fig. illustrates a fundamental property of the GM: If does not coincide with any of the input , then the unit pointing from to each must sum to zero—this is the zero- (optimality) condition for . It turns out that the solution to cannot be arbitrarily pulled away from trustworthy input as long as they are the majority . [H] [scale=2, thick, >=stealth] (w) at (3,0); (w) circle (1.2pt) node[below right] { }; (w2) at (0.5,0.3); (w3) at (0.7,0.7); (w2) circle (1pt) node[above left] { }; (w3) circle (1pt) node[above left] { }; at ( ) { }; (w) -- (w2); (w) -- (w3); (w) -- ( ) ; (w) -- ( ) node[pos=0.9, right,yshift=7pt] { }; (w4) at (5,0.2); at (5,0.6) { }; (w4) circle (1pt) node[below left] { }; (w) -- ( ) ; { Consider a solution of that does not coincide with any of the input . The optimality condition for requires that the unit from to the input sum to zero.} See also: , .",
      "deg": 2
    },
    {
      "id": "explanation",
      "name": "explanation",
      "desc": "One approach to enhance the of an method for its human user is to provide an explanation alongside the delivered by the method. Explanations can take different forms. For instance, they may consist of human-readable text or quantitative indicators, such as importance scores for the individual of a given ~ . Alternatively, explanations can be visual—for example, intensity that highlight image regions that drive the . Fig.\\ illustrates two types of explanations. The first is a local linear approximation of a nonlinear trained around a specific , as used in the method . The second form of explanation depicted in the figure is a sparse set of at selected , offering concrete reference points for the user. [H] [x=0.5cm] [ hide axis, xmin=-3, xmax=6, ymin=0, ymax=6, domain=0:6, samples=100, width=10cm, height=6cm, clip=false ] node[pos=0.9, above right, yshift=10pt] { }; node[pos=0.2, above] { }; coordinates {(1.5, {2 + sin(deg(1.5))})}; coordinates {(1.5,0) (1.5,2.4)}; at (axis cs:1.5, -0.2) { }; coordinates {(-1, {2 + sin(deg(-1))})}; coordinates {(-1,0) (-1,{2 + sin(deg(-1))})}; at (axis cs:-1, -0.2) { }; coordinates {(0, {2 + sin(deg(0))})}; coordinates {(0,0) (0,{2 + sin(deg(0))})}; at (axis cs:0, -0.2) { }; coordinates {(5, {2 + sin(deg(5))})}; coordinates {(5,0) (5,{2 + sin(deg(5))})}; at (axis cs:5, -0.2) { }; {A trained can be explained locally at some point by a linear approximation . For a , this approximation is determined by the . Another form of explanation could be the values for . } See also: , , , , .",
      "deg": 17
    },
    {
      "id": "risk",
      "name": "risk",
      "desc": "Consider a used to predict the of a based on its . We measure the quality of a particular using a . If we interpret as the of , the also becomes the of a . The allows us to define the risk of a as the expected . Note that the risk of depends on both the specific choice for the and the of the . \\\\ See also: , , , .",
      "deg": 32
    },
    {
      "id": "actfun",
      "name": "activation function",
      "desc": "Each artificial neuron within an is assigned an that maps a weighted combination of the neuron inputs to a single output value . Note that each neuron is parameterized by the . \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "distributedalgorithm",
      "name": "distributed algorithm",
      "desc": "A distributed is an designed for a special type of computer, i.e., a collection of interconnected computing devices (or nodes). These devices communicate and coordinate their local computations by exchanging messages over a network , . Unlike a classical , which is implemented on a single , a distributed is executed concurrently on multiple with computational capabilities. Similar to a classical , a distributed can be modeled as a set of potential executions. However, each execution in the distributed setting involves both local computations and message-passing . A generic execution might look as follows: Each starts from its own local input and performs a sequence of intermediate computations at discrete-time instants . These computations may depend on both the previous local computations at the and the messages received from other . One important application of distributed is in where a network of collaboratively trains a personal for each . \\\\ See also: , , , , .",
      "deg": 8
    },
    {
      "id": "algorithm",
      "name": "algorithm",
      "desc": "An algorithm is a precise, step-by-step specification for producing an output from a given input within a finite number of well-defined computational steps . For example, an for is an algorithm that explicitly describes how to map a given into through a sequence of . The precise form of an algorithm depends on the available computational infrastructure. For example, if this infrastructure allows to compute a , then we can define a algorithm using the . In contrast, if the computational infrastructe does only allow for basic arithmetic (mulilication and addition), the need to be somehow translated into a sequence of arithmetic operations (e.g., as in ). To study algorithms rigorously, we can represent (or approximate) them by different mathematical structures . One approach is to represent an algorithm as a collection of possible executions. Each individual execution is then a sequence of the form This sequence starts from an input and progresses via intermediate steps until an output is delivered. Crucially, an algorithm encompasses more than just a mapping from input to output; it also includes intermediate computational steps . \\\\ See also: , , , , , .",
      "deg": 29
    },
    {
      "id": "stochalgorithm",
      "name": "stochastic algorithm",
      "desc": "A uses a random mechanism during its execution. For example, uses a randomly selected subset of to compute an approximation for the of an . We can represent a by a , i.e., the possible execution sequence is the possible outcomes of a , , . \\\\ See also: , , , , , , , , , .",
      "deg": 11
    },
    {
      "id": "batchlearning",
      "name": "batch learning",
      "desc": "In learning (also known as offline learning), the is trained on the entire in a single training iteration, instead of updating it incrementally as arrive. All available are inputted into a learning , resulting in a that can make . Since these tend to be large, training is computationally expensive and time-consuming, so it is typically performed offline. After learning, the will be static and will not adapt to new automatically. Updating the with new information requires retraining the entirely. Once the has been trained, it is launched into production where it cannot be updated. Training a can take many hours, so many in production settings are updated cyclically on a periodic schedule when the distribution is stable. For example, a retail analytics team could retrain their demand forecast every Sunday using the previous week's sales to predict next week's demand. If a system needs to be constantly updated to rapidly changing , such as in stock price , a more adaptable solution such as is necessary. \\\\ See also: , , , .",
      "deg": 8
    },
    {
      "id": "onlinelearning",
      "name": "online learning",
      "desc": "Some methods are designed to process in a sequential manner, updating their one at a time, as new become available. A typical example is time-series , such as daily and temperatures recorded by an weather station. These values form a chronological sequence of observations. During each time step , online learning methods update (or refine) the current (or ) based on the newly observed . \\\\ See also: , .",
      "deg": 14
    },
    {
      "id": "onlinealgorithm",
      "name": "online algorithm",
      "desc": "An online processes input incrementally, receiving sequentially and making decisions or producing outputs (or decisions) immediately without having access to the entire input in advance , . Unlike an offline , which has the entire input available from the start, an online must handle about future inputs and cannot revise past decisions. Similar to an offline , we represent an online formally as a collection of possible executions. However, the execution sequence for an online has a distinct structure as follows: Each execution begins from an initial state (i.e., ) and proceeds through alternating computational steps, outputs (or decisions), and inputs. Specifically, at step , the performs a computational step , generates an output , and then subsequently receives the next input ( ) . A notable example of an online in is , which incrementally updates as new arrive. \\\\ See also: , , , , , , , .",
      "deg": 9
    },
    {
      "id": "transparency",
      "name": "transparency",
      "desc": "Transparency is a fundamental requirement for . In the context of methods, transparency is often used interchangeably with , . However, in the broader scope of systems, transparency extends beyond and includes providing information about the system’s limitations, reliability, and intended use. In medical diagnosis systems, transparency requires disclosing the confidence level for the delivered by a trained . In credit scoring, -based lending decisions should be accompanied by explanations of contributing factors, such as income level or credit history. These explanations allow humans (e.g., a loan applicant) to understand and contest automated decisions. Some methods inherently offer transparency. For example, provides a quantitative measure of reliability through the value . are another example, as they allow human-readable decision rules . Transparency also requires a clear indication when a user is engaging with an system. For example, -powered chatbots should notify users that they are interacting with an automated system rather than a human. Furthermore, transparency encompasses comprehensive documentation detailing the purpose and design choices underlying the system. For instance, datasheets and system cards help practitioners understand the intended use cases and limitations of an system . \\\\ See also: , .",
      "deg": 13
    },
    {
      "id": "sensattr",
      "name": "sensitive attribute",
      "desc": "revolves around learning a that allows us to predict the of a from its . In some applications, we must ensure that the output delivered by an system does not allow us to infer sensitive attributes of a . Which part of a is considered a sensitive attribute is a design choice that varies across different application domains. \\\\ See also: , , , , , .",
      "deg": 11
    },
    {
      "id": "sbm",
      "name": "stochastic block model (SBM)",
      "desc": "The SBM is a probabilistic generative for an undirected with a given set of nodes . In its most basic variant, the SBM generates a by first randomly assigning each node to a index . A pair of different nodes in the is connected by an edge with that depends solely on the . The presence of edges between different pairs of nodes is statistically independent. \\\\ See also: , , , , .",
      "deg": 6
    },
    {
      "id": "deepnet",
      "name": "deep net",
      "desc": "A deep net is an with a (relatively) large number of hidden . Deep learning is an umbrella term for methods that use a deep net as their . \\\\ See also: , , , .",
      "deg": 16
    },
    {
      "id": "baseline",
      "name": "baseline",
      "desc": "Consider some method that produces a learned (or trained ) . We evaluate the quality of a trained by computing the average on a . But how can we assess whether the resulting performance is sufficiently good? How can we determine if the trained performs close to optimal such that there is little point in investing more resources (for collection or computation) to improve it? To this end, it is useful to have a reference (or baseline) level against which we can compare the performance of the trained . \\\\ Such a reference value might be obtained from human performance, e.g., the misclassification rate of dermatologists who diagnose cancer from visual inspection of skin . Another source for a baseline is an existing, but for some reason unsuitable, method. For example, the existing method might be computationally too expensive for the intended application. Nevertheless, its error can still serve as a baseline. Another, somewhat more principled, approach to constructing a baseline is via a . In many cases, given a , we can precisely determine the achievable among any hypotheses (not even required to belong to the ) . \\\\ This achievable (referred to as the ) is the of the for the of a , given its . Note that, for a given choice of , the (if it exists) is completely determined by the . However, computing the and presents two main challenges. First, the is unknown and must be estimated from observed . Second, even if were known, computing the exactly may be computationally infeasible . A widely used is the for characterized by numeric and . Here, for the , the is given by the posterior of the , given the , . The corresponding is given by the posterior (see Fig. ). [H] (-1,0) -- (7,0) node[right] { }; plot ({ }, {2*exp(-0.5*(( -3)^2))}); (3,0) -- (3,2.5); at ([yshift=-5pt] 3,2.5) { }; (3-1,1) -- (3+1,1.0); at ([yshift=2pt] 3,1.2) { }; in {0.5} { at ( , 0) { }; } at (0.5,-0.2) { }; {If the and the of a are drawn from a , we can achieve the (under ) by using the to predict the of a with . The corresponding is given by the posterior . We can use this quantity as a baseline for the average of a trained . } See also: , .",
      "deg": 24
    },
    {
      "id": "kfoldcv",
      "name": "-fold cross-validation ( -fold CV)",
      "desc": "A method { -fold cross- } for evaluating the of an -based method. The idea is to divide evenly into subsets (or folds) [htbp] [font= ] in {1,..., } { {-( -1)*( + )} at (-0.25, +0.5* ) {fold }; in {1,..., } { {( -1)* } = ( , ) rectangle ++( , ); ( , ) rectangle ++( , ); ( , ) rectangle ++( , ); } } in {1,..., } { {( -1)* + 0.5* } at ( , +0.2) { }; } {In -fold cross-validation, the available is evenly divided into folds . Each fold is used once as a , while the remaining folds form the . } For each fold , train the on the union of all folds except and validate it on . The overall performance is obtained by averaging the results across all folds. \\\\ See also: , .",
      "deg": 11
    },
    {
      "id": "spectrogram",
      "name": "spectrogram",
      "desc": "A spectrogram represents the time-frequency distribution of the energy of a time signal . Intuitively, it quantifies the amount of signal energy present within a specific time segment and frequency interval . Formally, the spectrogram of a signal is defined as the squared magnitude of its short-time Fourier transform (STFT) . Fig. depicts a time signal along with its spectrogram. [H] { } { (a) (b)} {(a) A time signal consisting of two modulated Gaussian pulses. (b) An intensity plot of the spectrogram. } The intensity plot of its spectrogram can serve as an image of a signal. A simple recipe for audio signal is to feed this signal image into originally developed for image and object detection . It is worth noting that, beyond the spectrogram, several alternative representations exist for the time-frequency distribution of signal energy , . \\\\ See also: , .",
      "deg": 2
    },
    {
      "id": "graphclustering",
      "name": "graph clustering",
      "desc": "aims to cluster that are represented as the nodes of a . The edges of represent pairwise similarities between . We can sometimes quantify the extent of these similarities by an , . \\\\ See also: , , , .",
      "deg": 6
    },
    {
      "id": "specclustering",
      "name": "spectral clustering",
      "desc": "Spectral is a particular instance of , i.e., it clusters represented as the nodes of a . Spectral uses the of the to construct for each node (i.e., for each ) . We can feed these into -based methods, such as or via . Roughly speaking, the of nodes belonging to a well-connected subset (or ) of nodes in are located nearby in the (see Fig. ). [H] {0.4 } [every node/.style={circle, fill=black, inner sep=0pt, minimum size=0.3cm}] (1) at (0,0) {}; (2) [below left=of 1, xshift=-0.2cm, yshift=-1cm] {}; (3) [below right=of 1, xshift=0.2cm, yshift=-1cm] {}; (4) [below=of 1, yshift=0.5cm] {}; (1) -- (2); (1) -- (3); at (1) { }; at (2) { }; at (3) { }; at (4) { }; at (0,-4) {(a)}; {0.4 } \\!=\\! 2 & -1 & -1 & 0 \\\\ -1 & 1 & 0 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 \\!=\\! { } \\,^{T} { } \\\\ {0.4 } [scale=3] (-0.2, 0) -- (1.2, 0) node[right] { }; (0, -0.2) -- (0, 1.2) node[above] { }; (0.577, 0) circle (0.03cm) node[above right] { }; (0.577, 0) circle (0.03cm); (0.577, 0) circle (0.03cm); (0, 1) circle (0.03cm) node[above right] { }; at (0.5,-0.5) {(c)}; {0.4 } & = ( ^{(1)}, ^{(2)}, ^{(3)}, ^{(4)} ) \\\\ & ^{(1)}\\!=\\! { } 1 \\\\ 1 \\\\ 1 \\\\ 0 , \\, ^{(2)}\\!=\\! 0 \\\\ 0 \\\\ 0 \\\\ 1 { } { (a) An undirected with four nodes , each representing a . (b) The and its . (c) A of using the . (d) Two corresponding to the of the . } See also: , , , .",
      "deg": 17
    },
    {
      "id": "flowbasedclustering",
      "name": "flow-based clustering",
      "desc": "Flow-based groups the nodes of an undirected by applying to nodewise . These are built from network flows between carefully selected sources and destination nodes . \\\\ See also: , , , .",
      "deg": 4
    },
    {
      "id": "esterr",
      "name": "estimation error",
      "desc": "Consider , each with and . In some applications, we can model the relation between the and the of a as . Here, we use some true underlying and a noise term , which summarizes any modeling or labeling errors. The estimation error incurred by an method that learns a , e.g., using , is defined as , for some . For a parametric , which consists of determined by , we can define the estimation error as , . \\\\ See also: , , , , , , , , .",
      "deg": 11
    },
    {
      "id": "dob",
      "name": "degree of belonging",
      "desc": "Degree of belonging is a number that indicates the extent to which a belongs to a . The degree of belonging can be interpreted as a soft assignment. methods can encode the degree of belonging with a real number in the interval . is obtained as the extreme case when the degree of belonging only takes on values or . \\\\ See also: , , , .",
      "deg": 6
    },
    {
      "id": "msee",
      "name": "mean squared estimation error (MSEE)",
      "desc": "Consider an method that learns based on some . If we interpret the in as of a , we define the . Here, denotes the true of the of . The MSEE is defined as the of the squared Euclidean of the , . \\\\ See also: , , , .",
      "deg": 13
    },
    {
      "id": "gtvmin",
      "name": "generalized total variation minimization (GTVMin)",
      "desc": "GTVMin is an instance of using the of local as a . \\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "regression",
      "name": "regression",
      "desc": "Regression problems revolve around the of a numeric solely from the of a . \\\\ See also: , , , .",
      "deg": 14
    },
    {
      "id": "acc",
      "name": "accuracy",
      "desc": "Consider characterized by and a categorical that takes on values from a finite . The accuracy of a , when applied to the in a , is then defined as using the . \\\\ See also: , , .",
      "deg": 11
    },
    {
      "id": "expert",
      "name": "expert",
      "desc": "aims to learn a that accurately predicts the of a based on its . We measure the error using some . Ideally, we want to find a that incurs minimal on any . We can make this informal goal precise via the and by using the as the for the (average) of a . An alternative approach to obtaining a is to use the learned by an existing method. We refer to this as an expert . minimization methods learn a that incurs a comparable to the best expert , . \\\\ See also: , , .",
      "deg": 13
    },
    {
      "id": "nfl",
      "name": "networked federated learning (NFL)",
      "desc": "NFL refers to methods that learn personalized in a distributed fashion. These methods learn from that are related by an intrinsic network structure. \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "regret",
      "name": "regret",
      "desc": "The regret of a relative to another , which serves as a , is the difference between the incurred by and the incurred by . The is also referred to as an . \\\\ See also: , , .",
      "deg": 7
    },
    {
      "id": "strcvx",
      "name": "strongly convex",
      "desc": "A continuously real-valued is strongly with coefficient if , . \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "differentiable",
      "name": "differentiable",
      "desc": "A real-valued is differentiable if it can be approximated locally at any point by a linear . The local linear approximation at the point is determined by the . \\\\ See also: , .",
      "deg": 14
    },
    {
      "id": "gradient",
      "name": "gradient",
      "desc": "For a real-valued , if a exists such that , it is referred to as the gradient of at . If it exists, the gradient is unique and denoted by or . \\\\ See also: , .",
      "deg": 20
    },
    {
      "id": "subgradient",
      "name": "subgradient",
      "desc": "For a real-valued , a such that is referred to as a subgradient of at , . \\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "fedprox",
      "name": "federated proximal (FedProx)",
      "desc": "FedProx refers to an iterative that alternates between separately training and combining the updated local . In contrast to , which uses to train , FedProx uses a for the training . \\\\ See also: , , , , , , .",
      "deg": 7
    },
    {
      "id": "relu",
      "name": "rectified linear unit (ReLU)",
      "desc": "The ReLU is a popular choice for the of a neuron within an . It is defined as , with being the weighted input of the artificial neuron. \\\\ See also: , .",
      "deg": 3
    },
    {
      "id": "hypothesis",
      "name": "hypothesis",
      "desc": "A hypothesis refers to a (or ) from the to the . Given a with , we use a hypothesis to estimate (or approximate) the using the . [htbp] [ >=Latex, node distance=2.0cm, box/.style={draw, rounded corners=2pt, inner sep=6pt}, label/.style={font= }, thinline/.style={line width=0.6pt} ] (audio) {}; at (audio.north) [yshift=0mm] {audio samples }; ( ) .. controls +(.3,.35) and +(-.3,.35) .. ++(0.8,0) .. controls +(.3,-.35) and +(-.3,-.35) .. ++(0.8,0) .. controls +(.3,.25) and +(-.3,.25) .. ++(0.8,0) .. controls +(.3,-.25) and +(-.3,-.25) .. ++(0.8,0); (model) { }; (audio) -- (model) ; (rating) {}; at ( ) {}; (barL) at ( ); (barR) at ( ); (ptr) at ( ); ; (model) -- (rating); { A hypothesis maps the of a to a of the . For example, the application uses the samples of an audio recording as predict how closely a person’s singing resembles that of Freddie Mercury. } is all about learning (or finding) a hypothesis such that for any (with and ). Practical methods, limited by finite computational resources, must restrict learning to a subset of all possible hypothesis maps. This subset is called the or simply the underlying the method. \\\\ See also: , , , .",
      "deg": 98
    },
    {
      "id": "effdim",
      "name": "effective dimension",
      "desc": "The effective dimension of an infinite is a measure of its size. Loosely speaking, the effective dimension is equal to the effective number of independent tunable . These might be the coefficients used in a or the and terms of an . \\\\ See also: , , .",
      "deg": 13
    },
    {
      "id": "labelspace",
      "name": "label space",
      "desc": "In a application , each is described by a set of together with an associated . The set of all admissible values is called the , denoted by . Importantly, may include values that no observed has as its value. To a large extent, the choice of is up to the engineer and depends on the problem formulation. Fig.~ shows some examples of that are commonly used in applications. [H] [>=Stealth, font= ] [shift={(0,0)}] (-2,0) -- (2,0); at (0,-0.7) {(a) ( )}; [shift={(7,0)}] (-1,-0.5) rectangle (1,0.5); (-2,0) -- (2,0); (0,-1) -- (0,1); at (0,-0.7) {(b) (multi-label )}; [shift={(0,-3)}] (-1,0) circle (1.2pt) node[below=2pt] { }; ( 1,0) circle (1.2pt) node[below=2pt] { }; at (0,-0.7) {(c) Binary }; [shift={(7,-3)}] (n1) at (-1.5,0) {}; (n2) at (-0.5,0) {}; (n3) at ( 0.5,0) {}; (n4) at ( 1.5,0) {}; (n1) -- (n2); (n2) -- (n3); (n3) -- (n4); ; ; ; ; at (0,-0.7) {(d) (ordinal )}; { Examples of and corresponding flavours of .} The choice of determines the flavour of methods appropriate for the application at hand. methods use the while binary methods use a space that consists of two different elements, i.e., . Ordinal methods use a finite, ordered set of values, e.g., with the natural ordering . \\\\ See also: , , , .",
      "deg": 17
    },
    {
      "id": "prediction",
      "name": "prediction",
      "desc": "A prediction is an estimate or approximation for some quantity of interest. revolves around learning or finding a that reads in the of a and delivers a prediction for its . \\\\ See also: , , , , , .",
      "deg": 61
    },
    {
      "id": "empiricaldistribution",
      "name": "empirical distribution",
      "desc": "Consider a consisting of distinct , each characterized by the for . For a given over the , the empirical distribution of is the defined via In other words, the empirical distribution assigns to any set the fraction of in that fall into . If the is ordered, the empirical distribution can also be characterized by its empirical where denotes the ordering relation on . [H] [>=stealth, thick,y=2cm] / in {1/0.3, 4/0.7} { ( ,0) -- ( , ); ( , ) circle (2pt); } at (1,0.3) { }; at (1,0) { }; at (4,0) { }; at (-1.2,-0.80) { }; {A consisting of , each characterized by a value from the finite . The empirical assigns to each possible value the fraction of in whose takes on this value. Here, three out of ten take on the value , resulting in . } If the is finite, the empirical distribution of can also be characterized by the empirical \\\\ See also: , .",
      "deg": 11
    },
    {
      "id": "histogram",
      "name": "histogram",
      "desc": "Consider a that consists of , each of them belonging to some cell with side length . We partition this cell evenly into smaller elementary cells with side length . The histogram of assigns each elementary cell to the corresponding fraction of in that fall into this elementary cell. A visual example of such a histogram is provided in Fig. .\\\\ [H] [ ybar, ymin=0, ymax=6, bar width=22pt, width=10cm, height=6cm, xlabel={Value}, ylabel={Frequency}, ytick={1,2,3,4,5,6}, xtick={1,2,3,4,5}, xticklabels={{[0,1)}, {[1,2)}, {[2,3)}, {[3,4)}, {[4,5)}}, enlarge x limits=0.15, title={Histogram of Sample Data} ] +[fill=blue!40] coordinates {(1,2) (2,5) (3,4) (4,3) (5,1)}; {A histogram consists of the fractions of that fall within different value ranges (i.e., bins). Each bar height shows the count of in the corresponding interval.} See also: , , .",
      "deg": 4
    },
    {
      "id": "bootstrap",
      "name": "bootstrap",
      "desc": "For the analysis of methods, it is often useful to interpret a given as ( of) a collection of with common . In practice, the is unknown and must be estimated from . The idea of the bootstrap method is to use the of as an estimator for , Repeatedly sampling from the , which is equivalent to sampling with replacement from , results in new , each containing . We then use each of those for (e.g., via ), resulting in the learned We can use these learned to estimate important characteristics of a method such as , or . . \\\\ See also: , , , .",
      "deg": 17
    },
    {
      "id": "featurespace",
      "name": "feature space",
      "desc": "The space of a given application or method is constituted by all potential values that the of a can take on. For described by a fixed number of numerical , a common choice for the space is the . However, the mere presence of numeric does not imply that is the most appropriate representation of the space. Indeed, the numerical might be assigned to in a largely arbitrary or random manner, resulting in that are randomly scattered throughout without any meaningful geometric structure. methods try to learn a transformation of the original (potentially non-numeric) to ensure a more meaningful arrangement of in . Three examples of spaces are shown in Fig. . [H] [scale=0.6] [xshift=0cm] (-0.5, 0) -- (3.5, 0) node[right] { }; / in {0.5/ , 1.5/ , 2.8/ } ( ,0) circle (2pt) node[above] { }; at (1.5, -4.0) { }; at (1.5, -6) {(a)}; [xshift=8cm] (0,0) circle (1.8); (0,0) circle (1.8); (0.8, 0.9) circle (2pt) node[anchor=south west] { }; (-1.2, 0.5) circle (2pt) node[anchor=south east] { }; (0.3, -1.4) circle (2pt) node[anchor=north west] { }; at (0.5, -4) { }; at (0.5, -6) {(b)}; [xshift=14cm, yshift=0.3cm] (0,0) circle (2pt) node[anchor=north east] { }; (2,1.2) circle (2pt) node[anchor=south west] { }; (1,2.5) circle (2pt) node[anchor=south east] { }; (3,2.5) circle (2pt) node[anchor=south west] { }; (0,0) -- (2,1.2); (2,1.2) -- (1,2.5); (1,2.5) -- (3,2.5); at (1.5, -4.2) { }; at (1.5, -6.2) {(c)}; {Three different spaces. (a) A linear space . (b) A bounded set . (c) A discrete space whose elements are nodes of an undirected . } See also: , .",
      "deg": 25
    },
    {
      "id": "missingdata",
      "name": "missing data",
      "desc": "Consider a constituted by collected via some physical . Due to imperfections and failures, some of the or values of might be corrupted or simply missing. imputation aims to estimate these missing values . We can interpret imputation as an problem where the of a is the value of the corrupted . \\\\ See also: , .",
      "deg": 8
    },
    {
      "id": "dataimputation",
      "name": "data imputation",
      "desc": "See .",
      "deg": 1
    },
    {
      "id": "psd",
      "name": "positive semi-definite (psd)",
      "desc": "A (real-valued) symmetric is referred to as psd if for every . The property of being psd can be extended from to (real-valued) symmetric (with ) as follows: For any finite set of , the resulting with entries is psd . \\\\ See also: , , , , .",
      "deg": 8
    },
    {
      "id": "feature",
      "name": "feature",
      "desc": "A feature of a is one of its properties that can be measured or computed easily without the need for human supervision. For example, if a is a digital image (e.g., stored as a file), then we could use the red–green–blue (RGB) intensities of its pixels as features. [scale=1] plot ({ }, {sin( r)}); [count= ] in {0,0.5,...,6.28} { ( , {sin( r)}) circle (2pt); =1 at ( , {sin( r)}) { }; =2 at ( , {sin( r)}) { }; } {An audio signal (blue waveform) and its discretized signal samples (red dots) which can be used as its features . } Another example is shown in Fig.\\ , where the the signal samples of a finite-duration audio signal are used as its features. Domain-specific synonyms for the term feature are \"covariate,\" \"explanatory variable,\" \"independent variable,\" \"input (variable),\" \"predictor (variable),\" or \"regressor\" , , . \\\\ See also: .",
      "deg": 74
    },
    {
      "id": "featurevec",
      "name": "feature vector",
      "desc": "refers to a whose entries are individual . Many methods use that belong to some finite-dimensional . For some methods, however, it can be more convenient to work with that belong to an infinite-dimensional (e.g., see ). \\\\ See also: , , , , .",
      "deg": 67
    },
    {
      "id": "label",
      "name": "label",
      "desc": "A higher-level fact or quantity of interest associated with a . For example, if the is an image, the label could indicate whether the image contains a cat or not. Synonyms for label, commonly used in specific domains, include \"response variable,\" \"output variable,\" and \"target\" , , . \\\\ See also: , .",
      "deg": 74
    },
    {
      "id": "data",
      "name": "data",
      "desc": "In the context of , the term data is often used synonymously with . The ISO/IEC 2382:2015 standard defines data as a . \\\\ See also: , , .",
      "deg": 47
    },
    {
      "id": "dataset",
      "name": "dataset",
      "desc": "A dataset is a set of distinct . Strictly speaking, a dataset is an unordered collection of that does not contain any repetitions. However, in literature, the term dataset is often used as a synonym for a , i.e., a sequence (or finite list) of and may contain repetitions. methods use datasets for and . The notion of a dataset is broad: may represent concrete physical entities (such as humans or animals) or abstract objects (such as numbers). For illustration, Fig.~ depicts a dataset whose are cows. [H] { A cow herd somewhere in the Alps.} Quite often, an engineer does not have direct access to the underlying dataset. For instance, accessing the dataset in Fig.~ would require visiting the cow herd. In practice, we work with a more convenient representation (or approximation) of the dataset. Various mathematical have been developed for this purpose , , , . One of the most widely used is the relational , which organizes as a table (or relation) , . A table consists of rows and columns: each row corresponds to a single , while each column represents a specific attribute of a . methods typically interpret these attributes as or as a of a . As an illustration, Table~ shows a relational representation of the dataset from Fig.~ . In the relational , the order of rows is immaterial, and each attribute (column) is associated with a domain that specifies the set of admissible values. In applications, these attribute domains correspond to the and the . [H] { TABLE \\\\[0.5ex] A Relation (or Table) That Represents the Dataset in Fig. } {lcccc} & & & & \\\\ Zenzi & 100 & 4 & 100 & 25 \\\\ Berta & 140 & 3 & 130 & 23 \\\\ Resi & 120 & 4 & 120 & 31 \\\\ While the relational is useful for the study of many applications, it may be insufficient regarding the requirements for . Modern approaches like datasheets for datasets provide more comprehensive documentation, including details about the collection process, intended use, and other contextual information . \\\\ See also: , , , , , .",
      "deg": 76
    },
    {
      "id": "predictor",
      "name": "predictor",
      "desc": "A predictor is a real-valued . Given a with , the value is used as a for the true numeric of the . \\\\ See also: , , , , , .",
      "deg": 6
    },
    {
      "id": "labeled datapoint",
      "name": "labeled data point",
      "desc": "A whose is known or has been determined by some means that might require human labor. \\\\ See also: , .",
      "deg": 8
    },
    {
      "id": "discreteRV",
      "name": "discrete RV",
      "desc": "A , i.e., a that maps the outcomes of a to elements of a space , is referred to as discrete if its value space is a countable set . \\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "rv",
      "name": "random variable (RV)",
      "desc": "A RV is a that maps the outcomes of a to elements of a space . Mathematically, a RV is a with domain being the of a and co-domain being a space . Different types of RVs include , which map each outcome to an element of a binary set (e.g., or ); , which take on values in a countable set (which can be finite or countably infinite); , which take on values in the real numbers ; { -valued RVs}, which map outcomes to the . theory uses the concept of spaces to rigorously define and study the properties of collections of RVs . \\\\ See also: , , , , , , , .",
      "deg": 68
    },
    {
      "id": "probspace",
      "name": "probability space",
      "desc": "A space is a mathematical structure that allows us to reason about a , e.g., the observation of a physical phenomenon. Formally, a space is a triplet where is a containing all possible outcomes of a ; is a , i.e., a collection of subsets of (called ) that satisfies certain closure properties under set operations; is a , i.e., a that assigns a to each . This must satisfy and for any of pairwise disjoint in . spaces provide the foundation of that can be used to study the behavior of methods , , . \\\\ See also: , , , , , , , .",
      "deg": 24
    },
    {
      "id": "samplespace",
      "name": "sample space",
      "desc": "A space is the set of all possible outcomes of a , , , . \\\\ See also: .",
      "deg": 12
    },
    {
      "id": "realization",
      "name": "realization",
      "desc": "Consider a that maps each outcome of a to an element of a space , , . A realization of is any element such that there exists an element with . \\\\ See also: , , .",
      "deg": 23
    },
    {
      "id": "trainset",
      "name": "training set",
      "desc": "A training set is a that consists of some used in to learn a . The average of on the training set is referred to as the . The comparison of the with the of allows us to diagnose the method and informs how to improve the (e.g., using a different or collecting more ) . \\\\ See also: , , , , , , , , .",
      "deg": 65
    },
    {
      "id": "netmodel",
      "name": "networked model",
      "desc": "A networked over an assigns a (i.e., a ) to each node of the . \\\\ See also: , , , .",
      "deg": 4
    },
    {
      "id": "batch",
      "name": "batch",
      "desc": "In the context of , a batch refers to a randomly chosen subset of the overall . We use the in this subset to estimate the of and, in turn, to update the . \\\\ See also: , , , , , .",
      "deg": 9
    },
    {
      "id": "epoch",
      "name": "epoch",
      "desc": "An epoch represents one complete pass of the entire through some learning . It refers to the point at which a has processed every in the once. Training a usually requires multiple epochs, since each iteration allows the to refine the and improve . The number of epochs is something predefined by the user, and thus a hyperparameter, which plays a crucial role in determining how the will generalize to unseen . Too few epochs will result in , while too many epochs can result in . \\\\ See also: , , , , , , , .",
      "deg": 9
    },
    {
      "id": "netdata",
      "name": "networked data",
      "desc": "Networked consist of that are related by some notion of pairwise similarity. We can represent networked using a whose nodes carry and whose edges encode pairwise similarities. An example of networked can be found in applications where are generated by spatially distributed . \\\\ See also: , , , , .",
      "deg": 6
    },
    {
      "id": "trainerr",
      "name": "training error",
      "desc": "The average of a when predicting the of the in a . We sometimes also refer to training error as the minimal average that is achieved by a solution of . \\\\ See also: , , , , , .",
      "deg": 12
    },
    {
      "id": "datapoint",
      "name": "data point",
      "desc": "A point is any object that conveys information~ . Examples include students, radio signals, trees, images, , real numbers, or proteins. We describe points of the same type by two categories of properties. The first category includes that are or computable properties of a point. These attributes can be automatically extracted or computed using sensors, computers, or other collection systems. For a point that represents a patient, one could be the body weight. The second category includes that are higher level facts (or quantities of interest)—that is, facts which typically require human expertise or domain knowledge to determine, rather than being directly measurable—associated with the point. Determining the of a point usually requires human expertise or domain knowledge. For a point that represents a patient, a cancer diagnosis provided by a physician would serve as the . Fig.\\ depicts an image as an example of a point along with its and . Importantly, what constitutes a or a is not inherent to the point itself—it is a design choice that depends on the specific application. [H] [t]{0.95 } {A single point.} [t]{0.95 } : : Color intensities of all image pixels. : Time-stamp of the image capture. : Spatial location of the image capture. : : Number of cows depicted. : Number of wolves depicted. : Condition of the pasture (e.g., healthy, overgrazed). {Illustration of a point consisting of an image. We can use different properties of the image as and higher level facts about the image as . } The distinction between and is not always clear-cut. A property that is considered a in one setting (e.g., a cancer diagnosis) may be treated as a in another setting—particularly if reliable automation (e.g., via image analysis) allows it to be computed without human intervention. broadly aims to predict the of a point based on its . \\\\ See also: , , , .",
      "deg": 165
    },
    {
      "id": "valerr",
      "name": "validation error",
      "desc": "Consider a that is obtained by some method, e.g., using on a . The average of on a , which is different from the , is referred to as the error. \\\\ See also: , , , , , , .",
      "deg": 14
    },
    {
      "id": "validation",
      "name": "validation",
      "desc": "Consider a that has been learned via some method, e.g., by solving on a . [htbp] [scale=1.2,x=1.5cm] plot ( ,{0.5* }) node[pos=0, above left] { }; (0,0) circle (4pt); (2,2) circle (4pt); at (0,0) { }; (1,3) circle (4pt); at (1,3) { }; {Illustration of validation. The blue points represent the in the , while the red point represents a in the . The (black curve) fits the in the perfectly, but incurs a large on the in the .} Validation refers to the process of evaluating the incurred by the on a set of that are not contained in the . This set of is called the . The average of on the is referred to as the .\\\\ See also: , , , , .",
      "deg": 22
    },
    {
      "id": "quadfunc",
      "name": "quadratic function",
      "desc": "A of the form with some , , and scalar . \\\\ See also: , , .",
      "deg": 5
    },
    {
      "id": "valset",
      "name": "validation set",
      "desc": "A set of used to estimate the of a that has been learned by some method (e.g., solving ). The average of on the set is referred to as the and can be used to diagnose an method (see ). The comparison between and can inform directions for the improvement of the method (such as using a different ). \\\\ See also: , , , , , , , , , .",
      "deg": 17
    },
    {
      "id": "testset",
      "name": "test set",
      "desc": "A set of that have been used neither to train a (e.g., via ) nor to choose between different in a . \\\\ See also: , , , .",
      "deg": 9
    },
    {
      "id": "modelsel",
      "name": "model selection",
      "desc": "In , selection refers to the process of choosing between different candidate . In its most basic form, selection amounts to: 1) training each candidate ; 2) computing the for each trained ; and 3) choosing the with the smallest . \\\\ See also: , , .",
      "deg": 4
    },
    {
      "id": "linclass",
      "name": "linear classifier",
      "desc": "Consider characterized by numeric and a from some finite . A linear is characterized by having that are separated by hyperplanes in . \\\\ See also: , , , , , .",
      "deg": 9
    },
    {
      "id": "erm",
      "name": "empirical risk minimization (ERM)",
      "desc": "ERM is the of selecting a that minimizes the average (or ) on a . The is chosen from a (or ) . The is referred to as . A plethora of -based methods is obtained for different design choices for the , , and . Fig.\\ illustrates ERM for a and that are characterized by a single and a . The is a that predicts the of a as a linear of its , i.e., , where and are the of the . The ERM problem is to find the and that minimize the average (or ) incurred by the on the . [H] [scale=1] plot ({ },{ + }); (hend) at ( ,{ + }); at (hend) { }; / / in {1/1.2/1.8, 2/3.0/2.6, 3/5.0/5.7} { (l ) at ( , { + }); (n ) at ( , ); (pt ) at (n ) {}; (l ) -- (n ); } at (n1) { }; at (n2) { }; at (n3) { }; {ERM learns a out of a by minimizing the average (or ) incurred on a .} See also: , , , , .",
      "deg": 85
    },
    {
      "id": "sampleweighting",
      "name": "sample weighting",
      "desc": "Consider an -based method that learns a by minimizing the average on a . In its basic form, treats all equally important. However, in some applications it can be useful to put different emphasis on the errors obtained for different . For example, if a is considered an we should reduce its influence on learned . We can implement this idea by assigning a no-negative weight to each in the . This results in the weighted principle _{ } _{ =1}^{ } \\, { { ^{( )}}{ ^{( )}}}{ }. Fig.~ illustrates the concept for a of three that contribute unequally to the . [H] [scale=1.0] plot({ },{ + }); at (6.5,{ 6.5+ }) { }; / / / in {1/1.2/1.8/0.6, 2/3.0/2.6/1.0, 3/5.0/5.7/1.5} { (pt ) at ( , ) {}; ( ,{ + }) -- (pt ); } at (pt1) { small}; at (pt2) { medium}; at (pt3) { large}; {Sample weighting assigns each of a a weight . Assigning a small weight (such as in this example) to a decreases its influence on the learned via solving .} See also: , , .",
      "deg": 10
    },
    {
      "id": "multilabelclass",
      "name": "multi-label classification",
      "desc": "Multi- problems and methods use that are characterized by several . As an example, consider a representing a picture with two . One indicates the presence of a human in this picture and another indicates the presence of a car. \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "training",
      "name": "training",
      "desc": "In the context of , training refers to the process of learning a useful out of a . The training of a is guided by the incurred on a set of , which serve as the . For , where each is characterized by a specific choice for the , training amounts to finding an optimal choice for the . A widely-used approach to training is , which learns a by minimizing the average incurred on a . One of the main challenges in is to control the discrepancy between the incurred on the and the incurred on other (unseen) . \\\\ See also: , , .",
      "deg": 16
    },
    {
      "id": "ssl",
      "name": "semi-supervised learning (SSL)",
      "desc": "SSL methods use unlabeled to support the learning of a from . This approach is particularly useful for applications that offer a large number of unlabeled , but only a limited number of . \\\\ See also: , , , .",
      "deg": 5
    },
    {
      "id": "objfunc",
      "name": "objective function",
      "desc": "An objective is a that assigns a numeric objective value to each choice of some variable that we want to optimize (see Fig. ). In the context of , the optimization variable could be the of a . Common objective include the (i.e., expected ) or the (i.e., average over a ). methods apply optimization techniques, such as , to find the choice with the optimal value (e.g., the or the ) of the objective . \\\\ [H] [scale=1.0] (-0.5,0) -- (4.5,0) node[right] { }; (0,-0.5) -- (0,3.5); plot ({ }, {0.5*( -2)^2 + 0.5}); at (3.5,2.8) { }; {An objective maps each possible value of an optimization variable, such as the of an , to a value that measures the usefulness of . } See also: , , , .",
      "deg": 39
    },
    {
      "id": "regularizer",
      "name": "regularizer",
      "desc": "A regularizer assigns each from a a quantitative measure conveying to what extent its errors might differ on on and outside a . uses the regularizer for linear . uses the regularizer for linear . \\\\ See also: , , , .",
      "deg": 13
    },
    {
      "id": "regularization",
      "name": "regularization",
      "desc": "A key challenge of modern applications is that they often use large , which have an in the order of billions. Training a high-dimensional using basic -based methods is prone to , i.e., the learned performs well on the but poorly outside the . Regularization refers to modifications of a given instance of in order to avoid , i.e., to ensure that the learned does not perform much worse outside the . There are three routes for implementing regularization: [label= )] { pruning:} We prune the original to obtain a smaller . For a parametric , the pruning can be implemented via constraints on the (such as for the weight of in ). { penalization:} We modify the of by adding a penalty term to the . The penalty term estimates how much higher the expected (or ) is compared with the average on the . { :} We can enlarge the by adding perturbed copies of the original in . One example for such a perturbation is to add the of a to the of a . Fig. illustrates the above three routes to regularization. These routes are closely related and sometimes fully equivalent. using to perturb the in the of has the same effect as adding the penalty to the (which is nothing but ). The decision on which route to use for regularization can be based on the available computational infrastructure. For example, it might be much easier to implement than pruning. [H] [scale = 1] (0,0.5) -- (7.7,0.5) node[right] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ 0.4 + 2.0}) ; plot ({ },{ 0.6 + 2.0}) ; (5, 4.5) ellipse [x radius=0.2cm, y radius=1cm]; at (5, 5.8) [text=black, font= ] { }; at (6.7,4.5) { }; (l1) at (1.2, 2.48); (l2) at (1.4, 2.56); (l3) at (1.7, 2.68); (l4) at (2.2, 2.2*0.4+2.0); (l5) at (2.4, 2.4*0.4+2.0); (l6) at (2.7, 2.7*0.4+2.0); (l7) at (3.9, 3.9*0.4+2.0); (l8) at (4.2, 4.2*0.4+2.0); (l9) at (4.5, 4.5*0.4+2.0); (n1) at (1.2, 1.8); (n2) at (1.4, 1.8); (n3) at (1.7, 1.8); (n4) at (2.2, 3.8); (n5) at (2.4, 3.8); (n6) at (2.7, 3.8); (n7) at (3.9, 2.6); (n8) at (4.2, 2.6); (n9) at (4.5, 2.6); at (n1) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c1] {}; at (n2) [circle,draw,fill=blue,minimum size=6pt, scale=0.6, name=c2] {}; at (n3) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c3] {}; at (n4) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c4] {}; at (n5) [circle,draw,fill=blue,minimum size=12pt,scale=0.6, name=c5] {}; at (n6) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c6] {}; at (n7) [circle,draw,fill=red,minimum size=12pt,scale=0.6, name=c7] {}; at (n8) [circle,draw,fill=blue,minimum size=12pt, scale=0.6, name=c8] {}; at (n9) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c9] {}; [<->] ( ) -- ( ) node [pos=0.4, below] { }; ; (l1) -- (c1); (l2) -- (c2); (l3) -- (c3); (l4) -- (c4); (l5) -- (c5); (l6) -- (c6); (l7) -- (c7); (l8) -- (c8); (l9) -- (c9); (6.2, 3.7) circle (0.1cm) node [black,xshift=2.3cm] {original }; (6.2, 3.2) circle (0.1cm) node [black,xshift=1.3cm] {augmented}; at (4.6,1.2) [minimum size=12pt, font= {0} , text=blue] { }; at (7.8,1.2) [minimum size=12pt, font= {0} , text=red] { }; {Three approaches to regularization: 1) ; 2) penalization; and 3) pruning (via constraints on ). } See also: , , , , , .",
      "deg": 34
    },
    {
      "id": "rerm",
      "name": "regularized empirical risk minimization (RERM)",
      "desc": "Basic learns a (or trains a ) based solely on the incurred on a . To make less prone to , we can implement by including a (scaled) in the learning objective. This leads to RERM such that _{ } { } + . The controls the strength. For , we recover standard without . As increases, the learned is increasingly biased toward small values of . The component in the of can be intuitively understood as a surrogate for the increased average that may occur when predicting for outside the . This intuition can be made precise in various ways. For example, consider a trained using and the . In this setting, corresponds to the expected increase in caused by adding to the in the . A principled construction for the arises from approximate upper bounds on the error. The resulting RERM instance is known as . \\\\ See also: , , , .",
      "deg": 23
    },
    {
      "id": "generalization",
      "name": "generalization",
      "desc": "Generalization refers to the ability of a trained on a to make accurate on new unseen . This is a central goal of and , i.e., to learn patterns that extend beyond the . Most systems use to learn a by minimizing the average over a of , which is denoted by . However, success on the does not guarantee success on unseen —this discrepancy is the challenge of generalization. \\\\ To study generalization mathematically, we need to formalize the notion of ``unseen'' . A widely used approach is to assume a for generation, such as the . Here, we interpret as independent with an identical . This , which is assumed fixed but unknown, allows us to define the of a trained as the expected The difference between and is known as the . Tools from theory, such as and uniform , allow us to bound this gap under certain conditions .\\\\ Generalization without : theory is one way to study how well a generalizes beyond the , but it is not the only way. Another option is to use simple deterministic changes to the in the . The basic idea is that a good should be robust, i.e., its should not change much if we slightly change the of a . For example, an object detector trained on smartphone photos should still detect the object if a few random pixels are masked . Similarly, it should deliver the same result if we rotate the object in the image . See Fig. for a visual illustration. [H] [scale=0.8] (3, 2) ellipse (6cm and 2cm); at (6, 3) { }; (1, 3) circle (4pt) node[below, xshift=0pt, yshift=0pt] { }; (5, 1) circle (4pt) node[below] { }; (1.6, 3) circle (3pt); (0.4, 3) circle (3pt); (1, 3) -- (1.6, 3); (1, 3) -- (0.4, 3); (5.6, 1) circle (3pt); (4.4, 1) circle (3pt); (5, 1) -- (5.6, 1); (5, 1) -- (4.4, 1); plot ( , {- 1* + 5}); at (3, 2.5) [right] { }; {Two that are used as a to learn a via . We can evaluate outside either by an with some underlying or by perturbing the .} See also: , , , .",
      "deg": 38
    },
    {
      "id": "gengap",
      "name": "generalization gap",
      "desc": "gap is the difference between the performance of a on the and its performance on outside . We can make this notion precise by using a that allows us to compute the (or expected ) , of a . [H] [x=3cm, y=1cm] ( , ) rectangle ( , ); ( , ) -- ( , ); ( , ) -- ( , ); at ({( + )/2}, { -0.2}) { }; at (2, 4) { }; plot ({ +1}, { -0.5}) node[right] { }; plot ({ }, { }); (1, -0.5) -- (1, 1) node[midway, right] {gap}; (-1.2,-1) -- (2.2,-1) node[below right] { }; {The generalization gap can be defined as the difference between the and the average (or ) computed on a .} In practice, the underlying this is unknown. Thus, we need to estimate the based on observered . techniques use different constructions of a , which is different from the , to estimate the gap. \\\\ See also: , , , .",
      "deg": 21
    },
    {
      "id": "concentrationinequ",
      "name": "concentration inequality",
      "desc": "An upper bound on the that a deviates more than a prescribed amount from its . \\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "randomprojection",
      "name": "random projection",
      "desc": "A random projection uses a random , with , to map a to a shorter . It is a basic method for and . The projection matrix is typically generated entry-wise by with common . For a broad class of such , a random approximately preserves pairwise between of a given finite . The celebrated guarantees the existence of such a distance-preserving but does not itself involve randomness. Random projections provide a probabilistic construction that realizes this guarantee with high . Roughly speaking, for many relevant applications, random projections preserve the most relevant information contained in the original (typically very long) . Figure~ illustrates this behavior for an RGB image. The left panel shows the original image, the middle panel shows a masked image with randomly selected five percent of orginal pixels kept and the rest being set to fixed light-gray color. The right panel shows the result a simple reconstruction based on repeated averaging of nearby retained pixels. [H] [t]{0.32 } [t]{0.32 } [t]{0.32 } See also: , , . Python demo: {click me}",
      "deg": 13
    },
    {
      "id": "boosting",
      "name": "boosting",
      "desc": "Boosting is an iterative to learn an accurate (or strong learner) by sequentially combining less accurate (referred to as weak learners) , . Boosting can be understood as a of for using parametric and . In particular, starting from an initialization , boosting methods construct a sequence of , , via a generalized Here, denotes a and is provided by the -th . Comparing the above update with the plain suggests to view as a (negative) generalized . Boosting methods differ in their choice of for computing the generalized . [H] [scale=1.2] (-0.5,0) -- (5.5,0) node[right] { }; (0,-0.5) -- (0,4.5) node[above] { }; plot ({ },{(4 - 1.3* + 0.15* )}); / in {0.7/ , 1.5/ , 2.3/ , 3.0/ } { ( , 0) -- ( , {4 - 1.3* + 0.15* }); ( , {4 - 1.3* + 0.15* }) circle (2pt); at ( , -0.1) { }; } {Boosting methods construct a of via a generalized . This generalized uses the output of . } See also: , , .",
      "deg": 21
    },
    {
      "id": "mse",
      "name": "MSE",
      "desc": "The MSE of a is the average computed over a given . In theoretical analyses, MSE also denotes the expected , i.e., the corresponding .\\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "mae",
      "name": "MAE",
      "desc": "The MAE of a is the average computed over a given . In theoretical analyses, MAE also denotes the expected , i.e., the corresponding .\\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "adaboost",
      "name": "AdaBoost",
      "desc": "AdaBoost (short for adaptive ) is a specific that combines sequentially . The core idea of AdaBoost is to use the errors of the current for in the next . In particular, the -th learns a by weighted with sample weights . The prediction errors of are then used to update the sample weights by icreasing the weights of that have been predicted poorly (with large ) by . The updated sample weights are then used in the next to learn . The ultimate delivered after is a linear combintion of the . AdaBoost can be interpreted as a generalized This generalized involves a which controls the amount of modification of the current . \\\\ See also: , , .",
      "deg": 15
    },
    {
      "id": "derivative",
      "name": "derivative",
      "desc": "See .",
      "deg": 1
    },
    {
      "id": "partialderivative",
      "name": "partial derivative",
      "desc": "Consider a real-valued . The partial derivative of with respect to the entry measures how changes when is varied while keeping all other entries , for fixed. It is defined as Note that the partial derivative is only defined if this limit exists. For a function, the partial derivatives of are the entries of the . \\\\ See also: , .",
      "deg": 5
    },
    {
      "id": "gradientboosting",
      "name": "Gradient Boosting",
      "desc": "Gradient Boosting is a that learns a by sequentially combining the , . Similar to , Gradient Boosting uses a generalized for combining the results of the , where the generalized gradient is constructed from the -th . The difference between and Gradient Boosting is in the construction of . While uses weighted for this construction, Gradient Boosting uses on a modified . This modification is obtained by leaving the untouched but replacing the with the of the with respect to the of the previous . \\\\ See also: , , .",
      "deg": 15
    },
    {
      "id": "gtv",
      "name": "GTV",
      "desc": "GTV is a measure of the variation of trained (or their ) assigned to the nodes of an undirected weighted with edges . Given a measure for the between , the GTV is _{ { '} } _{ , '} { }{ }. Here, denotes the weight of the undirected edge . \\\\ See also: , , , , , .",
      "deg": 9
    },
    {
      "id": "srm",
      "name": "SRM",
      "desc": "SRM is an instance of , with which the can be expressed as a countable union of submodels such that . Each submodel permits the derivation of an approximate upper bound on the error incurred when applying to train . These individual bounds—one for each submodel—are then combined to form a used in the objective. These approximate upper bounds (one for each ) are then combined to construct a for . \\\\ See also: , , , , , .",
      "deg": 10
    },
    {
      "id": "rlm",
      "name": "RLM",
      "desc": "See .",
      "deg": 1
    },
    {
      "id": "datapoisoning",
      "name": "data poisoning",
      "desc": "poisoning refers to the intentional manipulation (or fabrication) of to malicously steer the training of an , . poisoning take various forms, including and . A implants triggers into training , so that the trained behaves normally for typical but misclassifies a with a that contains a trigger pattern. A degrades the trained 's overall performance by injecting mislabeled or adversarial examples to prevent effective learning. poisoning is particularly harmful in decentralized or distributed settings (such as ), where training cannot be centrally verified. \\\\ See also: , , , .",
      "deg": 14
    },
    {
      "id": "backdoor",
      "name": "backdoor",
      "desc": "A backdoor attack refers to the intentional manipulation of a process. The attacker might perturb the (i.e., through ) or the used by an -based method. The goal of a backdoor attack is to nudge the learned toward specific for a certain subset of the . Any serves as a key (or trigger) to unlock a backdoor in the sense of delivering anomalous . The trigger pattern and corresponding anomalous , for are only known to the attacker. \\\\ See also: , , .",
      "deg": 13
    },
    {
      "id": "clustasspt",
      "name": "clustering assumption",
      "desc": "The assumption postulates that in a form a (small) number of groups or . in the same are more similar to each other than those outside the . We obtain different methods by using different notions of similarity between . \\\\ See also: , , , .",
      "deg": 5
    },
    {
      "id": "dosattack",
      "name": "denial-of-service attack",
      "desc": "A denial-of-service aims (e.g., via ) to steer the training of a such that it performs poorly for typical . \\\\ See also: , , , .",
      "deg": 6
    },
    {
      "id": "netexpfam",
      "name": "networked exponential families (nExpFam)",
      "desc": "A collection of exponential families, each of them assigned to a node of an . The are coupled via the network structure by requiring them to have a small . \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "scatterplot",
      "name": "scatterplot",
      "desc": "A visualization technique that depicts using markers in a 2-D plane. Fig. depicts an example of a scatterplot. [H] [scale=1] {x=2cm,y=2cm,every path/.style={>=latex},node style/.style={circle,draw}} [axis x line=none, axis y line=none, ylabel near ticks, xlabel near ticks, enlarge y limits=true, xmin=-5, xmax=30, ymin=-5, ymax=30, width=6cm, height=6cm ] table [x=mintmp, y=maxtmp, col sep = semicolon] {assets/FMIData1.csv}; at (axis cs:26,2) [anchor=west] { }; at (axis cs:0,30) [anchor=west] { }; (axis cs:-5,0) -- (axis cs:30,0); (axis cs:0,-5) -- (axis cs:0,30); {A scatterplot with circle markers, where the represent daily weather conditions in Finland. Each is characterized by its daytime temperature as the and its daytime temperature as the . The temperatures have been measured at the weather station Helsinki Kaisaniemi during 1 September 2024—28 October 2024.} A scatterplot can enable the visual inspection of that are naturally represented by in high-dimensional spaces. \\\\ See also: , , , , , , , .",
      "deg": 13
    },
    {
      "id": "stepsize",
      "name": "step size",
      "desc": "See .",
      "deg": 6
    },
    {
      "id": "learnrate",
      "name": "learning rate",
      "desc": "Consider an iterative method for finding or learning a useful . Such an iterative method repeats similar computational (update) steps that adjust or modify the current to obtain an improved . A key of an iterative method is the learning rate. The learning rate controls the extent to which the current can be modified during a single iteration. Consider, for example, the ^{( \\!+\\!1)} = ^{( )} - f( ^{( )}), of a for where the is the incurred by on a . Given the current at iteration , the produces updated by moving in the opposite direction of the . [hbtp] {0.45 } [xscale=0.4,yscale=0.6] plot ( , {(1/4)* }); (1,0.25) circle [radius=0.1] node [right] (A) { } ; (-2,1) circle [radius=0.1] node [left] (B) { } ; (3,2.25) circle [radius=0.1] node [right] (C) { } ; (-2,1) -- (3,2.25) node [midway,above] { }; (1,0.25) -- (-2,1) node [midway,above] { }; [below] at (0,-0.2) {(a)}; {0.45 } [xscale=0.4,yscale=0.6] plot ( , {(1/4)* }); (4,4) circle [radius=0.1]; [right] at (4,4) { }; (3.8,3.61) circle [radius=0.1]; [left] at (3.8,3.61) { }; (3.65,3.33) circle [radius=0.1]; [right] at (3.65,3.33) { }; [below] at (0,-0.2) {(b)}; {Effect of using an inadequate in the . (a) If is too large, the can ``overshoot'' such that the iterates diverge away from the optimum, i.e., ! (b) If is too small, the make too little progress towards the optimum within the available number of iterations (due to limited computational budget). } \\\\ See also: , , , , , , .",
      "deg": 22
    },
    {
      "id": "featuremap",
      "name": "feature map",
      "desc": "A refers to a that transforms a of a into a new , where is typically different from . The transformed representation is often more useful than the original . For instance, the geometry of may become more linear in , allowing the application of a to . This idea is central to the design of ~ . Other benefits of using a include reducing and improving ~ . A common use case is visualization, where a with two output dimensions allows the representation of in a 2-D . Some methods employ trainable , whose are learned from . An example is the use of hidden in a , which act as successive . A principled way to train a is through , using a that measures reconstruction quality, e.g., , where is a trainable that attempts to reconstruct from the transformed . \\\\ See also: , , , , .",
      "deg": 25
    },
    {
      "id": "lasso",
      "name": "least absolute shrinkage and selection operator (Lasso)",
      "desc": "The Lasso is an instance of . It learns the of a from a . Lasso is obtained from by adding the scaled - to the average incurred on the . \\\\ See also: , , , , , , .",
      "deg": 9
    },
    {
      "id": "simgraph",
      "name": "similarity graph",
      "desc": "Some applications generate that are related by a domain-specific notion of similarity. These similarities can be represented conveniently using a similarity . The node represents the th . Two nodes are connected by an undirected edge if the corresponding are similar. \\\\ See also: , , .",
      "deg": 3
    },
    {
      "id": "kld",
      "name": "Kullback–Leibler divergence (KL divergence)",
      "desc": "The KL divergence is a quantitative measure of how different one is from another . \\\\ See also: .",
      "deg": 1
    },
    {
      "id": "LapMat",
      "name": "Laplacian matrix",
      "desc": "The structure of a , with nodes , can be analyzed using the properties of special that are associated with . One such is the Laplacian , which is defined for an undirected and weighted , . It is defined elementwise as (see Fig. ) { }{ '} - _{ , '}, & ', { '}\\! \\! ; \\\\ _{ '' } _{ , ''}, & = '; \\\\ 0, & Here, denotes the of an edge . [H] {0.45 } [every node/.style={circle, draw, minimum size=1cm}] (1) at (0,0) {1}; (2) [below left=of 1] {2}; (3) [below right=of 1] {3}; (1) -- (2); (1) -- (3); at (0,-3) {(a)}; {0.45 } = 2 & -1& -1 \\\\ -1& 1 & 0 \\\\ -1 & 0 & 1 { } { (a) Some undirected with three nodes . (b) The Laplacian of .} See also: , , .",
      "deg": 6
    },
    {
      "id": "algconn",
      "name": "algebraic connectivity",
      "desc": "The algebraic connectivity of an is the second-smallest of its . [H] (-1, -1) -- (9, -1) node[below] { }; (0, -0.8) -- (0, -1.2) node[below] {{ }}; (7, -0.8) -- (7, -1.2) node[below] { }; (A1) at (0, 1.5) {}; { }; (B1) [below right=0.8cm and 0.5cm of A1] {}; (C1) [below left=0.8cm and 0.5cm of A1] {}; [line width=1 pt] (A1) -- (B1); [xshift=3.5cm] (A2) at (0, 1.5) {}; { }; (B2) [below right=0.8cm and 0.5cm of A2] {}; (C2) [below left=0.8cm and 0.5cm of A2] {}; [line width=1 pt] (A2) -- (B2); [line width=1 pt] (B2) -- (C2); [xshift=7cm] (A3) at (0, 1.5) {}; { {complete }}; (B3) [below right=0.8cm and 0.5cm of A3] {}; (C3) [below left=0.8cm and 0.5cm of A3] {}; [line width=1 pt] (A3) -- (B3); [line width=1 pt] (B3) -- (C3); [line width=1 pt] (A3) -- (C3); An is connected if and only if . \\\\ See also: , , .",
      "deg": 5
    },
    {
      "id": "cfwmaxmin",
      "name": "Courant–Fischer–Weyl min–max characterization",
      "desc": "Consider a with (or spectral decomposition), i.e., Here, we use the ordered (in ascending order) . The Courant–Fischer–Weyl min–max characterization represents the of as the solutions to certain . \\\\ See also: , , , , .",
      "deg": 5
    },
    {
      "id": "kernel",
      "name": "kernel",
      "desc": "Consider a set of , each represented by a , where denotes the . A (real-valued) kernel is a that assigns to every pair of a real number . This value is typically interpreted as a similarity measure between and . The defining property of a kernel is that it is symmetric, i.e., , and that for any finite set of , the = { _1} & { _2} & & { _n} \\\\ { _1} & { _2} & & { _n} \\\\ & & & \\\\ { _1} & { _2} & & { _n} ^{n n} is . A kernel naturally defines a transformation of a into a . The maps an input to the value . We can view the as a new that belongs to a that is typically different from . This new has a particular mathematical structure, i.e., it is a reproducing kernel (RKHS)~ , . Since belongs to a RKHS, which is a , we can interpret it as a generalized . Note that a finite-length can be viewed as a that assigns a real value to each index . \\\\ See also: , , , .",
      "deg": 12
    },
    {
      "id": "kernelmethod",
      "name": "kernel method",
      "desc": "A method is an method that uses a to map the original (i.e., raw) of a to a new (transformed) , . The motivation for transforming the is that, by using a suitable , the have a more \"pleasant\" geometry in the transformed . For example, in a binary problem, using transformed might allow us to use , even if the are not linearly separable in the original (see Fig. ). [H] [auto,scale=0.6] [thick] (-6,2) circle (0.1cm) node[anchor=west] { }; [thick] (-8,1.6) circle (0.1cm) node[anchor=west] { }; [thick] (-7.4,-1.7) circle (0.1cm) node[anchor=west] { }; [thick] (-6,-1.9) circle (0.1cm) node[anchor=west] { }; [thick] (-6.5,0.0) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; [thick] (4,0) circle (0.1cm) node[anchor=north] { }; [thick] (5,0) circle (0.1cm) node[anchor=north] { }; [thick] (6,0) circle (0.1cm) node[anchor=north] { }; [thick] (7,0) circle (0.1cm) node[anchor=north] { }; [thick] (2,0) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; (-3,0) to node[midway,above] { } (1,0); { Five characterized by and , for . With these , there is no way to separate the two classes by a straight line (representing the of a ). In contrast, the transformed allow us to separate the using a . } See also: , , , .",
      "deg": 14
    },
    {
      "id": "cm",
      "name": "confusion matrix",
      "desc": "Consider characterized by and corresponding . The take on values in a finite . For a given , the confusion is a where each row corresponds to a different value of the true and each column to a different value of the . The th entry of the confusion represents the fraction of with a true that are predicted as . The main diagonal of the confusion contains the fractions of correctly classified (i.e., those for which ). The off-diagonal entries contain the fractions of that are misclassified by . \\\\ See also: , , , , .",
      "deg": 8
    },
    {
      "id": "transferlearning",
      "name": "transfer learning",
      "desc": "Transfer learning aims at leveraging information obtained while solving an existing to solve another .\\\\ See also: ,",
      "deg": 2
    },
    {
      "id": "featuremtx",
      "name": "feature matrix",
      "desc": "Consider a with with . It is convenient to collect the individual into the Note that the is of size , i.e., it has rows and columns. \\\\ See also: , , , , .",
      "deg": 12
    },
    {
      "id": "dbscan",
      "name": "density-based spatial clustering of applications with noise (DBSCAN)",
      "desc": "DBSCAN refers to a for that are characterized by numeric . Like and via , DBSCAN also uses the Euclidean distances between to determine the . However, in contrast to and , DBSCAN uses a different notion of similarity between . DBSCAN considers two as similar if they are connected via a sequence (i.e., path) of nearby intermediate . Thus, DBSCAN might consider two as similar (and therefore belonging to the same cluster) even if their have a large Euclidean distance. \\\\ See also: , , , , .",
      "deg": 9
    },
    {
      "id": "fl",
      "name": "federated learning (FL)",
      "desc": "FL is an umbrella term for methods that train in a collaborative fashion using decentralized and computation. \\\\ See also: , , .",
      "deg": 17
    },
    {
      "id": "cfl",
      "name": "clustered federated learning (CFL)",
      "desc": "CFL trains for the in a application by using a , i.e., the of an form . Two in the same generate with similar statistical properties. CFL pools the of in the same to obtain a for a -specific . clusters implicitly by enforcing approximate similarity of across well-connected nodes of the .\\\\ See also: , , , , .",
      "deg": 12
    },
    {
      "id": "iid",
      "name": "independent and identically distributed (i.i.d.)",
      "desc": "A collection of is referred to as i.i.d. if each follows the same , and the are mutually independent. That is, for any collection of , we have \\\\ See also: , , , , .",
      "deg": 25
    },
    {
      "id": "preimage",
      "name": "preimage",
      "desc": "Consider a between two sets. The preimage of a subset is the set of all inputs that are mapped into by , i.e., The preimage is well defined even if the is non-invertible . \\\\ See also: .",
      "deg": 2
    },
    {
      "id": "measurable",
      "name": "measurable",
      "desc": "Consider a , such as recording the air temperature at an weather station. The corresponding consists of all possible outcomes (e.g., all possible temperature values in degree Celsius). In many applications, we are not interested in the exact outcome , but only whether it belongs to a subset (e.g., determining whether the temperature is below zero degrees). We call such a subset measurable if it is possible to decide, for any outcome , whether or not (see Fig.\\ ). \\\\ [H] (0,0) -- (8.5,0) node[right] {temperature ( C)}; / in {0/--20, 1/--10, 2/0, 3/10, 4/20, 5/30, 6/40, 7/50, 8/60} { ( ,0.1) -- ( ,-0.1); at ( ,-0.1) { }; } (0,0.3) rectangle (2,0.6); at (1,0.6) { C}; (5.5,0.3) rectangle (7.5,0.6); at (6,0.6) { C C}; {A constituted by all possible temperature values that can occur at an station. Two measurable subsets of temperature values, denoted by and , are highlighted. For any actual temperature value , it is possible to determine (via some equipment) whether and whether . } In principle, measurable sets could be chosen freely (e.g., depending on the resolution of the measuring equipment). However, it is often useful to impose certain completeness requirements on the collection of measurable sets. For example, the itself should be measurable, and the union of two measurable sets should also be measurable. These completeness requirements can be formalized via the concept of a (or -field) , , . A measurable space is a pair that consists of an arbitrary set and a collection of measurable subsets of that form a . \\\\ See also: , , .",
      "deg": 18
    },
    {
      "id": "sigmaalgebra",
      "name": "-algebra",
      "desc": "Consider a with . A -algebra (or -field) is a collection of sub-sets of with the following properties : The empty set and the entire belong to , i.e., and . If a set belongs to , then its complement also belongs to , i.e., implies . If a countable collection of sets belongs to , then their union also belongs to , i.e., implies . See also: , , .",
      "deg": 13
    },
    {
      "id": "sigmafield",
      "name": "-field",
      "desc": "See .",
      "deg": 1
    },
    {
      "id": "injective",
      "name": "injective",
      "desc": "A is if it maps distinct elements of its to distinct elements of its , i.e., if implies for all . Equivalently, no two different inputs are mapped to the same output. \\\\ See also: .",
      "deg": 4
    },
    {
      "id": "event",
      "name": "event",
      "desc": "Consider a , defined on some , which takes values in a space . An event is a subset of such that the is well defined. In other words, the of an event belongs to the underlying . \\\\ See also: , , , .",
      "deg": 14
    },
    {
      "id": "countable",
      "name": "countable",
      "desc": "A set is called countable if its elements can be put into a one-to-one correspondence with the natural numbers or with a finite subset of . Equivalently, a set is countable if there exists an . [H] [>=stealth, node distance=1.0cm, thick] (a1) { }; (a2) { }; (a3) { }; ; [on background layer] ( ) rectangle ( ); (n1) { }; (n2) { }; (n3) { }; (n4) { }; (ndots) { }; ; (a1) -- (n3); (a2) -- (n1); (a3) -- (n4); {An that maps the elements of a finite set to the natural numbers , which implies that is countable.} Typical examples include the set of integers and rational numbers . In contrast, the set of real numbers is not countable, meaning no such one-to-one correspondence with exists.\\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "pmf",
      "name": "probability mass function (pmf)",
      "desc": "The pmf of a discrete is a that assigns to each possible value of the the . Fig.\\ illustrates the pmf of a discrete . [H] [>=stealth, thick,y=2cm] / in {1/0.3, 4/0.7}{ ( ,0) -- ( , ); ( , ) circle (2pt); } at (1,0.3) { }; at (1,0) { }; at (4,0) { }; at (-1.2,-0.80) { }; at (-5.2,1.18) { }; at (3.2,1.56) { }; {The pmf of a discrete taking values in the set . Also shown are three whose relative frequencies of match this pmf exactly. Such could arise as of sharing the common pmf . } The pmf satisfies . A pmf defined over the set can be viewed as an idealized description of any sufficiently long , whose relative frequencies of each value are close to the corresponding pmf value , A rigorous treatment of this approximation principle is at the heart information theory and statistics . \\\\ See also: , , , .",
      "deg": 10
    },
    {
      "id": "coreset",
      "name": "coreset",
      "desc": "A coreset is a small subset of a larger that approximates certain properties of the original . The construction of a coreset typically involves selecting representative and assigning them weights to reflect their importance in the original (Fig.\\ ). [H] / in {0.5/0.7, 1.2/1.4, 1.8/0.9, 2.2/1.8, 2.6/1.2, 3.1/1.6} { ( , ) circle (1.5pt);} / in {1.2/1.4, 2.6/1.2}{ ( , ) circle (2pt); ( , ) circle (6pt); } (label) at (0.6,2.2) { coreset}; (label) -- (1.2,1.5); (label) -- (2.6,1.3); {A coreset (highlighted in blue) is a small, subset of a larger . } Coresets are particularly useful for applications (such as ) involving large , as they allow for efficient computation while preserving the essential characteristics of the . \\\\ See also: , , .",
      "deg": 5
    },
    {
      "id": "outlier",
      "name": "outlier",
      "desc": "Many methods are motivated by the , which interprets as of with a common . The is useful for applications where the statistical properties of the generation process are stationary (or time-invariant) . However, in some applications, the consist of a majority of regular that conform with the as well as a small number of that have fundamentally different statistical properties compared with the regular . We refer to a that substantially deviates from the statistical properties of most as an outlier. Different methods for outlier detection use different measures for this deviation. Statistical learning theory studies fundamental limits on the ability to mitigate outliers reliably , . \\\\ See also: , , , .",
      "deg": 18
    },
    {
      "id": "membershipinferenceattack",
      "name": "membership inference attack",
      "desc": "Consider a method that learns a via on a . Membership inference is a form of where an adversary tries to determine whether a particular was part of the . The attacker typically queries with candidate , and infers the membership status of a given based on the .\\\\ See also: , .",
      "deg": 9
    },
    {
      "id": "machineunlearning",
      "name": "machine unlearning",
      "desc": "Consider a method that learns a via on a . The learned can reveal information about , which is exploited by such as . Machine unlearning refers to techniques that modify so that it is harder to infer properties of individual in . Machine unlearning helps to meet legal requirements for in systems . \\\\[4pt] See also: , , ,",
      "deg": 10
    },
    {
      "id": "ensemble",
      "name": "ensemble",
      "desc": "An ensemble method combines multiple methods, each of those is referred to as a , to improve overall performance. The can be -based using different choices for the , , and . By aggregating the of , ensemble methods can often achieve better performance than any single . The aggregation can amount to averaging the of (in ) or using a majority vote (for methods). [htbp] [ scale=1.1, transform shape, node distance=11mm and 10mm, dataset/.style={draw, rounded corners, inner sep=2pt}, learner/.style={draw, rounded corners,inner sep=2pt}, op/.style={draw, circle, inner sep=1pt}, flow/.style={->, >=latex}, feedback/.style={->, >=latex, dashed, very thin}, lab/.style={font= } ] (D) { }; (D1) { }; (D2) { }; (D3) { }; (D) -- (D1) node[midway, lab, above left=-1pt] {resample}; (D) -- (D2) node[midway, lab, right] {}; (D) -- (D3) node[midway, lab, above right=-1pt] {}; (L1) { }; (L2) { }; (L3) { }; (D1) -- (L1); (D2) -- (L2); (D3) -- (L3); (L1.east) .. controls +(+7mm,0mm) and +(-7mm,0mm) .. (L2.west) node[midway, lab, above] {}; (L2.east) .. controls +(+7mm,0mm) and +(-7mm,0mm) .. (L3.west); (L1.east) to[out=60, in=120] (L3.west); (agg) { }; (L1) -- (agg); (L2) -- (agg); (L3) -- (agg); (yhat) { }; (agg) -- (yhat); ; ; ; {A generic ensemble with three , each using to learn based on the . A might also use the output of other . The final is obtained by aggregating the obtained from the .} Different ensemble methods use different constructions for the . For example, methods (such as a ) use random sampling to construct a slighly different for each . On the other hand, methods run the sequentially: Each tries to correct the errors of the previous ones. A third family of ensemble methods is , where are trained on the same but using different . \\\\ See also: , , .",
      "deg": 18
    },
    {
      "id": "stacking",
      "name": "stacking",
      "desc": "Stacking is one of the main flavours of methods. In stacking, a finite number of are trained on the same but using a different or , for , . The -th delivers a learnt . The final for a is obtained by aggregating the of the via an aggregation rule , such as majority voting for or averaging for . We can interpret stacking as a form of , where each extracts a new . The aggregation rule can be obtained another instance of that learns a map from a meta . The is applied to the transformed [htbp] [ font= , scale=1.0, transform shape, node distance=7mm and 10mm, dataset/.style={draw, rounded corners, inner sep=2pt}, learner/.style={draw, rounded corners, minimum width=14mm, minimum height=7mm, inner sep=6pt,align=center}, op/.style={draw, circle, inner sep=1pt}, >=latex ] (D) { }; (L1) { \\\\ }; (L2) { \\\\ }; (L3) { \\\\ }; (D) -- (L1) node[midway, above left=-1pt] {}; (D) -- (L2) node[midway, right] {}; (D) -- (L3) node[midway, above right=-1pt]{}; (agg) { }; (yhat) { }; (L1) -- (agg); (L2) -- (agg); (L3) -- (agg); (agg) -- (yhat); ; ; ; {Three using with different and to obtain learned . For a with , each of them delivers a , for . These are then used as new for an aggregation rule which delivers the overall . The aggregation rule can be obtained by training a meta .} \\\\ See also: , .",
      "deg": 17
    },
    {
      "id": "sample",
      "name": "sample",
      "desc": "In the context of , a sample is a finite (of length ) of , . The number is called the . -based methods use a sample to train a (or learn a ) by minimizing the average (the ) over that sample. Since a sample is defined as a , the same may appear more than once. By contrast, some authors in statistics define a sample as a set of , in which case duplicates are not allowed . These two views (sequence vs. set) can be reconciled by regarding a sample as a of – pairs, . The -th pair consists of the and the of an unique underlying . While the underlying are unique, some of them can have identical and . [>=Latex, font= ] (pop) {}; ; / [count= ] in {-2.0/0.3, -1.6/0.9, -1.2/-0.2, -0.8/0.5, -0.3/-0.6, 0.2/0.1, 0.6/0.8, 1.0/-0.4, 1.4/0.4, 1.8/-0.1} { (p ) at ( ); (p ) circle (1.6pt); } (sampleanchor) at ([xshift=1.8cm,yshift=0.5cm]pop.east); (s1) at ( ) { }; (s2) at ( ) { }; (s3) at ( ) { }; (s4) at ( ) { }; (s5) at ( ) { }; (s6) at ( ) { }; (seqbox) {}; ; at ( ) { }; (p2) to[out=0, in=180] ( ); (p7) to[out=10, in=180] ( ); (p4) to[out=10, in=180] ( ); (p5) to[out=-10, in=180] ( ); (p3) to[out=0, in=180] ( ); (p3) to[out=-5, in=180] ( ); {A sample viewed as a finite . Each element of this sample consists of the and the of a from an underlying population. The same may occur more than once in the sample. } For the analysis of methods, it is common to interpret (the generation of) a sample as the of a indexed by . A widely used assumption is the , where sample elements , for , are with a common . \\\\ See also: , , .",
      "deg": 27
    },
    {
      "id": "condtionalexpect",
      "name": "conditional expectation",
      "desc": "Consider a numeric defined on a with . For any , the conditional expectation of given (or conditioned on) is defined as follows: TBC.",
      "deg": 3
    },
    {
      "id": "auc",
      "name": "area under the curve (AUC)",
      "desc": "The AUC is a quantiative measure for the usefulness of a binary . It is defined as the area (using the natural measure of the ) under the curve.",
      "deg": 4
    },
    {
      "id": "roc",
      "name": "receiver operating characteristic (ROC)",
      "desc": "Consider the is and a that uses a real-valued . For a given threshold , the ultimate is if and otherwise. On a we compute, for each value of , two quantities: true positive rate and false positive rate . The ROC curve is the One important characteristic of the ROC curve is the .\\\\ See also: , .",
      "deg": 8
    },
    {
      "id": "condprobdist",
      "name": "conditional probability distribution",
      "desc": "Consider a consisting of two and with . The conditional of given (or conditioned on) is denoted . It is defined via the conditional of the indicator functions obtained for any set in the generated by the .",
      "deg": 6
    },
    {
      "id": "posterior",
      "name": "posterior",
      "desc": "The study and design of methods is often based on a for the generation process. Within a , we view (the generation of) a with and as a with . It turns out that the optimal for the , given the is fully determined by the conditional of given (conditioned on) .",
      "deg": 10
    },
    {
      "id": "bagging",
      "name": "bagging",
      "desc": "Bagging is an technique where use perturbed copies of the original . Each delivers a potentially different , The delivered by the overall method is obtained by aggregating the using some aggregation rule. For methods, the rule is typically a majority vote while for methods, amounts to averaging. [htbp] [ scale=1.0, transform shape, node distance=10mm and 10mm, dataset/.style={draw, rounded corners, inner sep=2pt}, learner/.style={draw, rounded corners, minimum width=14mm, minimum height=7mm, inner sep=2pt}, op/.style={draw, circle, inner sep=1pt}, >=latex ] (D) { }; (D1) { }; (D2) { }; (D3) { }; (D) -- (D1) node[midway, above left=-1pt] {resample}; (D) -- (D2) node[midway, right] {resample}; (D) -- (D3) node[midway, above right=-1pt]{resample}; (L1) { }; (L2) { }; (L3) { }; (D1) -- (L1); (D2) -- (L2); (D3) -- (L3); (agg) { }; (yhat) { }; (L1) -- (agg); (L2) -- (agg); (L3) -- (agg); (agg) -- (yhat); ; ; ; {An example of bagging where three use perturbations of the original to learn the . The final is obtained by aggregating these individual via some aggregation rule .} See also: , , .",
      "deg": 12
    },
    {
      "id": "bootstrap aggregation",
      "name": "bootstrap aggregation",
      "desc": "See: .",
      "deg": 1
    },
    {
      "id": "decisionregion",
      "name": "decision region",
      "desc": "Consider a that delivers values from a finite set . For each value (i.e., category) , the determines a subset of values that result in the same output . We refer to this subset as a decision region of the . \\\\ See also: , , , .",
      "deg": 9
    },
    {
      "id": "baselearner",
      "name": "base learner",
      "desc": "A base learner is an method that is part of an method. \\\\ See also: , , , .",
      "deg": 11
    },
    {
      "id": "decisionboundary",
      "name": "decision boundary",
      "desc": "Consider a that reads in a and delivers a value from a finite set . The decision boundary of is the set of that lie between different . More precisely, a belongs to the decision boundary if and only if each , for any , contains at least two with different values. \\\\ See also: , , , , , , .",
      "deg": 10
    },
    {
      "id": "euclidnorm",
      "name": "Euclidean norm",
      "desc": "The Euclidean norm of a defined as The Euclidean norm is distinct among all norms on in the sense that it is induced by the inner-product . In other words, . \\\\ See also: , .",
      "deg": 3
    },
    {
      "id": "eucliddist",
      "name": "Euclidean distance",
      "desc": "The Euclidean distance is used synonymously for . \\\\ See also: , .",
      "deg": 7
    },
    {
      "id": "normalequations",
      "name": "normal equations",
      "desc": "The optimality condition for the in are often referred to as normal equations.\\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "euclidspace",
      "name": "Euclidean space",
      "desc": "The Euclidean space of dimension consists of , with real-valued entries . Such a Euclidean space is equipped with a geometric structure defined by the inner product between any two . \\\\ See also: .",
      "deg": 23
    },
    {
      "id": "eerm",
      "name": "explainable empirical risk minimization (EERM)",
      "desc": "EERM is an in- stance of that adds a term to the average in the of . The term is chosen to favor that are intrinsically explainable for a specific user. This user is characterized by their provided for the in a . \\\\ See also: , , , .",
      "deg": 10
    },
    {
      "id": "kmeans",
      "name": "-means",
      "desc": "The -means principle is an optimization-based approach to the of with n umeric . As a approach, -means partitions a into disjoint subsets (or ), which are indexed by . Each is characterized by the average of that belong to it. This average (or ) is referred to as the . A visual illustration is provided in Fig. . [H] [scale=1] { data/.style={circle, fill=black, inner sep=1.2pt}, centroid/.style={thick, cross out, draw, minimum size=6pt, inner sep=0pt} } (xi) at (1.0,0.2) {}; ; in {(-0.3,0.0),(0.2,-0.4),(0.6,0.8),(0.0,0.9),(1.1,-0.2)} at ; in {(2.5,1.0),(3.7,1.2),(2.6,2.3),(3.8,2.5),(3.0,2.9),(3.6,1.6)} at ; (mu1) at (0.55,0.4) {}; (mu2) at (3.1,1.85) {}; ; ; {A of , indexed by and characterized by . The also includes two . } In general, solving the -means exactly is challenging (or NP-hard) . However, there are simple iterative methods for finding approximately optimal . One such method is referred to as .\\\\ See also: , , .",
      "deg": 19
    },
    {
      "id": "lloydalgorithm",
      "name": "Lloyd's algorithm",
      "desc": "Lloyd's is an iterative for finding that are approximately optimal for the . Lloyd's alternates between updating the assignment of each based on the nearest current and re-calculating the given the updated assignments . [ assignment/.style={-Latex, very thin}, move/.style={-Latex, thick}, center/.style={draw, circle, inner sep=1.2pt, fill=white}, pointA/.style={circle, inner sep=1.1pt, fill=black}, pointB/.style={rectangle, inner sep=1.1pt, fill=black}, cross/.style={line width=0.4pt}, lab/.style={font= } ] [shift={(0,0)}] (Ba1) at (0.2, 1.1); (Ba2) at (0.4, 0.6); (Ba3) at (0.8, 1.0); (Ba4) at (0.6, 0.2); (Bb1) at (2.7, 1.4); (Bb2) at (3.2, 0.9); (Bb3) at (2.6, 0.3); (Bb4) at (3.3, 0.2); at (Ba1) {}; at (Ba2) {}; at (Ba3) {}; at (Ba4) {}; at (Bb1) {}; at (Bb2) {}; at (Bb3) {}; at (Bb4) {}; (Bc1old) at (0.9,0.65); (Bc2old) at (2.8,1.8); right: }] (B-C1) at (Bc1old) {}; right: }] (B-C2) at (Bc2old) {}; let 1=(B-C1), 2=(B-C2), 1={( 2- 1)}, 2={( 2- 1)}, 3={veclen( 1, 2)} in coordinate (B-M) at ( ) coordinate (B-Nhat) at ( ); ( ) -- ( ); (Ba2) -- (B-C1); (Ba3) -- (B-C1); (Bb2) -- (B-C2); (Bb3) -- (B-C2); at (1.6,-0.35) {(a) Assign to nearest }; [shift={(5.5,0)}] (Ca1) at (0.2, 1.1); (Ca2) at (0.4, 0.6); (Ca3) at (0.8, 1.0); (Ca4) at (0.6, 0.2); (Cb1) at (2.7, 1.4); (Cb2) at (3.2, 0.9); (Cb3) at (2.6, 0.3); (Cb4) at (3.3, 0.2); at (Ca1) {}; at (Ca2) {}; at (Ca3) {}; at (Ca4) {}; at (Cb1) {}; at (Cb2) {}; at (Cb3) {}; at (Cb4) {}; (Cc1old) at (0.9,0.65); (Cc2old) at (2.8,1.8); (Cc1new) at (0.5,0.725); (Cc2new) at (2.95,0.70); at (Cc1old) {}; at (Cc2old) {}; ( ) -- ( ); ( ) -- ( ); ( ) -- ( ); ( ) -- ( ); (Cc1old) -- (Cc1new); (Cc2old) -- (Cc2new); at (1.6,-0.35) {(b) Recompute }; [shift={(3,-4)}] (Da1) at (0.2, 1.1); (Da2) at (0.4, 0.6); (Da3) at (0.8, 1.0); (Da4) at (0.6, 0.2); (Db1) at (2.7, 1.4); (Db2) at (3.2, 0.9); (Db3) at (2.6, 0.3); (Db4) at (3.3, 0.2); at (Da1) {}; at (Da2) {}; at (Da3) {}; at (Da4) {}; at (Db1) {}; at (Db2) {}; at (Db3) {}; at (Db4) {}; (Dc1new) at (0.5,0.725); (Dc2new) at (2.95,0.70); right: }] (D-C1n) at (Dc1new) {}; right: }] (D-C2n) at (Dc2new) {}; let 1=(D-C1n), 2=(D-C2n), 1={( 2- 1)}, 2={( 2- 1)}, 3={veclen( 1, 2)} in coordinate (D-M) at ( ) coordinate (D-Nhat) at ( ); ( ) -- ( ); at (1.6,-0.35) {(c) Assign to nearest }; {Lloyd's alternates between assigning to nearest and, in turn, re-computing the based on the new assignments. } See also: , , .",
      "deg": 10
    },
    {
      "id": "qlearning",
      "name": "Q-learning",
      "desc": "Q-learning is a popular that learns an optimal policy by estimating the optimal action-value function (or Q-function) . \\\\ See also: , .",
      "deg": 3
    },
    {
      "id": "iteration",
      "name": "iteration",
      "desc": "The elementary computational step during the execution of an is referred to as iteration . For example, the elementary computational step of is a . [t] [>=Latex, font= ,scale=1] (xstar) at (8,0) {}; (x0) at (0.3,0) {}; (x1) at (4.3,0) {}; (x2) at (6.5,0) {}; (x0) to[bend left=12] node[above,sloped] { } (x1); (x1) to[bend left=12] node[above,sloped] { } (x2); {A consists of the repeated application of an operator with some fixed point , i.e., .} More generally, the elementary computational step of a is the evaluation of an underlying operator (which might vary across iterations). Many important , including and , are . \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "clustercentroid",
      "name": "cluster centroid",
      "desc": "methods decompose a given into few . Different methods use different representations for these . If are characterized by numerical , we can use some vector , referred to as centroid, to represent a . For example, if a consists of a set of , we use the average of their as a centroid. However, there are also other choices for how to construct a centroid. \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "xml",
      "name": "explainable machine learning (XML)",
      "desc": "XML methods aim to complement each with an of how the has been obtained. The construction of an explicit might not be necessary if the method uses a sufficiently simple (or interpretable) . \\\\ See also: , , , .",
      "deg": 4
    },
    {
      "id": "fmi",
      "name": "Finnish Meteorological Institute (FMI)",
      "desc": "The FMI is a government agency responsible for gathering and reporting weather in Finland. \\\\ See also: .",
      "deg": 6
    },
    {
      "id": "samplemean",
      "name": "sample mean",
      "desc": "The for a given , with , is defined as \\\\ See also: , , , .",
      "deg": 5
    },
    {
      "id": "samplecovmtx",
      "name": "sample covariance matrix",
      "desc": "The for a given set of is defined as Here, we use the . \\\\ See also: , , , .",
      "deg": 4
    },
    {
      "id": "covmtx",
      "name": "covariance matrix",
      "desc": "The of a is defined as . \\\\ See also: , , .",
      "deg": 9
    },
    {
      "id": "highdimregime",
      "name": "high-dimensional regime",
      "desc": "The high-dimensional regime of is characterized by the of the being larger than the , i.e., the number of (labeled) in the . For example, methods operate in the high-dimensional regime whenever the number of used to characterize exceeds the number of in the . Another example of methods that operate in the high-dimensional regime is large , which have far more tunable (and bias terms) than the total number of in the . High-dimensional statistics is a recent main thread of theory that studies the behavior of methods in the high-dimensional regime , . \\\\ See also: , , , .",
      "deg": 15
    },
    {
      "id": "covariance",
      "name": "covariance",
      "desc": "The covariance between two real-valued and , defined on a common , measures their linear dependence. It is defined as A positive covariance indicates that and tend to increase together, while a negative covariance suggests that one tends to increase as the other decreases. If , the are said to be uncorrelated, though not necessarily statistically independent. See Fig. for visual illustrations. [H] [shift={(0,0)}] [ width=4.5cm, height=4.5cm, title={ }, xlabel={ }, ylabel={ }, xmin=-3, xmax=3, ymin=-3, ymax=3, xtick= , ytick= , axis lines=middle, enlargelimits ] +[only marks, mark=*, samples=50, domain=-2:2] ({x}, {-x + rand}); at (1.5,-1) {(a)}; [shift={(5.2cm,0)}] [ width=4.5cm, height=4.5cm, title={ }, xlabel={ }, ylabel={ }, xmin=-3, xmax=3, ymin=-3, ymax=3, xtick= , ytick= , axis lines=middle, enlargelimits ] +[only marks, mark=*, samples=50, domain=-2:2] ({x}, {rand}); at (1.5,-1) {(b)}; [shift={(10.4cm,0)}] [ width=4.5cm, height=4.5cm, title={ }, xlabel={ }, ylabel={ }, xmin=-3, xmax=3, ymin=-3, ymax=3, xtick= , ytick= , axis lines=middle, enlargelimits ] +[only marks, mark=*, samples=50, domain=-2:2] ({x}, {x + rand}); at (1.5,-1) {(c)}; { illustrating from three different for two with different covariance values. (a) Negative. (b) Zero. (c) Positive.} See also: , .",
      "deg": 8
    },
    {
      "id": "gmm",
      "name": "Gaussian mixture model (GMM)",
      "desc": "A GMM is a particular type of for characterized by a numeric . Within a GMM, the is drawn from a randomly selected with . The index is a with . A GMM is parameterized, for each , by the , the , and the . \\\\ See also: , , .",
      "deg": 14
    },
    {
      "id": "maxlikelihood",
      "name": "maximum likelihood",
      "desc": "Consider that are interpreted as the of with a common , which depends on the . likelihood methods learn by maximizing the probability (density) of the observed . Thus, the likelihood estimator is a solution to the . \\\\ See also: , , .",
      "deg": 12
    },
    {
      "id": "em",
      "name": "expectation–maximization (EM)",
      "desc": "Consider a for the generated in some application. The estimator for the is obtained by maximizing . However, the resulting might be computationally challenging. EM approximates the estimator by introducing a latent such that maximizing would be easier , , . Since we do not observe , we need to estimate it from the observed using a conditional . The resulting estimate is then used to compute a new estimate by solving . The crux is that the conditional depends on the , which we have updated based on . Thus, we have to recalculate , which, in turn, results in a new choice for the . In practice, we repeat the computation of the conditional (i.e., the E-step) and the update of the (i.e., the M-step) until some is met. \\\\ See also: , , .",
      "deg": 12
    },
    {
      "id": "ppca",
      "name": "probabilistic principal component analysis (PPCA)",
      "desc": "PPCA extends basic by using a for . The of PPCA frames the task of as an estimation problem that can be solved using . \\\\ See also: , , , .",
      "deg": 5
    },
    {
      "id": "polyreg",
      "name": "polynomial regression",
      "desc": "Polynomial is an instance of that learns a polynomial to predict a numeric based on the numeric of a . For characterized by a single numeric , polynomial uses the The quality of a polynomial is measured using the average incurred on a set of (which we refer to as the ). \\\\ See also: , , .",
      "deg": 11
    },
    {
      "id": "leastsquares",
      "name": "least squares",
      "desc": "Least squares refers to -based methods that use the average on a to measure the quality of a . We obtain different least squares methods by using different in . For example, the least squares variant of is a least squares method that uses a . \\\\ See also: , , , .",
      "deg": 9
    },
    {
      "id": "columnspace",
      "name": "column space",
      "desc": "The column space of a , denoted by , is the set of all linear combinations of the columns of . In other words, The column space of is a of the . \\\\ See also: , .",
      "deg": 7
    },
    {
      "id": "hyperplane",
      "name": "hyperplane",
      "desc": "TBC",
      "deg": 0
    },
    {
      "id": "subspace",
      "name": "subspace",
      "desc": "A subset of is a subspace of if it is also a with respect to the same operations as . \\\\ See also: .",
      "deg": 2
    },
    {
      "id": "designmatrix",
      "name": "design matrix",
      "desc": "The term index matrix is a synonym for the , particularly used in statistics . It collects the of the in a that is used for or .",
      "deg": 7
    },
    {
      "id": "datamatrix",
      "name": "data matrix",
      "desc": "The term is sometimes used as a synonym for the of a containing , each characterized by a . In particular, when no information is available, the term highlights that the fully characterizes the .\\\\ See also: , , , .",
      "deg": 7
    },
    {
      "id": "labelvec",
      "name": "label vector",
      "desc": "Given a of , it is convenient to collect the corresponding into a single . \\\\ See also: , , , .",
      "deg": 9
    },
    {
      "id": "inputvec",
      "name": "input vector",
      "desc": "The term input is often used as a synonym for the of a . In settings where arise from a dynamical system observed over time, are obtained from measuring input variables. These input variables are then used by methods to predict the system’s output (which is a in terminology).",
      "deg": 6
    },
    {
      "id": "outputvec",
      "name": "output vector",
      "desc": "The term output is used as a synonym for the of a .",
      "deg": 3
    },
    {
      "id": "output",
      "name": "output",
      "desc": "The term output is sometimes used as a synonym for the of a .",
      "deg": 2
    },
    {
      "id": "targetvec",
      "name": "target vector",
      "desc": "The term target is used as a synonym for the of a .",
      "deg": 3
    },
    {
      "id": "target",
      "name": "target",
      "desc": "The term target is sometimes used as a synonym for the of a .",
      "deg": 2
    },
    {
      "id": "responsevec",
      "name": "response vector",
      "desc": "The term response is used as a synonym for the of a .",
      "deg": 3
    },
    {
      "id": "response",
      "name": "response",
      "desc": "The term response is sometimes used as a synonym for the of a .",
      "deg": 2
    },
    {
      "id": "linleastsquares",
      "name": "linear least squares",
      "desc": "Linear least squares refers to the variant of that uses the to measure the quality of a linear . Conversely, it can also be viewed as the variant of that restricts the to a . [scale=1] (-1,-0.333) -- (3,1) node[pos=0.0,below right] { }; (y) at (1,2); (y) circle (1.6pt) node[above] { }; (xw) at (1.5,0.5); (xw) circle (1.6pt) node[below right] { }; (y) -- (xw); [xshift=6.2cm] at (0,1.2) { }; at (0,0.4) { }; {Linear least squares has both geometric and algebraic interpretations. Left: geometrically, it finds the orthogonal projection of the onto the of the . Right: algebraically, it solves a linear system known as . } In particular, linear least squares learns the of a linear by solving _{ ^{ }} {2}^2. Here, the is and the is . Both are constructed from the The optimization problem in admits a clear geometric interpretation: we seek the vector in the of that is closest to the label vector (see Fig.~ ) . A necessary and sufficient condition for to minimize are the See also: , , , , .",
      "deg": 15
    },
    {
      "id": "weightedleastsquares",
      "name": "weighted least squares",
      "desc": "Weighted least squares refers to -based methods that use the weighted average on a to measure the quality of a . [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 3.5) -- (10.5, 3.5) node[right] { }; at (ptB7) { }; (lineStart) at (0.5, 3.5); (lineEnd) at (10.5, 3.5); (lineStart) -- (lineEnd) node[right] { }; let 1 = (ptB7) in coordinate (proj7) at ( 1, 3.5); (proj7) -- node[right, xshift=2pt, fill=white, inner sep=1pt] { } (ptB7); (proj7) circle (1.2pt); (ptB7) circle (1.2pt); {Weighted least squares can be used to mitigate the effect of in a . } The weights allow us to emphasize or de-emphasize the contribution of individual in the . Ideally, we assign a small weight (de-empahsize) the -th if it is an (see Figure ). We obtain different weighted least squares methods by using different in . \\\\ See also: , , , .",
      "deg": 10
    },
    {
      "id": "linreg",
      "name": "linear regression",
      "desc": "Linear methods learn a linear which is used to predict the numeric of a based on its numeric . The least-squares variant of linear measures the quality of a linear via the average incurred on a As an instance of , linear (least-squares) learns the by solving the [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/4 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptA ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (7.5, -4) {(a)}; [xshift=10cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 7.5) -- (10.5, 7.5) node[right] { }; at (ptB7) { }; at (7.5, -4) {(b)}; {For a with and using the trivial for any , linear reduces to computing the average . (a) A clean and resulting (given by the average). (b) A perturbed (including an ) and the resulting . } We can rewrite the above more compactly using the and the . This allows to rewrite the above as By the , a necessary and sufficient condition for a vector to be a solution to the above is the linear system of equations ^{T} = ^{T} . Instead of solving directly (via computing the or ), many mehtods use variants of to construct a sequence of increasingly accurate approximations of a solution to . These can be interpreted as a for the following re-formulation of , This equation is solved by a if and only if this also solves . The optimality condition is also useful for the study of the of linear . Ideally, we would like the solutions of to be insensitive to small perturbations of the . We can capture these perturbations via a perturbed and perturbed . Here, and represent small perturbations to the and of the in the original . perturbation theory allows to evaluate how much the solutions of the perturbed linear problem deviate from the solutions of the original linear problem. \\\\ See also: , , .",
      "deg": 42
    },
    {
      "id": "ridgeregression",
      "name": "ridge regression",
      "desc": "Consider a problem where the goal is to learn a for predicting the numeric of a based on its . Ridge learns the by minimizing the penalized average . The average is measured on a set of (i.e., the ) The penalty term is the scaled squared Euclidean with a . The purpose of the penalty term is , i.e., to prevent in the , where the number of exceeds the number of in the . For of a , adding to the average is equivalent to computing the average on an augmented . [H] [scale = 1] (0,0.5) -- (7.7,0.5) node[right] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ 0.4 + 2.0}) ; at (6.7,4.5) { }; (l1) at (1.2, 2.48); (l2) at (1.4, 2.56); (l3) at (1.7, 2.68); (l4) at (2.2, 2.2*0.4+2.0); (l5) at (2.4, 2.4*0.4+2.0); (l6) at (2.7, 2.7*0.4+2.0); (l7) at (3.9, 3.9*0.4+2.0); (l8) at (4.2, 4.2*0.4+2.0); (l9) at (4.5, 4.5*0.4+2.0); (n1) at (1.2, 1.8); (n2) at (1.4, 1.8); (n3) at (1.7, 1.8); (n4) at (2.2, 3.8); (n5) at (2.4, 3.8); (n6) at (2.7, 3.8); (n7) at (3.9, 2.6); (n8) at (4.2, 2.6); (n9) at (4.5, 2.6); at (n1) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c1] {}; at (n2) [circle,draw,fill=blue,minimum size=6pt, scale=0.6, name=c2] {}; at (n3) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c3] {}; at (n4) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c4] {}; at (n5) [circle,draw,fill=blue,minimum size=12pt,scale=0.6, name=c5] {}; at (n6) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c6] {}; at (n7) [circle,draw,fill=red,minimum size=12pt,scale=0.6, name=c7] {}; at (n8) [circle,draw,fill=blue,minimum size=12pt, scale=0.6, name=c8] {}; at (n9) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c9] {}; [<->] ( ) -- ( ) node [pos=0.4, below] { }; ; (l1) -- (c1); (l2) -- (c2); (l3) -- (c3); (l4) -- (c4); (l5) -- (c5); (l6) -- (c6); (l7) -- (c7); (l8) -- (c8); (l9) -- (c9); (6.2, 3.7) circle (0.1cm) node [anchor=west,black,xshift=0.1cm] {original }; (6.2, 3.2) circle (0.1cm) node [anchor=west,black,xshift=0.1cm] {augmented }; {For a , adding the penalty term to the in is equivalent to on an augmented } This augmented is obtained by replacing each in the original by the of infinitely many whose is centered around . \\\\ See also: , , , .",
      "deg": 28
    },
    {
      "id": "expectation",
      "name": "expectation",
      "desc": "Consider a numeric that we interpret as the of a with a . The expectation of is defined as the integral . Note that the expectation is only defined if this integral exists, i.e., if the is integrable , , . Fig. illustrates the expectation of a scalar discrete that takes on values from a finite set only. [H] [ ybar, y=5cm, x=2cm, bar width=0.6cm, xlabel={ }, clip=false, ylabel={ }, y label style={rotate=-90, anchor=west, xshift=-1cm}, xtick={1,2,3,4,5}, ymin=0, ymax=0.6, grid=both, major grid style={gray!20}, tick align=outside, axis line style={black!70}, ] +[ybar, fill=blue!50] coordinates { (1,0.1) (2,0.2) (3,0.4) (4,0.2) (5,0.1) }; at (axis cs:1,0.13) { }; at (axis cs:2,0.23) { }; at (axis cs:3,0.43) { }; at (axis cs:4,0.23) { }; at (axis cs:5,0.13) { }; at (axis cs:3.8,0.53) { }; {The expectation of a discrete is obtained by summing its possible values , weighted by the corresponding . } See also: , , , , .",
      "deg": 19
    },
    {
      "id": "logreg",
      "name": "logistic regression",
      "desc": "Logistic learns a linear (or ) to predict a binary based on the numeric of a . The quality of a linear is measured by the average on some (i.e., the ). \\\\ See also: , , , , , , , , , .",
      "deg": 12
    },
    {
      "id": "logloss",
      "name": "logistic loss",
      "desc": "Consider a characterized by the and a binary . We use a real-valued to predict the from the . The logistic incurred by this is defined as { } \\, ( 1 + \\,(- ( ))). [H] [ axis lines=middle, xlabel={ }, ylabel={ }, xlabel style={at={(axis description cs:1.,0.3)}, anchor=north}, ylabel style={at={(axis description cs:0.5,1.1)}, anchor=center}, xmin=-3.5, xmax=3.5, ymin=-0.5, ymax=2.5, xtick={-3, -2, -1, 0, 1, 2, 3}, ytick={0, 1, 2}, domain=-3:3, samples=100, width=10cm, height=6cm, grid=both, major grid style={line width=.2pt, draw=gray!50}, minor grid style={line width=.1pt, draw=gray!20}, legend pos=south west ] ; {The logistic incurred by the for a with .} Note that the expression for the logistic applies only for the and when using the thresholding rule . \\\\ See also: , , , , , , .",
      "deg": 8
    },
    {
      "id": "hingeloss",
      "name": "hinge loss",
      "desc": "Consider a characterized by a and a binary . The hinge incurred by a real-valued is defined as { } \\{ 0 , 1 - ( ) \\}. [H] [ axis lines=middle, xlabel={ }, ylabel={ }, xlabel style={at={(axis description cs:1.,0.3)}, anchor=north}, ylabel style={at={(axis description cs:0.5,1.1)}, anchor=center}, xmin=-3.5, xmax=3.5, ymin=-0.5, ymax=2.5, xtick={-3, -2, -1, 0, 1, 2, 3}, ytick={0, 1, 2}, domain=-3:3, samples=100, width=10cm, height=6cm, grid=both, major grid style={line width=.2pt, draw=gray!50}, minor grid style={line width=.1pt, draw=gray!20}, legend pos=south west ] ; {The hinge incurred by the for a with . A regularized variant of the hinge is used by the .} See also: , , .",
      "deg": 11
    },
    {
      "id": "iidasspt",
      "name": "independent and identically distributed assumption (i.i.d.\\ assumption)",
      "desc": "The assumption interprets of a as the of . \\\\ See also: , , , , .",
      "deg": 14
    },
    {
      "id": "hypospace",
      "name": "hypothesis space",
      "desc": "A space is a mathematical that characterizes the learning capacity of an method. The goal of such a method is to learn a that maps of a to a of its . Given a finite amount of computational resources, a practical method typically explores only a restricted set of all possible from the to the . Such a restricted set is referred to as a space underlying the method (see Fig. ). For the analysis of a given method, the choice of a space is not unique, i.e., any superset containing all the method can learn is also a valid space. [H] [allow upside down, scale=0.4] [below] at (5,-3) { }; [ultra thick] (5,0) circle (5cm); [ultra thick,fill=black!20] (5,0) circle (1cm); [] at (5,0) { }; {The space of an method is a (typically very small) subset of the (typically very large) set of all possible from the into the . } On the other hand, from an engineering perspective, the space is a design choice for -based methods. This design choice can be guided by the available computational resources and . For instance, if efficient operations are feasible and a roughly linear relation exists between and , a can be a useful choice for . \\\\ See also: , , , .",
      "deg": 35
    },
    {
      "id": "model",
      "name": "model",
      "desc": "The study and design of methods is often based on a mathematical model . Maybe the most widely used example of a mathematical model for is a . A consists of that are used by an method to predict from the of . Another important type of mathematical model is a , which consists of that describe how are generated. Unless stated otherwise, we use the term model to refer specifically to the underlying an method. We illustrate one example of a and a in Fig. . [H] [scale=1] (-1,0) -- (3,0) node[right] { }; (0,-1) -- (0,3) node[above] { }; (-0.5,0) -- (2.5,2) node[right] { }; (-0.5,1) -- (2.5,1) node[right] { }; (-0.5,2) -- (2.5,0.5) node[right] { }; at (1.5,-1.2) {(a)}; [scale=1] (-1,0) -- (3,0) node[right] { }; (0,-1) -- (0,3) node[above] { }; (1,1) ellipse [x radius=1, y radius=0.5]; (2,2) ellipse [x radius=0.7, y radius=0.3]; at (1,0.3) { }; at (2,2.7) { }; at (1.5,-1.2) {(b)}; {Two types of mathematical models used in . (a) A consisting of three . (b) A consisting of over the plane spanned by the and values of a . } See also: , , .",
      "deg": 89
    },
    {
      "id": "modelparam",
      "name": "model parameters",
      "desc": "The elements of a are specified by quantities that are referred to as . In the context of , a consists of maps that are specified by a list of . It is often convenient to stack these into a . [scale=1] (0,0) ellipse (1.6 and 1.1); at (0,1.5) { }; (-0.6,0.2) circle (1.5pt) node[above left] { }; (0.7,-0.3) circle (1.5pt) node[below right] { }; (6,0) ellipse (1.8 and 1.2); at (6,1.6) { }; (5.4,0.1) circle (1.5pt) node[above left] { }; (6.7,-0.2) circle (1.5pt) node[below right] { }; (-0.6,0.2) .. controls (2,0.9) .. (5.4,0.1); (0.7,-0.3) .. controls (2,-0.9) .. (6.7,-0.2); at (3,1.2) { }; {The select a well-defined out of the .} We can think of as an identifier for a , similar to how a social security number identifies a person.\\\\ See also: , , , .",
      "deg": 57
    },
    {
      "id": "ai",
      "name": "artificial intelligence (AI)",
      "desc": "AI refers to systems that behave rationally in the sense of maximizing a long-term . The -based approach to AI is to train a to predict optimal actions. These are computed from observations about the state of the environment. The choice of sets AI applications apart from more basic applications. AI systems rarely have access to a labeled that allows the average to be measured for any possible choice of . Instead, AI systems use observed signals to estimate the incurred by the current choice of . \\\\ See also: , .",
      "deg": 13
    },
    {
      "id": "mdp",
      "name": "Markov decision process (MDP)",
      "desc": "An MDP is a mathematical structure that can be used to study applications. An MDP formalizes how signals depend on the (and corresponding actions) made by an method. Formally, an MDP is a specific type of defined by a state space ; an action space (where each action corresponds to a specific made by the method); a transition specifying the over the next state , given the current state and action ; a that assigns a numerical to each state-action pair. The defining property of an MDP is the Markov property. That is, the next state and only depend on the current state and action , not on the entire history of interactions. \\\\ See also: , , , , , .",
      "deg": 6
    },
    {
      "id": "reward",
      "name": "reward",
      "desc": "A reward refers to some observed (or measured) quantity that allows us to estimate the incurred by the (or decision) of a . For example, in an application to self-driving vehicles, could represent the current steering direction of a vehicle. We could construct a reward from the measurements of a collision sensor that indicate if the vehicle is moving toward an obstacle. We define a low reward for the steering direction if the vehicle moves dangerously toward an obstacle. \\\\ See also: , , .",
      "deg": 11
    },
    {
      "id": "clusteringerror",
      "name": "clustering error",
      "desc": "Consider a method that decomposes a given into . The error is a quantitative measure for the usefulness of the . Different methods use different choices for the error. [scale=1] (c1) at (0.8,0.7); ( ) rectangle ( ); at (c1) { }; (c2) at (3.6,1.6); ( ) rectangle ( ); at (c2) { }; [shift={(c1)}, xscale=0.9, yscale=0.7, rotate=0] / in {-0.6/-0.4, 0.1/0.9, 0.7/-0.6} { ( , ) circle (1.5pt); ( , ) -- (0,0); } [shift={(c2)}, xscale=0.8, yscale=0.8, rotate=0] / in {-1.1/-0.5, -0.2/0.6, 0.6/-0.2} { ( , ) circle (1.5pt); ( , ) -- (0,0); } {For with numeric , we can use the average squared to the nearest as a measure for the error.} For example, the method measures the error via the average squared between a (its ) and the nearest .",
      "deg": 9
    },
    {
      "id": "hardclustering",
      "name": "hard clustering",
      "desc": "Hard refers to the task of partitioning a given set of into (a few) non-overlapping . This requirement allows to represent a by a subset of , i.e., precisely those belonging to the . In contrast to hard , methods allow for overlapping and specify, for each , a numeric to each . Hard is an extreme case of where the take only two values, indicating either no belonging or full belonging. For characterized by numeric , a widely used hard method is . Any method for numeric can be adapted for non-numerical using methods. One important example of this approach is , where have a similarity structure in the form of an undirected . The nodes of this represent while undirected (possibly weighted) edges represent similarities (and their extend) between . We can then use the entries of the of the as numeric for each . \\\\ See also: , , , .",
      "deg": 17
    },
    {
      "id": "softclustering",
      "name": "soft clustering",
      "desc": "Soft refers to the task of partitioning a given set of into (a few) overlapping . Each is assigned to several different with varying . Soft methods determine the (or soft assignment) for each and each . A principled approach to soft for characterized by numerical is via a such as the . The conditional of a belonging to a specific mixture component is then a natural choice for the . soft methods can be applied to non-numeric by using methods to provide numerical (such as in ). \\\\ See also: , , , , .",
      "deg": 17
    },
    {
      "id": "kroneckerproduct",
      "name": "Kronecker product",
      "desc": "The Kronecker product of two and is a block denoted by and defined as , The Kronecker product is a special case of the tensor product for and is widely used in multivariate statistics, linear algebra, and structured . It satisfies the identity for and of compatible dimensions. \\\\ See also: , , , .",
      "deg": 4
    },
    {
      "id": "clustering",
      "name": "clustering",
      "desc": "Clustering methods decompose a given set of into a few subsets, which are referred to as . Each consists of that are more similar to each other than to outside the . Different clustering methods use different measures for the similarity between and different forms of representations. The clustering method uses the average of a (i.e., the ) as its representative. A popular method based on represents a by a . \\\\ See also: , , , .",
      "deg": 23
    },
    {
      "id": "cluster",
      "name": "cluster",
      "desc": "A cluster is a subset of that are more similar to each other than to the outside the cluster. The quantitative measure of similarity between is a design choice. If are characterized by Euclidean , we can define the similarity between two via the Euclidean distance between their . An example of such clusters is shown in Fig. .\\\\ [H] [ width=10cm, height=8cm, xlabel={ }, ylabel={ }, title={Clusters of Data Points}, xmin=0, xmax=10, ymin=0, ymax=10, axis lines=left, legend style={at={(0.5,-0.25)}, anchor=north, legend columns=3} ] coordinates { (1,1) (2,1.2) (1.8,2) (2.2,1.5) (1.5,2.5) }; coordinates { (7,8) (8,7.5) (7.5,8.5) (8.2,7.8) (7.7,7) }; coordinates { (5,3) (5.5,3.2) (5.2,2.8) (4.8,3.5) (5.1,3.1) }; {Illustration of three clusters in a 2-D . Each cluster groups that are more similar to each other than to those in other clusters, based on the Euclidean distance.} See also: , , .",
      "deg": 17
    },
    {
      "id": "huberloss",
      "name": "Huber loss",
      "desc": "The Huber unifies the and the . \\\\ See also: , , .",
      "deg": 4
    },
    {
      "id": "svm",
      "name": "support vector machine (SVM)",
      "desc": "The SVM is a binary meth\\-od that learns a linear . Thus, like and , it is also an instance of for the . However, the SVM uses a different from the one used in those methods. As illustrated in Fig. , it aims to maximally separate from the two different classes in the (i.e., margin principle). Maximizing this separation is equivalent to minimizing a regularized variant of the , , . [H] [auto,scale=0.8] [thick] (1,2) circle (0.1cm)node[anchor=west] { }; [thick] (0,1.6) circle (0.1cm)node[anchor=west] { }; [thick] (0,3) circle (0.1cm)node[anchor=west] { }; [thick] (2,1) circle (0.1cm)node[anchor=east,above] { }; (B) at (-2,0) {support }; (B) to (1.9,1) ; [|<->|,thick] (2.05,0.95) -- (2.75,0.25)node[pos=0.5] { } ; [thick] (1,-1.5) -- (4,1.5) node [right] { } ; [thick] (3,-1.9) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; [thick] (4,.-1) rectangle ++(0.1cm,0.1cm) node[anchor=west,above] { }; {The SVM learns a (or ) with minimal average soft-margin . Minimizing this is equivalent to maximizing the margin between the of and each class of the .} The above basic variant of SVM is only useful if the from different categories can be (approximately) linearly separated. For an application where the categories are not derived from a . \\\\ See also: , , , .",
      "deg": 20
    },
    {
      "id": "eigenvalue",
      "name": "eigenvalue",
      "desc": "We refer to a number as an eigenvalue of a square if there exists a nonzero such that . \\\\ See also: , .",
      "deg": 9
    },
    {
      "id": "eigenvector",
      "name": "eigenvector",
      "desc": "An eigenvector of a is a nonzero such that with some . \\\\ See also: , , .",
      "deg": 6
    },
    {
      "id": "evd",
      "name": "eigenvalue decomposition (EVD)",
      "desc": "The EVD for a square is a factorization of the form The columns of the are the of the . The diagonal contains the corresponding to the . Note that the above decomposition exists only if the is diagonalizable. \\\\ See also: , , .",
      "deg": 5
    },
    {
      "id": "svd",
      "name": "singular value decomposition (SVD)",
      "desc": "The SVD for a is a factorization of the form with orthonormal and . The is only nonzero along the main diagonal, whose entries are nonnegative and referred to as singular values. \\\\ See also: .",
      "deg": 1
    },
    {
      "id": "tv",
      "name": "total variation",
      "desc": "See .",
      "deg": 1
    },
    {
      "id": "cvxclustering",
      "name": "convex clustering",
      "desc": "Consider a . learns by minimizing Here, denotes the - (for ). It turns out that many of the optimal coincide. A then consists of those with identical , . \\\\ See also: , , , , , , .",
      "deg": 7
    },
    {
      "id": "gdmethod",
      "name": "gradient-based method",
      "desc": "A -based method is an iterative technique for finding the (or ) of a of the . Such a method constructs a sequence of approximations to an optimal choice for . As the name indicates, a -based method uses the of the evaluated during previous iterations to construct new, (hopefully) improved . One important example of a -based method is . \\\\ See also: , , , , .",
      "deg": 26
    },
    {
      "id": "sgd",
      "name": "subgradient descent",
      "desc": "descent is a of that does not require differentiability of the to be minimized. This generalization is obtained by replacing the concept of a with that of a . Similar to , allow us to construct local approximations of an . The might be the viewed as a of the that select a . \\\\ See also: , , , , , , , , .",
      "deg": 10
    },
    {
      "id": "stochGD",
      "name": "stochastic gradient descent (SGD)",
      "desc": "SGD is obtained from by replacing the of the with a approximation. A main application of SGD is to train a parameterized via on a that is either very large or not readily available (e.g., when are stored in a database distributed globally). To evaluate the of the (as a of the ), we need to compute a sum over all in the . We obtain a approximation to the by replacing the sum with a sum over a randomly chosen subset (see Fig. ). We often refer to these randomly chosen as a . The size is an important of SGD. SGD with is referred to as mini- SGD . [H] [scale=1.5, >=stealth] plot ( , {( -1.5)^2 + 1}); at (0.5, 2) { }; plot ( , {( -2)^2 + 0.5}); at (3.3, 1.5) { }; {SGD for approximates the by replacing the sum over all in the (indexed by ) with a sum over a randomly chosen subset . } See also: , , , , , , , , , , , , .",
      "deg": 22
    },
    {
      "id": "onlineGD",
      "name": "online gradient descent (online GD)",
      "desc": "Consider an method that learns from some . The learning process uses that arrive at consecutive time instants . Let us interpret the as copies of a . The of a can then (under mild conditions) be obtained as the limit . We might use this limit as the for learning the . Unfortunately, this limit can only be evaluated if we wait infinitely long in order to collect all . Some applications require methods that learn online, i.e., as soon as a new arrives at time , we update the current . Note that the new contributes the component to the . As its name suggests, online updates via a (projected) such that ^{( +1)} { ^{( )} - _{ } _{ } { ^{( )}}{ }}. Note that is a for the current component of the . The update ignores all previous components , for . It might therefore happen that, compared with , the updated increase the retrospective average . However, for a suitably chosen , online can be shown to be optimal in practically relevant settings. By optimal, we mean that the delivered by online after observing are at least as good as those delivered by any other learning method , . [H] [x=1.5cm,scale=1.5, every node/.style={font= }] (0.5, 0) -- (5.5, 0) node[below] {}; in {1, 2, 3, 4, 5} { ( , 0.1) -- ( , -0.1) node[below] { }; } / in {1/2.5, 2/1.8, 3/2.3, 4/1.5, 5/2.0} { ( , ) circle (2pt) node[above right] { }; } / in {1/1.0, 2/1.6, 3/1.8, 4/2.2, 5/1.9} { ( , ) circle (2pt) node[below left] { }; } / / in {1/2.5/1.0, 2/1.8/1.6, 3/2.3/2.0, 4/1.5/1.8, 5/2.0/1.9} { ( , ) -- ( , ); } {An instance of online that updates the using the arriving at time . This instance uses the .} See also: , , , .",
      "deg": 17
    },
    {
      "id": "pca",
      "name": "principal component analysis (PCA)",
      "desc": "PCA determines a linear such that the new allow us to reconstruct the original with the reconstruction error . \\\\ See also: , , , .",
      "deg": 10
    },
    {
      "id": "loss",
      "name": "loss",
      "desc": "methods use a to measure the error incurred by applying a specific to a specific . With a slight abuse of notation, we use the term loss for both the itself and the specific value , for a and . \\\\ See also: , .",
      "deg": 50
    },
    {
      "id": "lossfunc",
      "name": "loss function",
      "desc": "A is a It assigns a nonnegative real number (i.e., the ) to a pair that consists of a , with and , and a . The value quantifies the discrepancy between the true and the . Lower (closer to zero) values indicate a smaller discrepancy between and . Fig. depicts a for a given , with and , as a of the . [H] [scale = 0.7, every axis/.append style={ axis line style={-Latex, thick}, tick style={thick} }] [axis x line=center, axis y line=center, xlabel={}, xlabel style={below right}, ylabel style={above right}, xtick= , ytick= , xmin=-5, xscale = 1.4, xmax=5, ymin=-0.5, ymax=2.5 ] ; ; ; [below] at (10,1) { }; [right] at (4,6) { }; {Some for a fixed , with and , and a varying . methods try to find (or learn) a that incurs minimal .} See also: , , , .",
      "deg": 31
    },
    {
      "id": "decisiontree",
      "name": "decision tree",
      "desc": "A decision tree is a flowchart-like representation of a . More formally, a decision tree is a directed containing a root node that reads in the of a . The root node then forwards the to one of its child nodes based on some elementary test on the . If the receiving child node is not a leaf node, i.e., it has child nodes itself, it represents another test. Based on the test result, the is forwarded to one of its descendants. This testing and forwarding of the is continued until the ends up in a leaf node without any children. See Fig.\\ for visual illustrations. [H] {.45 } { (A) {}; (B) {}; (C) {}; (D) {}; (E) {}; (A) -- (B) node[midway, left] {no}; (A) -- (C) node[midway, right] {yes}; (C) -- (D) node[midway, left] {no}; (C) -- (E) node[midway, right] {yes}; at (0.7,-4.5) { (a)}; } {.45 } (-2,2) rectangle (2,-2); (-0.5,0) circle (1cm); (0.5,0) circle (1cm); (-2,1.5) rectangle (2,-1.5); (-0.5,0) circle (1cm); (0.5,0) circle (1cm); (-0.5,0) circle [radius=0.025]; [below right, red] at (-0.5,0) { }; [below left, blue] at (-0.7,0) { }; [above left] at (-0.7,1) { }; [left] at (-0.4,0) { }; (0.5,0) circle [radius=0.025]; [right] at (0.6,0) { }; at (0,-3.5) { (b)}; {(a) A decision tree is a flowchart-like representation of a piecewise constant . Each piece is a . The depicted decision tree can be applied to numeric , i.e., . It is parameterized by the threshold and the . (b) A decision tree partitions the into . Each corresponds to a specific leaf node in the decision tree.} See also: .",
      "deg": 15
    },
    {
      "id": "API",
      "name": "application programming interface (API)",
      "desc": "An API is a formal mechanism that allows software components to interact in a structured and modular way . In the context of , APIs are commonly used to provide access to a trained . Users—whether humans or machines—can submit the of a and receive a corresponding . Suppose a trained is defined as . Through an API, a user can input and receive the output without knowledge of the detailed structure of the or its training. In practice, the is typically deployed on a server connected to the Internet. Clients send requests containing values to the server, which responds with the computed . APIs promote modularity in system design, i.e., one team can develop and train the , while another team handles integration and user interaction. Publishing a trained via an API also offers practical advantages. For instance, the server can centralize computational resources that are required to compute . Furthermore, the internal structure of the remains hidden—which is useful for protecting intellectual property or trade secrets. However, APIs are not without . Techniques such as can potentially reconstruct a from its using carefully selected . \\\\ See also: , , , , , , .",
      "deg": 8
    },
    {
      "id": "modelinversion",
      "name": "model inversion",
      "desc": "A inversion is a form of on an system. An adversary seeks to infer of individual by exploiting partial access to a trained . This access typically consists of querying the for using carefully chosen inputs. Basic inversion techniques have been demonstrated in the context of facial image , where images are reconstructed using the ( of) outputs combined with auxiliary information such as a person’s name (see Fig. ). [H] [scale=1.5] (-0.5,0) -- (5.5,0) node[right] {face image }; (0,-0.2) -- (0,2.5) node[above] {name}; plot ({ }, {2/(1 + exp(-3*( - 3)))}); {2/(1 + exp(-3*( - 3)))} ( ,0) -- ( , ); (0, ) -- ( , ); ( , ) circle (0.1); at (-0.1, ) { ``Alexander Jung''}; at ( ,-0.25) { }; at (4,2.2) {trained }; {Model inversion techniques implemented in the context of facial image classification. } See also: , , , , , , , , , .",
      "deg": 13
    },
    {
      "id": "samplesize",
      "name": "sample size",
      "desc": "The number of individual contained in a or . Consider a -based method that uses a with sample size and a with . If the can be well-approximated by the , then the ratio between and can be a useful indicator for the occurence of . \\\\ See also: , .",
      "deg": 11
    },
    {
      "id": "skipconnection",
      "name": "skip connection",
      "desc": "Consider a with neurons that are organized in consecutive . A skip connection links the output of a neuron in some to the input of a neuron in a non-consecutive .\\\\ See also: , .",
      "deg": 3
    },
    {
      "id": "ann",
      "name": "artificial neural network (ANN)",
      "desc": "An artificial neural network (ANN) is a graphical (signal-flow) representation of a that maps of a at its input to a for the corresponding at its output. The fundamental computational unit of an ANN is the artificial neuron, which applies an to the sum of its inputs. The output of a neuron can be used either as the final output of the ANN or as an input to other neurons. A key design parameter of an ANN is its connectivity structure (or architecture), i.e., which neuron outputs are connected to which neuron inputs. As illustrated in Fig.\\ , we can represent an ANN as an . One widely used type of are where neurons form consecutive . In a , the outputs of neurons in a given are typically only connnected to the inputs of the neurons in a consecutive . Sometimes it is useful to add shortcut or skip connections that directly connect the outputs of neurons in one to the inputs of neurons in a non-consecutive . [H] [>=stealth, node distance=2.3cm and 2.4cm] (x1) {}; (x2) [below=of x1] {}; (h1) [right=of x1, yshift=5mm] {}; (h2) [right=of x2, yshift=-5mm] {}; (y) [right=of h1, yshift=-2cm] {}; (x1) -- (h1) node [midway, above] { }; (x2) -- (h1)node [pos=0.1, above] { }; (x1) -- (h2) node [pos=0.8, above] { }; (x2) -- (h2) node [midway, above] { }; (h1) -- (y) node [midway, above] { }; (h2) -- (y) node [midway, above] { }; (x1) -- (y) node [midway, above] { }; {An ANN can be represented as a weighted with nodes representing neurons or of a . can be viewed as trivial neurons without input and fixed ouput given by the value. The weighted directed edges indicate how neuron outputs are used as inputs to other neurons. The edge weights are tunable and are used to scale the inputs to the neurons. The output of some neurons are used as the . } See also: , , , .",
      "deg": 27
    },
    {
      "id": "randomforest",
      "name": "random forest",
      "desc": "A random forest is a set of different . Each of these is obtained by fitting a perturbed copy of the original . \\\\ See also: , .",
      "deg": 3
    },
    {
      "id": "gd",
      "name": "gradient descent (GD)",
      "desc": "GD is an iterative method for finding the of a . GD generates a sequence of estimates that (ideally) converge to a of . At each iteration , GD refines the current estimate by taking a step in the direction of the steepest descent of a local linear approximation. This direction is given by the negative of the at the current estimate . The resulting update rule is given by ^{( \\!+\\!1)} = ^{( )} - f( ^{( )}) where is a suitably small . For a suitably choosen , the update typically reduces the value, i.e., . Fig.\\ illustrates a single GD step. [H] [scale=0.9] (-4,0) grid (4,4); plot ( , {(1/4)* }); plot ( , {2* - 4}); (4,4) -- node[right] { } (4,2); (4,4) -- node[above] { } (1,4); (4,2) -- node[below] { } (3,2) ; (-4.25,0) -- (4.25,0) node[right] { }; (0,-2pt) -- (0,4.25) node[above] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; (0pt,2pt) -- (0pt,-2pt) node[below] { }; / in {1/1, 2/2, 3/3, 4/4} (2pt,0pt) -- (-2pt,0pt) node[left] { }; {A single toward the minimizer of .} See also: , , , , .",
      "deg": 19
    },
    {
      "id": "abserr",
      "name": "absolute error loss",
      "desc": "Consider a with and numeric . As its name suggests, the absolute error incurred by a is defined as Fig. depicts the absolute error for a fixed with and . It also indicates the values incurred by two different and . Similar to the , the absolute error is also a of the . However, in contrast to the , the absolute error is , as it is not at the optimal . This property makes -based methods using the absolute error computationally more demanding , . To build intuition, it is useful to consider the two depicted in Fig. . Just by inspecting the slope of around and , it is impossible to determine whether we are very close to the optimum (at ) or still far away (at ). As a result, any that is based on local approximations of the (such as ) must use a decreasing to avoid overshooting when approaching the optimum. This required decrease in tends to slow down the of the . Besides the increased computational complexity, using absolute error in can be beneficial in the presence of in the . In contrast to the , the slope of the absolute error does not increase with increasing error . As a result, the effect of introducing an with large error on the solution of with absolute error is much smaller compared with the effect on the solution of with . [H] [x=3cm,y=1.6cm] {0.0} {0.6} {3.7} [axis lines=middle,xtick= ,ytick= ,width=15cm,height=5cm,xmin=-4,xmax=4,ymin=-0.2,ymax=3,domain=-4:4,samples=100,clip=false,enlarge x limits=0.15,enlarge y limits=0.15] ; coordinates {( , 0)}; at (axis cs: , 0) { }; {abs( - )} coordinates {( , )}; at (axis cs: , ) { }; at (axis cs: , 0) { }; coordinates {( , 0) ( , )}; {abs( - )} coordinates {( , )}; at (axis cs: , 0) { }; coordinates {( , 0) ( , )}; at (axis cs: , ) { }; at (axis cs:4,0) { }; {For a with numeric , the absolute error can be used as a to guide the learning of a . } See also: , , , , , , .",
      "deg": 26
    },
    {
      "id": "device",
      "name": "device",
      "desc": "A physical system that can store and process . In the context of , the term typically refers to a computer capable of reading from different sources and using them to train an . \\\\ See also: , , , .",
      "deg": 12
    },
    {
      "id": "huberreg",
      "name": "Huber regression",
      "desc": "Huber refers to -based methods that use the as a measure of the error. Two important special cases of Huber are and . Tuning the threshold of the allows the user to trade the of the against the computational benefits of the . \\\\ See also: , , , .",
      "deg": 13
    },
    {
      "id": "ladregression",
      "name": "least absolute deviation regression",
      "desc": "Least absolute deviation regression is an instance of using the . It is a special case of . [H] [scale=0.7, y=0.5cm, x=0.5cm] / in { 1/2, 4/3, 7/4 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptA ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (7.5, -4) {(a)}; [xshift=10cm] / in { 1/2, 4/3, 7/10 } { ( , 0) -- ( , ); ( , ) circle (2pt); (ptB ) at ( , ) {}; } (0.5, 3) -- (10.5, 3) node[right] { }; at (ptB7) {outlier}; at (7.5, -4) {(b)}; {For the simple , with amounts to computing the . (a) Original . (b) Noisy including an . } For the , with is solved by the . Using instead for the same , makes computing the . \\\\ See also: , , .",
      "deg": 12
    },
    {
      "id": "metric",
      "name": "metric",
      "desc": "A metric is a quantitative measure used to compare objects. In mathematics, a metric measures the distance between two points in a space and must follow specific rules, i.e., the distance is always nonnegative, zero only if the points are the same, symmetric, and it satisfies the triangle inequality . In the context of , the term metric refers to a quantitative measure of how well a performs (somewhat similar to a ). Examples include , precision, and the average on a , . The term is typically used in the context of , while the term metric is used in the context of . \\\\ See also: , , .",
      "deg": 14
    },
    {
      "id": "bayesrisk",
      "name": "Bayes risk",
      "desc": "Consider a for a application where each is interpreted as a . The includes a for the and of a . The Bayes is the possible that can be achieved by any . Any that achieves the Bayes is referred to as a . \\\\ See also: , , .",
      "deg": 14
    },
    {
      "id": "bayesestimator",
      "name": "Bayes estimator",
      "desc": "Consider a with a joint over the and the of a . For a given , we refer to a as a Bayes estimator if its is the achievable . Note that whether a qualifies as a Bayes estimator depends on the underlying and the choice for the . \\\\ See also: , , .",
      "deg": 11
    },
    {
      "id": "weights",
      "name": "weights",
      "desc": "Consider a parameterized . We use the term weights for numeric that are used to scale or their transformations in order to compute . A uses weights to compute the linear combination . Weights are also used in to form linear combinations of or the outputs of neurons in hidden (see Fig. ). [H] [neuron/.style={circle, draw, minimum size=1cm}, thick, >=stealth] (h1) at (0, 2) { }; (h2) at (0, 0) { }; (h3) at (0, -2) { }; (outpoint); at ([xshift=0.2cm]outpoint) { }; (h1) -- node[above] { } (outpoint); (h2) -- node[above] { } (outpoint); (h3) -- node[below] { } (outpoint); {A section of an that contains a hidden with outputs (or ) , , and . These outputs are combined linearly to compute , which can be used either as output of the or as input to another . } See also: , , , , , , .",
      "deg": 15
    },
    {
      "id": "probdist",
      "name": "probability distribution",
      "desc": "To analyze methods, it can be useful to interpret as of a . The typical properties of such are then governed by the distribution of this . The distribution of a binary is fully specified by the and . The distribution of a real-valued might be specified by a such that . In the most general case, a distribution is defined by a measure , . \\\\ See also: , , , , .",
      "deg": 46
    },
    {
      "id": "pdf",
      "name": "probability density function (pdf)",
      "desc": "The pdf of a continuous real-valued allows to compute the (of the ) via a This definition extends naturally to a (continuous) vector-valued as the is defined for with any . \\\\ See also: , , , , .",
      "deg": 13
    },
    {
      "id": "parameter",
      "name": "parameter",
      "desc": "The parameter of an is a tunable (i.e., learnable or adjustable) quantity that allows us to choose between different . For example, the consists of all with a particular choice for the parameters . Another example of a parameter is the assigned to a connection between two neurons of an . \\\\ See also: , , , , , , .",
      "deg": 26
    },
    {
      "id": "lln",
      "name": "law of large numbers",
      "desc": "The law of large numbers refers to the of the average of an increasing (large) number of to the of their common . Different instances of the law of large numbers are obtained by using different notions of . \\\\ See also: , , , , .",
      "deg": 6
    },
    {
      "id": "stopcrit",
      "name": "stopping criterion",
      "desc": "Many methods use iterative that construct a sequence of in order to minimize the . For example, iteratively update the of a parametric , such as a or a . Given a finite amount of computational resources, we need to stop updating the after a finite number of iterations. A stopping criterion is any well-defined condition for deciding when to stop updating. \\\\ See also: , .",
      "deg": 10
    },
    {
      "id": "jacobimethod",
      "name": "Jacobi method",
      "desc": "The Jacobi method is an for solving systems of linear equations (i.e., a linear system) of the form . Here, is a square with nonzero main diagonal entries. The method constructs a sequence by updating each entry of according to Note that all entries are updated simultaneously. The above iteration converges to a solution, i.e., , under certain conditions on the , e.g., being strictly diagonally dominant or symmetric positive definite , , . Jacobi-type methods are appealing for large linear systems due to their parallelizable structure . We can interpret the Jacobi method as a . Indeed, using the decomposition , with being the diagonal of , allows us to rewrite the linear equation as a fixed-point equation which leads to the iteration . \\\\ As an example, for the linear equation the Jacobi method updates each component of as follows: See also: , , , .",
      "deg": 4
    },
    {
      "id": "renyidiv",
      "name": "R\\'enyi divergence",
      "desc": "The R\\'enyi divergence measures the (dis)similarity between two . \\\\ See also: .",
      "deg": 1
    },
    {
      "id": "nonsmooth",
      "name": "non-smooth",
      "desc": "We refer to a as non-smooth if it is not . \\\\ See also: , .",
      "deg": 4
    },
    {
      "id": "convex",
      "name": "convex",
      "desc": "A subset of the is referred to as convex if it contains the line segment between any two points in that set. A is convex if its is a convex set . We illustrate one example of a convex set and a convex in Fig. . [H] (-3,0) ellipse (2 and 1.2); (-3,0) ellipse (2 and 1.2); (-3.7,0.2) circle (2pt) node[left] { }; (-2.3,-0.5) circle (2pt) node[right] { }; (-3.7,0.2) -- (-2.3,-0.5); at (-1.2,-1.0) { }; at (-3,-2.4) {(a)}; [shift={(5,-1)}] plot ({ }, {0.5* }); plot[domain=-1.5:1.5, smooth] ({ }, {0.5* }) -- (2, {0.5*2*2}) -- (-2, {0.5*2*2}) -- cycle; at (0,-0.4) { }; at (0,-1.4) {(b)}; {(a) A convex set . (b) A convex . } See also: , , .",
      "deg": 17
    },
    {
      "id": "smooth",
      "name": "smooth",
      "desc": "A real-valued is smooth if it is and its is continuous at all , . A smooth is referred to as -smooth if the is Lipschitz continuous with Lipschitz constant , i.e., The constant quantifies the smoothness of the : the smaller the , the smoother is. with a smooth can be solved effectively by . Indeed, approximate the locally around a current choice using its . This approximation works well if the does not change too rapidly. We can make this informal claim precise by studying the effect of a single with (see Fig. ). [H] [scale=0.8, x=0.6cm,y=0.05cm] plot ({ }, { ^2}); (w) at ( ,{ }); (wkplus1) at (4+ ,{(4+ )^2}); (wk) at (8+ ,{(8+ )^2}); (wk) -- +(-2, -{4*(8 + )} ) -- +(1, {2*(8 + )}); (w) -- +(-1, {-{2* }} ) -- +(1, {+{2* }}) node[below] { }; (wk) circle (2pt) node[above left] { } node[below right, xshift=-15pt,yshift=-15pt] { } ; (w) circle (2pt) node[above right] { } ; (wkplus1) circle (2pt) node[below right] { }; (wk) -- ( ) ; (wkplus1) -- ( ) ; ( ) -- ( ) node[midway, right] { }; {Consider an that is -smooth. Taking a , with , decreases the objective by at least , , . Note that the becomes larger for smaller . Thus, for smoother (i.e., those with smaller ), we can take larger steps. } See also: , , , .",
      "deg": 15
    },
    {
      "id": "parammodel",
      "name": "parametric model",
      "desc": "A parametric is a mathematical characterized by a finite set of variable quantities called . An important example is the consisting, for a given , of all (on ) with some and . In the context of , a parametric defines a parameterized by a finite number of . Each is uniquely identified by a list of (see Fig.~ ). We can stack these into a . Two widely used examples of parametric are the and the . The corresponding is typically a subset of . [H] (paramspace) {}; { space }; (theta1) at ( ) {}; ; (theta2) at ( ) {}; ; (plotcloud) {}; { }; (plot1start) at ( ) {}; (plot1start) .. controls ++(0.8, 1) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (plot2start) at ( ) {}; (plot2start) .. controls ++(0.8, 0.5) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (theta1) to ( ); (theta2) to (plot2start); {The space of an consists of all feasible choices for the . Each choice for the selects a . } See also: , , .",
      "deg": 21
    },
    {
      "id": "paramspace",
      "name": "parameter space",
      "desc": "The space of an is the set of all feasible choices for the (see Fig. ). Many important methods use a that is parameterized by of the . Two widely used examples of parameterized are and . The space is then often a subset , e.g., all with a smaller than one. [H] (paramspace) {}; { space }; (theta1) at ( ) {}; ; (theta2) at ( ) {}; ; (plotcloud) {}; { }; (plot1start) at ( ) {}; (plot1start) .. controls ++(0.8, 1) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (plot2start) at ( ) {}; (plot2start) .. controls ++(0.8, 0.5) and ++(-0.8, -0.8) .. ( ) node[anchor=west] { }; (theta1) to ( ); (theta2) to (plot2start); {The space of an consists of all feasible choices for the . Each choice for the selects a . } See also: , , .",
      "deg": 16
    },
    {
      "id": "datanorm",
      "name": "data normalization",
      "desc": "normalization refers to transformations applied to the of to improve the method's or . For example, in with using a fixed , depends on controlling the of in the . A common approach is to normalize such that their does not exceed one . \\\\ See also: , , .",
      "deg": 13
    },
    {
      "id": "dataaug",
      "name": "data augmentation",
      "desc": "augmentation methods add synthetic to an existing set of . These synthetic are obtained by perturbations (e.g., adding noise to physical measurements) or transformations (e.g., rotations of images) of the original . These perturbations and transformations are such that the resulting synthetic should still have the same . As a case in point, a rotated cat image is still a cat image even if their (obtained by stacking pixel color intensities) are very different (see Fig. ). augmentation can be an efficient form of . [H] {0.5} {2} plot[smooth, tension=1] coordinates {(0,0) (2,1) (4,0) (6,-1) (8,0)}; at (0,0) { }; plot[smooth, tension=1] coordinates {(0 + ,0 + ) (2 + ,1 + ) (4 + ,0 + ) (6 + ,-1 + ) (8 + ,0 + )}; at (8 + ,0 + ) { }; (2,1) circle (2pt) node[above] { }; (6,-1) circle (2pt) node[above] { }; (2,1) to[out=240, in=240] node[midway, below] { } (6,-1); { augmentation exploits intrinsic symmetries of in some . We can represent a symmetry by an operator , parameterized by some number . For example, might represent the effect of rotating a cat image by degrees. A with must have the same as a with . } See also: , , , , , .",
      "deg": 9
    },
    {
      "id": "localdataset",
      "name": "local dataset",
      "desc": "The concept of a local is in between the concept of a and a . A local consists of several individual characterized by and . In contrast to a single used in basic methods, a local is also related to other local via different notions of similarity. These similarities might arise from or communication infrastructure and are encoded in the edges of an . \\\\ See also: , , , , , , .",
      "deg": 13
    },
    {
      "id": "localmodel",
      "name": "local model",
      "desc": "Consider a collection of that are represented as nodes of an . A local is a assigned to a node . Different nodes can have different , i.e., in general, for different nodes . \\\\ See also: , , , .",
      "deg": 11
    },
    {
      "id": "mutualinformation",
      "name": "mutual information (MI)",
      "desc": "The MI between two , defined on the same is given by It is a measure of how well we can estimate based solely on . A large value of indicates that can be well predicted solely from . This could be obtained by a learned by an -based method. \\\\ See also: , , , , , .",
      "deg": 7
    },
    {
      "id": "zerogradientcondition",
      "name": "zero-gradient condition",
      "desc": "Consider the unconstrained with a and . [htbp] [scale=1.1,x=2cm] {1} {0.5} {-0.2} {2.4} {( - )^2 + } plot ( ,{( - )^2 + }); at ( , ) { }; (xstar) at ( , ); (xstar) circle (1.6pt); ( ,0) -- (xstar) node[below,yshift=-18pt] { }; (0, ) -- (xstar); (xstar) ++(-0.7,0) -- ++(1.4,0); [xshift=20pt,yshift=-5pt] at ( ) { }; A necessary and sufficient condition for a to solve this problem is that the is the zero . In other words , By defining the operator , we can rewrite the zero-gradient condition as a fixed-point equation Here, denotes the identity operator (i.e., ) and is an arbitrary positive number. \\\\ See also: , , , , , .",
      "deg": 7
    },
    {
      "id": "edgeweight",
      "name": "edge weight",
      "desc": "Each edge of an is assigned a nonnegative edge weight . A zero edge weight indicates the absence of an edge between nodes . \\\\ See also: .",
      "deg": 3
    },
    {
      "id": "dataminprinc",
      "name": "data minimization principle",
      "desc": "European protection regulation includes a minimization principle. This principle requires a controller to limit the collection of personal information to what is directly relevant and necessary to accomplish a specified purpose. The should be retained only for as long as necessary to fulfill that purpose , . \\\\ See also: .",
      "deg": 2
    },
    {
      "id": "layer",
      "name": "layer",
      "desc": "A is an that consists of consecutive layers, indexed by . The -th layer consists of artificial neurons with the layer width . Each of these artificial neurons evaluates an for a weighted sum of the outputs (or ) of the previous layer . The input to layer is formed from weighted sums of the of the for which the computes a . The outputs of the neurons in layer are then, in turn, used to form the inputs for the neurons in the next layer. The final (output) layer consists of a single neuron whose output is used as the delivered by the . \\\\ See also: , .",
      "deg": 17
    },
    {
      "id": "activation",
      "name": "activation",
      "desc": "The output of an artificial neuron within an is referred to as its activation. In particular, the activation is obtained by applying a (typically nonlinear) to a weighted sum of its inputs. \\\\ See also: , .",
      "deg": 7
    },
    {
      "id": "cav",
      "name": "concept activation vector (CAV)",
      "desc": "Consider a , consisting of several hidden , trained to predict the of a from its . One way to explain the behavior of the trained is by using the of a hidden as a new . We then probe the geometry of the resulting new by applying the to that represent a specific concept . By applying the also to that do not belong to this concept, we can train a binary that distinguishes between concept and non-concept based on the of the hidden . The resulting is a hyperplane whose normal is the CAV for the concept . \\\\ See also: , , , , .",
      "deg": 14
    },
    {
      "id": "backpropagation",
      "name": "backpropagation",
      "desc": "Backpropagation is an for computing the of an that depends on the of an . One example of such an is the average incurred by the on a of . This is a direct application of the chain rule from calculus to efficiently compute partial derivatives of the with respect to the . Backpropagation consists of two consecutive phases, also illustrated in Fig. . The first phase includes the forward pass, where a of is fed into the . The processes the input through its using its current , ultimately producing a at its output. The of the is compared to the true using a , which quantifies the error. The second phase includes the backward pass (i.e., backpropagation), where the error is backpropagated through the . The obtained partial derivatives with respect to the constitute the , which can be used, in turn, to implement a . [H] [ >=Stealth, neuron/.style={circle,draw,minimum size=9mm,inner sep=0pt}, conn/.style={-Stealth, line width=0.7pt}, grad/.style={Stealth-, dashed, line width=0.7pt}, lbl/.style={font= }, box/.style={draw, rounded corners, inner sep=4pt} ] (x1) at (0,1.8) { }; (x2) at (0,0) { }; (x3) at (0,-1.8){ }; (h1) { }; (h2) { }; (h3) { }; (yhat) { }; (loss) { }; in {1,2,3}{ in {1,2,3}{ (x ) -- (h ); } } in {1,2,3}{ (h ) -- (yhat); } (yhat) -- (loss); (yhat) to[bend left=10] node[above, lbl] { } (loss); in {1,2,3}{ (h ) to[bend left=10] (yhat); } in {1,2,3}{ in {1,2,3}{ (x ) to[bend left=10] (h ); } } at ( ) { }; at ( ) { }; (legend) { [baseline={(0,0)}] (0,0) -- (1.0,0); at (1.5,0) { forward pass (compute )}; (0,-0.5) -- (1.0,-0.5); at (1.5,-0.5) { backward pass (compute )}; }; at ( ) { ,\\; ,\\; }; {Solid arrows show the forward pass (i.e., flow and calculation), while dashed arrows show the correction flow during the backward pass for updating the { }.} See also: , , , .",
      "deg": 18
    },
    {
      "id": "vcdim",
      "name": "Vapnik–Chervonenkis dimension (VC dimension)",
      "desc": "The statistical properties of an -based method depend critically on the expressive capacity of its (or ) . A standard measure of this capacity is the VC dimension . Formally, it is the largest integer such that there exists a that can be perfectly classified (or shattered) by some . Formally, this means that for every one of the possible assignments of binary to each in , there exists some that realizes this labeling. Intuitively, the VC dimension quantifies how well can fit arbitrary assignments, and thus captures its approximate power. It plays a central role in deriving bounds on the . Fig. illustrates the definition of the VC dimension for a with . Fig.~ (a) and ~ (b) show the same set of three noncollinear under two different binary labelings. In both cases, a separating hyperplane exists that realizes the labeling. Since this holds for all possible binary labelings of the three , the set is shattered. Fig.~ (c) depicts four with a specific labeling. No linear separator can correctly classify all in this case. Thus, . \\\\ [H] {.3 } [scale =.4] [red] (-1,1) circle (3pt); [blue] (1,-1) circle (3pt); [blue] (-1,-1) circle (3pt); [black] (-1.5,0) -- (1.5,0); at (0,-3.4) {(a)}; {.3 } [scale =.4] [red] (-1,1) circle (3pt); [red] (1,-1) circle (3pt); [blue] (-1,-1) circle (3pt); [black] (-1.2,0.3) -- (0.3,-1.2); at (0,-3.4) {(b)}; {.3 } [ scale =.4] [red] (-1,1) circle (3pt); [blue] (1,1) circle (3pt); [red] (1,-1) circle (3pt); [blue] (-1,-1) circle (3pt); at (0,-3.4) {(c)}; {Illustration of the VC dimension for a that is used to learn a in the . } More generally, for a , the VC dimension equals . In other words, for , the VC dimension essentially matches the dimension of the underlying . For more complex , such as or , the relation between VC dimension and the dimension of the is far less direct. In these cases, alternative complexity measures, such as the , can be more useful for analyzing -based methods. \\\\ See also: , , , , .",
      "deg": 21
    },
    {
      "id": "metricspace",
      "name": "metric space",
      "desc": "A metric space is a set equipped with a function (referred to as a metric) , that satisfies the following requirements for all : , if and only if , , . Formally, a metric space is a pair that satisfies the above requirements. [H] [>=stealth, x=0.5cm, y=1cm] at (2.5,3.6) { }; at (12.5,3.6) { }; [shift={(0,0)}] (0,0) -- (5.2,0) node[below right] { }; (0,0) -- (0,3.2) node[left] { }; (X) at (1.1,0.9); (Y) at (3.8,2.1); (X) circle (1.2pt) node[below left] { }; (Y) circle (1.2pt) node[above right] { }; (X) -- (Y) node[midway, below right, xshift=1pt] { }; [shift={(9.0,0)}] (A) at (1.0,0.6); (B) at (3.1,0.9); (C) at (2.2,2.6); (D) at (4.8,2.2); (E) at (0.4,2.1); (A)--(B)--(C)--(E)--(A); (C)--(D)--(B); (A) circle (1.2pt) node[below left] { }; (D) circle (1.2pt) node[above right] { }; (A)--(B)--(D); at (5.0,0.7) { }; (B) circle (1.2pt); (C) circle (1.2pt); (E) circle (1.2pt); {Examples of metric spaces: Left: with the as metric. Right: with the shortest-path distance as metric. } A prominent example of a metric space is the equipped with metric given by the Euclidean distance . Another well-known example of a metric space is an , with the metric defined by the length of the shortest path connecting nodes and . \\\\ See also: , , .",
      "deg": 7
    },
    {
      "id": "rademachercomplexity",
      "name": "Rademacher complexity",
      "desc": "Similar to the , the Rademacher complexity is a quantitative measure for the size of a . It is defined via the empirical Rademacher complexity, which is defined for a given as _ ( ) = _{ _{1}, , _{ } } _{ } { } _{ =1}^ _ ( ^{( )} ). Here, the is taken with respect to the , which are and taking values in with equal . The Rademacher complexity of is then defined as the of the empirical Rademacher complexity of a random that consists of , for . See also: , , , , .",
      "deg": 11
    },
    {
      "id": "penaltyterm",
      "name": "penalty term",
      "desc": "Consider an -based method that learns by minimizing the average (or ) on a . To avoid , and control the , it is common to augment the with a penalty term . We refer to the resulting modified as . [H] [scale = 1] (0,0.5) -- (7.7,0.5) node[right] { }; (0.5,0) -- (0.5,4.2) node[above] { }; plot ({ },{ 0.4 + 2.0}) ; at (6.7,4.5) { }; (l1) at (1.2, 2.48); (l2) at (1.4, 2.56); (l3) at (1.7, 2.68); (l4) at (2.2, 2.2*0.4+2.0); (l5) at (2.4, 2.4*0.4+2.0); (l6) at (2.7, 2.7*0.4+2.0); (l7) at (3.9, 3.9*0.4+2.0); (l8) at (4.2, 4.2*0.4+2.0); (l9) at (4.5, 4.5*0.4+2.0); (n1) at (1.2, 1.8); (n2) at (1.4, 1.8); (n3) at (1.7, 1.8); (n4) at (2.2, 3.8); (n5) at (2.4, 3.8); (n6) at (2.7, 3.8); (n7) at (3.9, 2.6); (n8) at (4.2, 2.6); (n9) at (4.5, 2.6); at (n1) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c1] {}; at (n2) [circle,draw,fill=blue,minimum size=6pt, scale=0.6, name=c2] {}; at (n3) [circle,draw,fill=red,minimum size=6pt,scale=0.6, name=c3] {}; at (n4) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c4] {}; at (n5) [circle,draw,fill=blue,minimum size=12pt,scale=0.6, name=c5] {}; at (n6) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c6] {}; at (n7) [circle,draw,fill=red,minimum size=12pt,scale=0.6, name=c7] {}; at (n8) [circle,draw,fill=blue,minimum size=12pt, scale=0.6, name=c8] {}; at (n9) [circle,draw,fill=red,minimum size=12pt, scale=0.6, name=c9] {}; [<->] ( ) -- ( ) node [pos=0.4, below] { }; ; (l1) -- (c1); (l2) -- (c2); (l3) -- (c3); (l4) -- (c4); (l5) -- (c5); (l6) -- (c6); (l7) -- (c7); (l8) -- (c8); (l9) -- (c9); (6.2, 3.7) circle (0.1cm) node [black,xshift=2.3cm] {original }; (6.2, 3.2) circle (0.1cm) node [black,xshift=1.3cm] {augmented}; at (4.6,1.2) [minimum size=12pt, font= {0} , text=blue] { }; at (7.8,1.2) [minimum size=12pt, font= {0} , text=red] { }; {Adding a penalty term to the in is equivalent to including perturbations of the during . The parameter controls the extend of the perturbations. } The penalty term depends only on the but not on the in the . For some combinations of and , the penalty term can be obtained as the average incurred on (an infinite number of) perturbed copies of the . In other words, adding a penalty term in can be viewed as a form of . \\\\ See also: , , , .",
      "deg": 18
    },
    {
      "id": "sequence",
      "name": "sequence",
      "desc": "A sequence is an ordered collection of values from a set . For example, a sequence of values from the set could be Formally, a sequence is a We denote a sequence as or . Sometimes we also use the notation . Note that the same value can appear multiple times in the sequence at different positions . Sequences are fundamental for the study of methods, for instance when describing successive iterates of an iterative . We can also use a sequence to represent an infinite \\\\ See also: , .",
      "deg": 12
    },
    {
      "id": "convergence",
      "name": "convergence",
      "desc": "Consider a with numeric values . This is said to converge to a value if the values become arbitrarily close to for sufficiently large indices , Mathematically speaking, the converges to if We denote the convergence of a to by [x=1.2cm, y=2cm, >=stealth] (0.5,0) -- (6.5,0) node[right] { }; (0.5,0) -- (0.5,1.6) node[above] { }; (0, {1- }) rectangle (6.3, {1+ }); (0,{1+ }) -- (6.3,{1+ }) node[right] { }; (0,{1- }) -- (6.3,{1- }) node[right] { }; (0,1) -- (6.3,1) node[right] { }; in {1,...,6} { {1 - 0.6^( )} ( , ) circle (2pt); } in {1,2,3} { ( ,0.02) -- ( ,-0.02) node[below] { }; } ( ,0) -- ( ,1.7); at ( ,1.7) { }; {A real-valued sequence converging to the limit . } The concept of convergence of a real-valued (where ) exstends naturally to a in an aribtrary . Indeed, we just need to replace the absolute difference by the . Note that a can only converge if it is a CITE. However, not every is converging (as this requires the underlying to be complete). \\\\ See also: , , .",
      "deg": 10
    },
    {
      "id": "johnsonlindenstrausslemma",
      "name": "Johnson--Lindenstrauss (JL) lemma",
      "desc": "The describes conditions for the existence of a with such that the pairwise between of a finite is approximately preserved . Consider a with characterized by in . Then, for any that satisfies there is a such that : (1\\!-\\! ) { ^{( )}\\!-\\! ^{( ')}}{2} \\! \\! { ( ^{( )} )\\!-\\! ( ^{( ')} )}{2} \\! \\!(1\\!+\\! ) { ^{( )}\\!-\\! ^{( ')}}{2} for all . [hbtp] (x1) at (0.5,-0.6); (x2) at (2.0,0.9); (x3) at (1.1,0.3); in {x1,x2,x3} ( ) circle (1.7pt); at (x1) { }; at (x2) { }; at (x3) { }; [anchor=east] at (1.2,2.2) { }; [xshift=1cm] (2.9,2.2) -- (4.1,2.2) node[midway, above] { }; [xshift=2cm] (y1) at (4.7,-0.7); (y2) at (6.1,0.5); (y3) at (5.3,-0.1); in {y1,y2,y3} ( ) circle (1.7pt); at (y1) { }; at (y2) { }; at (y3) { }; [anchor=west] at (6.0,2.2) { }; {The JL lemma offers precise conditions that guarantee the existence of a such that pair-wise between (the of) are approximately preserved. Roughly speaking, maps neighbouring points in the original to neighbouring points in the new .} The can be obtained from a random whose entries are Gaussian . It can be shown that the satisfies with at least . \\\\ See also: , , , , , .",
      "deg": 18
    },
    {
      "id": "majmin",
      "name": "majorize-minimize (MM)",
      "desc": "Consider an with some complicated (potentially non- and ) . One important example of such an is for learning the of a non-linear . An MM method is an iterative that constructs a of as follows : During the -th the is aproximated by another . This approximation must be an upper bound for (majorize) the original , i.e., for all , and be tight for , i.e., . The new are then obtained by minimizing the approximation, i.e., . [x=1.2cm,y=1cm] ( -0.2,-2) -- ( +0.3,-2) node[right] { }; plot ( ,{sin( r)}) node[pos=0.1,above left,black] { }; plot ( ,{ + (-0.7)*( - )}); ( ,{ +(-0.7)*( - )}) -- ( ,{ +(-0.7)*( - )}); plot ( ,{ +(-0.7)*( - ) + (0.7)*( - )}); at ( , ) { }; (2.35619449,0.70710678) circle (1.2pt); ( ,-2) -- ( , ); at ( ,-2) { }; Similar to , also the MM principle is based on approximating an locally, around the current , and then optimizing this approximation to obtain new . However, the construction of local approximations is very different: While use linear for these approximations, MM methods can use non-linear as long as they are upper bounds for the original . \\\\ See also: , .",
      "deg": 13
    },
    {
      "id": "markovsinequality",
      "name": "Markov's inequality",
      "desc": "Consider a real-valued non-negative for which the exists. Markov's inequality provides an upper bound on the that exceeds a given positive threshold . In particular, { \\{ x\\}}{a} a > 0. This inequality can be verified by noting that is the with the As illustrated in Figure , for any positive , This implies Markov's inequality via the monotonicity property of the . [scale=1, x=0.8cm, y=0.8cm] (0,0) -- ( +1,0) node[below right] { }; (0,0) -- (0,3.1) node[left] { }; plot[samples=400, domain=0: , smooth] ( ,{ (6/sqrt(2*pi)) * ( )^(1.5) * exp(- /2) }) -- ( ,0) -- (0,0) -- cycle; plot ( ,{ (6/(sqrt(2*pi))) * ( )^(1.5) * exp(- /2) }) node[pos=0.9, above right, xshift=2pt] {}; ( ,0) -- ( ,1.05); at ( ,0) { }; at (1* ,3) { }; at (0,0) { }; (0,0) -- ( ,0); ( ,0) circle (2pt); ( ,1) -- ( ,1) node[pos=0.9, above, yshift=2pt] { }; ( ,1) circle (2pt); plot ( ,{ (1/ ) }); at ({2.5* +0.2},{2.5}) { }; (0,1) -- ++(-0.12,0) node[left] { }; {The and the of a non-negative with can be obtained via of and , respectively.} \\\\ See also: , , .",
      "deg": 8
    },
    {
      "id": "chebyshevsinequality",
      "name": "Chebyshev's inequality",
      "desc": "Consider a real-valued for which the second moment exists (and is finite). The existence of the second moment implies the existence of a finite and a finite . Chebyshev's inequality refers to the following upper bound on the that deviates from by more than a given threshold . In particular, { ^2} > 0. This upper bound can be obtained by applying to the new . [htbp] [ width=9cm, height=4.2cm, samples=300, axis lines=left, ylabel={ }, xlabel={ }, x label style={at={(axis description cs:1,0)}, anchor=west}, ylabel style={rotate=270,anchor=south,at={(axis description cs:0,1.02)}}, xtick={-1.5,0,1.5}, xticklabels={ , , }, ytick= , ymin=0, ymax=0.45, domain=-4:4, clip=false ] ; ; fill between[of=pdf and axis, soft clip={domain=1.5:4}]; fill between[of=pdf and axis, soft clip={domain=-4:-1.5}]; (axis cs:0,0) -- (axis cs:0,0.42); (axis cs:1.5,0) -- (axis cs:1.5,{exp(-0.5*1.5^2)/sqrt(2*pi)}); (axis cs:-1.5,0) -- (axis cs:-1.5,{exp(-0.5*1.5^2)/sqrt(2*pi)}); {Chebyshev's inquality provides an upper bound for the tail (shaded area) of a real-valued with finite second moment. } \\\\ See also: , , .",
      "deg": 6
    }
  ],
  "edges": [
    {
      "source": "pseudoinverse",
      "target": "matrix"
    },
    {
      "source": "pseudoinverse",
      "target": "inverse"
    },
    {
      "source": "pseudoinverse",
      "target": "ridgeregression"
    },
    {
      "source": "pseudoinverse",
      "target": "dataset"
    },
    {
      "source": "pseudoinverse",
      "target": "featuremtx"
    },
    {
      "source": "pseudoinverse",
      "target": "labelvec"
    },
    {
      "source": "pseudoinverse",
      "target": "modelparam"
    },
    {
      "source": "randomexperiment",
      "target": "samplespace"
    },
    {
      "source": "randomexperiment",
      "target": "rv"
    },
    {
      "source": "randomexperiment",
      "target": "function"
    },
    {
      "source": "randomexperiment",
      "target": "probability"
    },
    {
      "source": "randomexperiment",
      "target": "probspace"
    },
    {
      "source": "randomexperiment",
      "target": "lln"
    },
    {
      "source": "randomexperiment",
      "target": "clt"
    },
    {
      "source": "randomexperiment",
      "target": "ml"
    },
    {
      "source": "randomexperiment",
      "target": "trainset"
    },
    {
      "source": "randomexperiment",
      "target": "data"
    },
    {
      "source": "randomexperiment",
      "target": "datapoint"
    },
    {
      "source": "randomexperiment",
      "target": "erm"
    },
    {
      "source": "randomexperiment",
      "target": "stochGD"
    },
    {
      "source": "randomexperiment",
      "target": "privprot"
    },
    {
      "source": "randomexperiment",
      "target": "diffpriv"
    },
    {
      "source": "dimension",
      "target": "vectorspace"
    },
    {
      "source": "dimension",
      "target": "basis"
    },
    {
      "source": "linearlyindep",
      "target": "vectorspace"
    },
    {
      "source": "linearlyindep",
      "target": "vector"
    },
    {
      "source": "linearlyindep",
      "target": "dimension"
    },
    {
      "source": "linearlyindep",
      "target": "basis"
    },
    {
      "source": "basis",
      "target": "vectorspace"
    },
    {
      "source": "basis",
      "target": "linearlyindep"
    },
    {
      "source": "basis",
      "target": "vector"
    },
    {
      "source": "widematrix",
      "target": "matrix"
    },
    {
      "source": "tallmatrix",
      "target": "matrix"
    },
    {
      "source": "imagesegmentation",
      "target": "clustering"
    },
    {
      "source": "mgf",
      "target": "rv"
    },
    {
      "source": "mgf",
      "target": "expectation"
    },
    {
      "source": "rankdeficient",
      "target": "matrix"
    },
    {
      "source": "rankdeficient",
      "target": "fullrank"
    },
    {
      "source": "rankdeficient",
      "target": "linreg"
    },
    {
      "source": "rankdeficient",
      "target": "erm"
    },
    {
      "source": "rankdeficient",
      "target": "featuremtx"
    },
    {
      "source": "rankdeficient",
      "target": "dimension"
    },
    {
      "source": "rankdeficient",
      "target": "vectorspace"
    },
    {
      "source": "fullrank",
      "target": "matrix"
    },
    {
      "source": "fullrank",
      "target": "rank"
    },
    {
      "source": "fullrank",
      "target": "rankdeficient"
    },
    {
      "source": "fullrank",
      "target": "tallmatrix"
    },
    {
      "source": "fullrank",
      "target": "widematrix"
    },
    {
      "source": "fullrank",
      "target": "dimension"
    },
    {
      "source": "fullrank",
      "target": "linearmap"
    },
    {
      "source": "fullrank",
      "target": "columnspace"
    },
    {
      "source": "rank",
      "target": "matrix"
    },
    {
      "source": "rank",
      "target": "dimension"
    },
    {
      "source": "rank",
      "target": "columnspace"
    },
    {
      "source": "rank",
      "target": "linearmap"
    },
    {
      "source": "inverse",
      "target": "matrix"
    },
    {
      "source": "inverse",
      "target": "det"
    },
    {
      "source": "inverse",
      "target": "linreg"
    },
    {
      "source": "inverse",
      "target": "rank"
    },
    {
      "source": "inverse",
      "target": "pseudoinverse"
    },
    {
      "source": "matrix",
      "target": "modelparam"
    },
    {
      "source": "matrix",
      "target": "linreg"
    },
    {
      "source": "matrix",
      "target": "linearmap"
    },
    {
      "source": "matrix",
      "target": "vectorspace"
    },
    {
      "source": "matrix",
      "target": "dataset"
    },
    {
      "source": "matrix",
      "target": "datapoint"
    },
    {
      "source": "matrix",
      "target": "feature"
    },
    {
      "source": "matrix",
      "target": "label"
    },
    {
      "source": "matrix",
      "target": "linmodel"
    },
    {
      "source": "stratification",
      "target": "dataset"
    },
    {
      "source": "stratification",
      "target": "stratum"
    },
    {
      "source": "stratification",
      "target": "ml"
    },
    {
      "source": "stratification",
      "target": "trainset"
    },
    {
      "source": "stratification",
      "target": "valset"
    },
    {
      "source": "stratification",
      "target": "datapoint"
    },
    {
      "source": "stratification",
      "target": "validation"
    },
    {
      "source": "stratification",
      "target": "kfoldcv"
    },
    {
      "source": "stratum",
      "target": "datapoint"
    },
    {
      "source": "stratum",
      "target": "feature"
    },
    {
      "source": "stratum",
      "target": "label"
    },
    {
      "source": "stratum",
      "target": "dataset"
    },
    {
      "source": "stratum",
      "target": "fmi"
    },
    {
      "source": "stratum",
      "target": "stratification"
    },
    {
      "source": "det",
      "target": "matrix"
    },
    {
      "source": "det",
      "target": "function"
    },
    {
      "source": "det",
      "target": "eigenvalue"
    },
    {
      "source": "det",
      "target": "vector"
    },
    {
      "source": "det",
      "target": "inverse"
    },
    {
      "source": "hessian",
      "target": "function"
    },
    {
      "source": "hessian",
      "target": "matrix"
    },
    {
      "source": "hessian",
      "target": "continuous"
    },
    {
      "source": "hessian",
      "target": "neighborhood"
    },
    {
      "source": "hessian",
      "target": "convex"
    },
    {
      "source": "hessian",
      "target": "psd"
    },
    {
      "source": "hessian",
      "target": "smooth"
    },
    {
      "source": "hessian",
      "target": "quadfunc"
    },
    {
      "source": "hessian",
      "target": "differentiable"
    },
    {
      "source": "continuous",
      "target": "function"
    },
    {
      "source": "continuous",
      "target": "metric"
    },
    {
      "source": "continuous",
      "target": "euclidspace"
    },
    {
      "source": "linearmap",
      "target": "map"
    },
    {
      "source": "linearmap",
      "target": "function"
    },
    {
      "source": "linearmap",
      "target": "vector"
    },
    {
      "source": "linearmap",
      "target": "matrix"
    },
    {
      "source": "linearmap",
      "target": "linmodel"
    },
    {
      "source": "linearmap",
      "target": "ml"
    },
    {
      "source": "vector",
      "target": "vectorspace"
    },
    {
      "source": "vector",
      "target": "ml"
    },
    {
      "source": "vector",
      "target": "euclidspace"
    },
    {
      "source": "vector",
      "target": "function"
    },
    {
      "source": "vector",
      "target": "kernelmethod"
    },
    {
      "source": "vector",
      "target": "map"
    },
    {
      "source": "vector",
      "target": "linearmap"
    },
    {
      "source": "vectorspace",
      "target": "vector"
    },
    {
      "source": "vectorspace",
      "target": "euclidspace"
    },
    {
      "source": "vectorspace",
      "target": "ml"
    },
    {
      "source": "vectorspace",
      "target": "dataset"
    },
    {
      "source": "vectorspace",
      "target": "hypospace"
    },
    {
      "source": "vectorspace",
      "target": "probspace"
    },
    {
      "source": "vectorspace",
      "target": "rv"
    },
    {
      "source": "vectorspace",
      "target": "linmodel"
    },
    {
      "source": "vectorspace",
      "target": "linearmap"
    },
    {
      "source": "stochastic",
      "target": "ml"
    },
    {
      "source": "stochastic",
      "target": "stochGD"
    },
    {
      "source": "stochastic",
      "target": "uncertainty"
    },
    {
      "source": "stochastic",
      "target": "probmodel"
    },
    {
      "source": "stochproc",
      "target": "stochastic"
    },
    {
      "source": "stochproc",
      "target": "rv"
    },
    {
      "source": "stochproc",
      "target": "probspace"
    },
    {
      "source": "stochproc",
      "target": "graph"
    },
    {
      "source": "stochproc",
      "target": "ergraph"
    },
    {
      "source": "stochproc",
      "target": "sbm"
    },
    {
      "source": "stochproc",
      "target": "stochalgorithm"
    },
    {
      "source": "stochproc",
      "target": "stochGD"
    },
    {
      "source": "stochproc",
      "target": "uncertainty"
    },
    {
      "source": "stochproc",
      "target": "probmodel"
    },
    {
      "source": "characteristicfunc",
      "target": "function"
    },
    {
      "source": "characteristicfunc",
      "target": "rv"
    },
    {
      "source": "characteristicfunc",
      "target": "probdist"
    },
    {
      "source": "entropy",
      "target": "uncertainty"
    },
    {
      "source": "entropy",
      "target": "rv"
    },
    {
      "source": "entropy",
      "target": "probability"
    },
    {
      "source": "entropy",
      "target": "function"
    },
    {
      "source": "entropy",
      "target": "generalization"
    },
    {
      "source": "entropy",
      "target": "diffentropy"
    },
    {
      "source": "entropy",
      "target": "probmodel"
    },
    {
      "source": "diffentropy",
      "target": "rv"
    },
    {
      "source": "diffentropy",
      "target": "pdf"
    },
    {
      "source": "diffentropy",
      "target": "entropy"
    },
    {
      "source": "diffentropy",
      "target": "mean"
    },
    {
      "source": "diffentropy",
      "target": "covmtx"
    },
    {
      "source": "diffentropy",
      "target": "uncertainty"
    },
    {
      "source": "diffentropy",
      "target": "probmodel"
    },
    {
      "source": "co-domain",
      "target": "function"
    },
    {
      "source": "co-domain",
      "target": "domain"
    },
    {
      "source": "co-domain",
      "target": "map"
    },
    {
      "source": "domain",
      "target": "function"
    },
    {
      "source": "domain",
      "target": "co-domain"
    },
    {
      "source": "domain",
      "target": "map"
    },
    {
      "source": "map",
      "target": "function"
    },
    {
      "source": "attention",
      "target": "ml"
    },
    {
      "source": "attention",
      "target": "datapoint"
    },
    {
      "source": "attention",
      "target": "token"
    },
    {
      "source": "attention",
      "target": "probmodel"
    },
    {
      "source": "attention",
      "target": "function"
    },
    {
      "source": "attention",
      "target": "parameter"
    },
    {
      "source": "attention",
      "target": "erm"
    },
    {
      "source": "attention",
      "target": "model"
    },
    {
      "source": "attention",
      "target": "vector"
    },
    {
      "source": "attention",
      "target": "nlp"
    },
    {
      "source": "transformer",
      "target": "ml"
    },
    {
      "source": "transformer",
      "target": "ann"
    },
    {
      "source": "transformer",
      "target": "attention"
    },
    {
      "source": "transformer",
      "target": "token"
    },
    {
      "source": "transformer",
      "target": "model"
    },
    {
      "source": "transformer",
      "target": "data"
    },
    {
      "source": "transformer",
      "target": "rnn"
    },
    {
      "source": "transformer",
      "target": "layer"
    },
    {
      "source": "transformer",
      "target": "nlp"
    },
    {
      "source": "rnn",
      "target": "ann"
    },
    {
      "source": "rnn",
      "target": "data"
    },
    {
      "source": "rnn",
      "target": "token"
    },
    {
      "source": "rnn",
      "target": "gdmethod"
    },
    {
      "source": "llm",
      "target": "ml"
    },
    {
      "source": "llm",
      "target": "model"
    },
    {
      "source": "llm",
      "target": "modelparam"
    },
    {
      "source": "llm",
      "target": "data"
    },
    {
      "source": "llm",
      "target": "token"
    },
    {
      "source": "llm",
      "target": "transformer"
    },
    {
      "source": "llm",
      "target": "labeled datapoint"
    },
    {
      "source": "llm",
      "target": "label"
    },
    {
      "source": "llm",
      "target": "feature"
    },
    {
      "source": "llm",
      "target": "datapoint"
    },
    {
      "source": "llm",
      "target": "trainset"
    },
    {
      "source": "llm",
      "target": "nlp"
    },
    {
      "source": "selfsupervisedlearning",
      "target": "feature"
    },
    {
      "source": "selfsupervisedlearning",
      "target": "datapoint"
    },
    {
      "source": "selfsupervisedlearning",
      "target": "label"
    },
    {
      "source": "selfsupervisedlearning",
      "target": "nlp"
    },
    {
      "source": "selfsupervisedlearning",
      "target": "llm"
    },
    {
      "source": "selfsupervisedlearning",
      "target": "data"
    },
    {
      "source": "optproblem",
      "target": "objfunc"
    },
    {
      "source": "optmethod",
      "target": "algorithm"
    },
    {
      "source": "optmethod",
      "target": "optproblem"
    },
    {
      "source": "convexopt",
      "target": "convex"
    },
    {
      "source": "convexopt",
      "target": "optproblem"
    },
    {
      "source": "convexopt",
      "target": "euclidspace"
    },
    {
      "source": "convexopt",
      "target": "objfunc"
    },
    {
      "source": "convexopt",
      "target": "function"
    },
    {
      "source": "convexopt",
      "target": "epigraph"
    },
    {
      "source": "convexopt",
      "target": "optmethod"
    },
    {
      "source": "newtonmethod",
      "target": "optmethod"
    },
    {
      "source": "newtonmethod",
      "target": "minimum"
    },
    {
      "source": "newtonmethod",
      "target": "maximum"
    },
    {
      "source": "newtonmethod",
      "target": "differentiable"
    },
    {
      "source": "newtonmethod",
      "target": "objfunc"
    },
    {
      "source": "newtonmethod",
      "target": "gdmethod"
    },
    {
      "source": "newtonmethod",
      "target": "gradient"
    },
    {
      "source": "newtonmethod",
      "target": "hessian"
    },
    {
      "source": "newtonmethod",
      "target": "matrix"
    },
    {
      "source": "newtonmethod",
      "target": "quadfunc"
    },
    {
      "source": "newtonmethod",
      "target": "function"
    },
    {
      "source": "newtonmethod",
      "target": "convergence"
    },
    {
      "source": "newtonmethod",
      "target": "gd"
    },
    {
      "source": "newtonmethod",
      "target": "lossfunc"
    },
    {
      "source": "hilbertspace",
      "target": "vectorspace"
    },
    {
      "source": "hilbertspace",
      "target": "cauchysequence"
    },
    {
      "source": "hilbertspace",
      "target": "euclidspace"
    },
    {
      "source": "cauchysequence",
      "target": "sequence"
    },
    {
      "source": "cauchysequence",
      "target": "metricspace"
    },
    {
      "source": "cauchysequence",
      "target": "fixedpointiter"
    },
    {
      "source": "nonexpansiveop",
      "target": "fixedpointiter"
    },
    {
      "source": "nonexpansiveop",
      "target": "contractop"
    },
    {
      "source": "fixedpointiter",
      "target": "optproblem"
    },
    {
      "source": "fixedpointiter",
      "target": "sequence"
    },
    {
      "source": "fixedpointiter",
      "target": "differentiable"
    },
    {
      "source": "fixedpointiter",
      "target": "convex"
    },
    {
      "source": "fixedpointiter",
      "target": "function"
    },
    {
      "source": "fixedpointiter",
      "target": "operator"
    },
    {
      "source": "fixedpointiter",
      "target": "nonexpansiveop"
    },
    {
      "source": "fixedpointiter",
      "target": "modelparam"
    },
    {
      "source": "fixedpointiter",
      "target": "contractop"
    },
    {
      "source": "fixedpointiter",
      "target": "proxop"
    },
    {
      "source": "ergraph",
      "target": "graph"
    },
    {
      "source": "ergraph",
      "target": "probmodel"
    },
    {
      "source": "ergraph",
      "target": "iid"
    },
    {
      "source": "ergraph",
      "target": "rv"
    },
    {
      "source": "ergraph",
      "target": "realization"
    },
    {
      "source": "ergraph",
      "target": "probability"
    },
    {
      "source": "attack",
      "target": "ml"
    },
    {
      "source": "attack",
      "target": "dataset"
    },
    {
      "source": "attack",
      "target": "datapoisoning"
    },
    {
      "source": "attack",
      "target": "device"
    },
    {
      "source": "attack",
      "target": "privattack"
    },
    {
      "source": "attack",
      "target": "sensattr"
    },
    {
      "source": "attack",
      "target": "dosattack"
    },
    {
      "source": "attack",
      "target": "backdoor"
    },
    {
      "source": "privattack",
      "target": "attack"
    },
    {
      "source": "privattack",
      "target": "ml"
    },
    {
      "source": "privattack",
      "target": "sensattr"
    },
    {
      "source": "privattack",
      "target": "model"
    },
    {
      "source": "privattack",
      "target": "modelinversion"
    },
    {
      "source": "privattack",
      "target": "trustAI"
    },
    {
      "source": "privattack",
      "target": "gdpr"
    },
    {
      "source": "epigraph",
      "target": "function"
    },
    {
      "source": "epigraph",
      "target": "graph"
    },
    {
      "source": "epigraph",
      "target": "convex"
    },
    {
      "source": "nullspace",
      "target": "matrix"
    },
    {
      "source": "nullspace",
      "target": "vector"
    },
    {
      "source": "nullspace",
      "target": "featlearn"
    },
    {
      "source": "nullspace",
      "target": "featurevec"
    },
    {
      "source": "nullspace",
      "target": "datapoint"
    },
    {
      "source": "nullspace",
      "target": "featurespace"
    },
    {
      "source": "nullspace",
      "target": "prediction"
    },
    {
      "source": "nullspace",
      "target": "model"
    },
    {
      "source": "nullspace",
      "target": "classifier"
    },
    {
      "source": "nullspace",
      "target": "featuremap"
    },
    {
      "source": "maximum",
      "target": "supremum"
    },
    {
      "source": "discrepancy",
      "target": "fl"
    },
    {
      "source": "discrepancy",
      "target": "netdata"
    },
    {
      "source": "discrepancy",
      "target": "empgraph"
    },
    {
      "source": "discrepancy",
      "target": "hypothesis"
    },
    {
      "source": "discrepancy",
      "target": "map"
    },
    {
      "source": "discrepancy",
      "target": "localmodel"
    },
    {
      "source": "FedRelax",
      "target": "fl"
    },
    {
      "source": "FedRelax",
      "target": "distributedalgorithm"
    },
    {
      "source": "fedavg",
      "target": "fl"
    },
    {
      "source": "fedavg",
      "target": "algorithm"
    },
    {
      "source": "fedavg",
      "target": "localmodel"
    },
    {
      "source": "fedavg",
      "target": "modelparam"
    },
    {
      "source": "fedavg",
      "target": "stochGD"
    },
    {
      "source": "FedGD",
      "target": "fl"
    },
    {
      "source": "FedGD",
      "target": "distributedalgorithm"
    },
    {
      "source": "FedGD",
      "target": "empgraph"
    },
    {
      "source": "FedGD",
      "target": "gradstep"
    },
    {
      "source": "FedGD",
      "target": "gdmethod"
    },
    {
      "source": "FedSGD",
      "target": "fl"
    },
    {
      "source": "FedSGD",
      "target": "distributedalgorithm"
    },
    {
      "source": "FedSGD",
      "target": "empgraph"
    },
    {
      "source": "FedSGD",
      "target": "gradstep"
    },
    {
      "source": "FedSGD",
      "target": "gdmethod"
    },
    {
      "source": "FedSGD",
      "target": "stochGD"
    },
    {
      "source": "hfl",
      "target": "localdataset"
    },
    {
      "source": "hfl",
      "target": "datapoint"
    },
    {
      "source": "hfl",
      "target": "feature"
    },
    {
      "source": "hfl",
      "target": "ssl"
    },
    {
      "source": "hfl",
      "target": "fl"
    },
    {
      "source": "hfl",
      "target": "vfl"
    },
    {
      "source": "dimred",
      "target": "feature"
    },
    {
      "source": "dimred",
      "target": "risk"
    },
    {
      "source": "dimred",
      "target": "overfitting"
    },
    {
      "source": "dimred",
      "target": "effdim"
    },
    {
      "source": "dimred",
      "target": "model"
    },
    {
      "source": "dimred",
      "target": "ml"
    },
    {
      "source": "dimred",
      "target": "linreg"
    },
    {
      "source": "dimred",
      "target": "matrix"
    },
    {
      "source": "dimred",
      "target": "data"
    },
    {
      "source": "dimred",
      "target": "scatterplot"
    },
    {
      "source": "dimred",
      "target": "datapoint"
    },
    {
      "source": "dimred",
      "target": "pca"
    },
    {
      "source": "dimred",
      "target": "johnsonlindenstrausslemma"
    },
    {
      "source": "diagnosis",
      "target": "erm"
    },
    {
      "source": "diagnosis",
      "target": "model"
    },
    {
      "source": "diagnosis",
      "target": "hypothesis"
    },
    {
      "source": "diagnosis",
      "target": "trainerr"
    },
    {
      "source": "diagnosis",
      "target": "valerr"
    },
    {
      "source": "diagnosis",
      "target": "trainset"
    },
    {
      "source": "diagnosis",
      "target": "valset"
    },
    {
      "source": "diagnosis",
      "target": "baseline"
    },
    {
      "source": "diagnosis",
      "target": "bayesrisk"
    },
    {
      "source": "diagnosis",
      "target": "ml"
    },
    {
      "source": "diagnosis",
      "target": "validation"
    },
    {
      "source": "diagnosis",
      "target": "kfoldcv"
    },
    {
      "source": "diagnosis",
      "target": "generalization"
    },
    {
      "source": "ml",
      "target": "label"
    },
    {
      "source": "ml",
      "target": "feature"
    },
    {
      "source": "ml",
      "target": "datapoint"
    },
    {
      "source": "ml",
      "target": "hypothesis"
    },
    {
      "source": "ml",
      "target": "hypospace"
    },
    {
      "source": "ml",
      "target": "model"
    },
    {
      "source": "ml",
      "target": "lossfunc"
    },
    {
      "source": "ml",
      "target": "erm"
    },
    {
      "source": "ml",
      "target": "data"
    },
    {
      "source": "ml",
      "target": "loss"
    },
    {
      "source": "reinforcementlearning",
      "target": "onlinelearning"
    },
    {
      "source": "reinforcementlearning",
      "target": "hypothesis"
    },
    {
      "source": "reinforcementlearning",
      "target": "modelparam"
    },
    {
      "source": "reinforcementlearning",
      "target": "featurevec"
    },
    {
      "source": "reinforcementlearning",
      "target": "datapoint"
    },
    {
      "source": "reinforcementlearning",
      "target": "prediction"
    },
    {
      "source": "reinforcementlearning",
      "target": "reward"
    },
    {
      "source": "reinforcementlearning",
      "target": "lossfunc"
    },
    {
      "source": "reinforcementlearning",
      "target": "ml"
    },
    {
      "source": "featlearn",
      "target": "ml"
    },
    {
      "source": "featlearn",
      "target": "datapoint"
    },
    {
      "source": "featlearn",
      "target": "feature"
    },
    {
      "source": "featlearn",
      "target": "map"
    },
    {
      "source": "featlearn",
      "target": "featurespace"
    },
    {
      "source": "featlearn",
      "target": "hypospace"
    },
    {
      "source": "featlearn",
      "target": "pca"
    },
    {
      "source": "featlearn",
      "target": "minimum"
    },
    {
      "source": "featlearn",
      "target": "dataset"
    },
    {
      "source": "autoencoder",
      "target": "ml"
    },
    {
      "source": "autoencoder",
      "target": "map"
    },
    {
      "source": "autoencoder",
      "target": "model"
    },
    {
      "source": "autoencoder",
      "target": "ann"
    },
    {
      "source": "autoencoder",
      "target": "linmodel"
    },
    {
      "source": "autoencoder",
      "target": "pca"
    },
    {
      "source": "autoencoder",
      "target": "erm"
    },
    {
      "source": "autoencoder",
      "target": "loss"
    },
    {
      "source": "autoencoder",
      "target": "featurevec"
    },
    {
      "source": "autoencoder",
      "target": "featlearn"
    },
    {
      "source": "autoencoder",
      "target": "dimred"
    },
    {
      "source": "vfl",
      "target": "fl"
    },
    {
      "source": "vfl",
      "target": "device"
    },
    {
      "source": "vfl",
      "target": "feature"
    },
    {
      "source": "vfl",
      "target": "datapoint"
    },
    {
      "source": "vfl",
      "target": "dataset"
    },
    {
      "source": "vfl",
      "target": "featurevec"
    },
    {
      "source": "vfl",
      "target": "localdataset"
    },
    {
      "source": "vfl",
      "target": "label"
    },
    {
      "source": "vfl",
      "target": "data"
    },
    {
      "source": "vfl",
      "target": "privprot"
    },
    {
      "source": "interpretability",
      "target": "ml"
    },
    {
      "source": "interpretability",
      "target": "model"
    },
    {
      "source": "interpretability",
      "target": "prediction"
    },
    {
      "source": "interpretability",
      "target": "testset"
    },
    {
      "source": "interpretability",
      "target": "hypothesis"
    },
    {
      "source": "interpretability",
      "target": "linearmap"
    },
    {
      "source": "interpretability",
      "target": "expectation"
    },
    {
      "source": "interpretability",
      "target": "trainset"
    },
    {
      "source": "interpretability",
      "target": "label"
    },
    {
      "source": "interpretability",
      "target": "explainability"
    },
    {
      "source": "interpretability",
      "target": "explanation"
    },
    {
      "source": "interpretability",
      "target": "map"
    },
    {
      "source": "interpretability",
      "target": "trustAI"
    },
    {
      "source": "interpretability",
      "target": "regularization"
    },
    {
      "source": "interpretability",
      "target": "lime"
    },
    {
      "source": "multitask learning",
      "target": "learningtask"
    },
    {
      "source": "multitask learning",
      "target": "dataset"
    },
    {
      "source": "multitask learning",
      "target": "deepnet"
    },
    {
      "source": "multitask learning",
      "target": "weights"
    },
    {
      "source": "multitask learning",
      "target": "layer"
    },
    {
      "source": "learningtask",
      "target": "dataset"
    },
    {
      "source": "learningtask",
      "target": "datapoint"
    },
    {
      "source": "learningtask",
      "target": "feature"
    },
    {
      "source": "learningtask",
      "target": "label"
    },
    {
      "source": "learningtask",
      "target": "model"
    },
    {
      "source": "learningtask",
      "target": "lossfunc"
    },
    {
      "source": "learningtask",
      "target": "erm"
    },
    {
      "source": "learningtask",
      "target": "objfunc"
    },
    {
      "source": "learningtask",
      "target": "regression"
    },
    {
      "source": "learningtask",
      "target": "classification"
    },
    {
      "source": "learningtask",
      "target": "probmodel"
    },
    {
      "source": "learningtask",
      "target": "multitask learning"
    },
    {
      "source": "learningtask",
      "target": "labelspace"
    },
    {
      "source": "explainability",
      "target": "ml"
    },
    {
      "source": "explainability",
      "target": "prediction"
    },
    {
      "source": "explainability",
      "target": "model"
    },
    {
      "source": "explainability",
      "target": "testset"
    },
    {
      "source": "explainability",
      "target": "probmodel"
    },
    {
      "source": "explainability",
      "target": "data"
    },
    {
      "source": "explainability",
      "target": "entropy"
    },
    {
      "source": "explainability",
      "target": "trustAI"
    },
    {
      "source": "explainability",
      "target": "regularization"
    },
    {
      "source": "lime",
      "target": "model"
    },
    {
      "source": "lime",
      "target": "hypothesis"
    },
    {
      "source": "lime",
      "target": "featurevec"
    },
    {
      "source": "lime",
      "target": "datapoint"
    },
    {
      "source": "lime",
      "target": "prediction"
    },
    {
      "source": "lime",
      "target": "explanation"
    },
    {
      "source": "lime",
      "target": "erm"
    },
    {
      "source": "lime",
      "target": "trainset"
    },
    {
      "source": "lime",
      "target": "label"
    },
    {
      "source": "lime",
      "target": "decisiontree"
    },
    {
      "source": "lime",
      "target": "deepnet"
    },
    {
      "source": "lime",
      "target": "linmodel"
    },
    {
      "source": "linmodel",
      "target": "ml"
    },
    {
      "source": "linmodel",
      "target": "datapoint"
    },
    {
      "source": "linmodel",
      "target": "featurevec"
    },
    {
      "source": "linmodel",
      "target": "model"
    },
    {
      "source": "linmodel",
      "target": "hypospace"
    },
    {
      "source": "linmodel",
      "target": "linearmap"
    },
    {
      "source": "linmodel",
      "target": "feature"
    },
    {
      "source": "linmodel",
      "target": "prediction"
    },
    {
      "source": "linmodel",
      "target": "compasp"
    },
    {
      "source": "linmodel",
      "target": "statasp"
    },
    {
      "source": "linmodel",
      "target": "bias"
    },
    {
      "source": "linmodel",
      "target": "risk"
    },
    {
      "source": "linmodel",
      "target": "interpretability"
    },
    {
      "source": "linmodel",
      "target": "convex"
    },
    {
      "source": "linmodel",
      "target": "optmethod"
    },
    {
      "source": "linmodel",
      "target": "minimum"
    },
    {
      "source": "linmodel",
      "target": "ann"
    },
    {
      "source": "linmodel",
      "target": "deepnet"
    },
    {
      "source": "linmodel",
      "target": "featuremap"
    },
    {
      "source": "linmodel",
      "target": "layer"
    },
    {
      "source": "linmodel",
      "target": "decisiontree"
    },
    {
      "source": "linmodel",
      "target": "decisionregion"
    },
    {
      "source": "linmodel",
      "target": "differentiable"
    },
    {
      "source": "linmodel",
      "target": "gradient"
    },
    {
      "source": "linmodel",
      "target": "robustness"
    },
    {
      "source": "linmodel",
      "target": "trustAI"
    },
    {
      "source": "linmodel",
      "target": "map"
    },
    {
      "source": "linmodel",
      "target": "lime"
    },
    {
      "source": "gradstep",
      "target": "differentiable"
    },
    {
      "source": "gradstep",
      "target": "function"
    },
    {
      "source": "gradstep",
      "target": "vector"
    },
    {
      "source": "gradstep",
      "target": "gradient"
    },
    {
      "source": "gradstep",
      "target": "stepsize"
    },
    {
      "source": "gradstep",
      "target": "neighborhood"
    },
    {
      "source": "gradstep",
      "target": "generalization"
    },
    {
      "source": "gradstep",
      "target": "parameter"
    },
    {
      "source": "gradstep",
      "target": "learnrate"
    },
    {
      "source": "gradstep",
      "target": "convex"
    },
    {
      "source": "gradstep",
      "target": "proxop"
    },
    {
      "source": "operator",
      "target": "function"
    },
    {
      "source": "operator",
      "target": "domain"
    },
    {
      "source": "operator",
      "target": "co-domain"
    },
    {
      "source": "operator",
      "target": "vectorspace"
    },
    {
      "source": "operator",
      "target": "hilbertspace"
    },
    {
      "source": "operator",
      "target": "metricspace"
    },
    {
      "source": "operator",
      "target": "ml"
    },
    {
      "source": "operator",
      "target": "euclidspace"
    },
    {
      "source": "proxop",
      "target": "convex"
    },
    {
      "source": "proxop",
      "target": "function"
    },
    {
      "source": "proxop",
      "target": "vector"
    },
    {
      "source": "proxop",
      "target": "generalization"
    },
    {
      "source": "proxop",
      "target": "gradstep"
    },
    {
      "source": "proxop",
      "target": "smooth"
    },
    {
      "source": "proxop",
      "target": "stepsize"
    },
    {
      "source": "proximable",
      "target": "convex"
    },
    {
      "source": "proximable",
      "target": "function"
    },
    {
      "source": "proximable",
      "target": "proxop"
    },
    {
      "source": "connected",
      "target": "undirectedgraph"
    },
    {
      "source": "connected",
      "target": "algconn"
    },
    {
      "source": "mvndist",
      "target": "probmodel"
    },
    {
      "source": "mvndist",
      "target": "featurevec"
    },
    {
      "source": "mvndist",
      "target": "probdist"
    },
    {
      "source": "mvndist",
      "target": "vector"
    },
    {
      "source": "mvndist",
      "target": "rv"
    },
    {
      "source": "mvndist",
      "target": "mean"
    },
    {
      "source": "mvndist",
      "target": "covmtx"
    },
    {
      "source": "mvndist",
      "target": "pdf"
    },
    {
      "source": "mvndist",
      "target": "stdnormvec"
    },
    {
      "source": "mvndist",
      "target": "diffentropy"
    },
    {
      "source": "mvndist",
      "target": "gaussrv"
    },
    {
      "source": "stdnormvec",
      "target": "vector"
    },
    {
      "source": "stdnormvec",
      "target": "iid"
    },
    {
      "source": "stdnormvec",
      "target": "gaussrv"
    },
    {
      "source": "stdnormvec",
      "target": "mvndist"
    },
    {
      "source": "stdnormvec",
      "target": "rv"
    },
    {
      "source": "earlystopping",
      "target": "erm"
    },
    {
      "source": "earlystopping",
      "target": "optmethod"
    },
    {
      "source": "earlystopping",
      "target": "gd"
    },
    {
      "source": "earlystopping",
      "target": "modelparam"
    },
    {
      "source": "earlystopping",
      "target": "emprisk"
    },
    {
      "source": "earlystopping",
      "target": "trainset"
    },
    {
      "source": "earlystopping",
      "target": "objfunc"
    },
    {
      "source": "earlystopping",
      "target": "valerr"
    },
    {
      "source": "earlystopping",
      "target": "regularization"
    },
    {
      "source": "earlystopping",
      "target": "model"
    },
    {
      "source": "earlystopping",
      "target": "gdmethod"
    },
    {
      "source": "earlystopping",
      "target": "hypospace"
    },
    {
      "source": "earlystopping",
      "target": "sequence"
    },
    {
      "source": "earlystopping",
      "target": "gradstep"
    },
    {
      "source": "earlystopping",
      "target": "overfitting"
    },
    {
      "source": "statasp",
      "target": "ml"
    },
    {
      "source": "statasp",
      "target": "probdist"
    },
    {
      "source": "statasp",
      "target": "probmodel"
    },
    {
      "source": "statasp",
      "target": "data"
    },
    {
      "source": "compasp",
      "target": "ml"
    },
    {
      "source": "compasp",
      "target": "erm"
    },
    {
      "source": "compasp",
      "target": "gradstep"
    },
    {
      "source": "compasp",
      "target": "modelparam"
    },
    {
      "source": "compasp",
      "target": "gd"
    },
    {
      "source": "zerooneloss",
      "target": "loss"
    },
    {
      "source": "zerooneloss",
      "target": "classifier"
    },
    {
      "source": "zerooneloss",
      "target": "prediction"
    },
    {
      "source": "zerooneloss",
      "target": "label"
    },
    {
      "source": "zerooneloss",
      "target": "datapoint"
    },
    {
      "source": "zerooneloss",
      "target": "feature"
    },
    {
      "source": "zerooneloss",
      "target": "acc"
    },
    {
      "source": "probability",
      "target": "event"
    },
    {
      "source": "probability",
      "target": "randomexperiment"
    },
    {
      "source": "underfitting",
      "target": "ml"
    },
    {
      "source": "underfitting",
      "target": "erm"
    },
    {
      "source": "underfitting",
      "target": "hypothesis"
    },
    {
      "source": "underfitting",
      "target": "emprisk"
    },
    {
      "source": "underfitting",
      "target": "trainset"
    },
    {
      "source": "underfitting",
      "target": "model"
    },
    {
      "source": "underfitting",
      "target": "feature"
    },
    {
      "source": "underfitting",
      "target": "label"
    },
    {
      "source": "underfitting",
      "target": "linmodel"
    },
    {
      "source": "underfitting",
      "target": "data"
    },
    {
      "source": "underfitting",
      "target": "loss"
    },
    {
      "source": "underfitting",
      "target": "risk"
    },
    {
      "source": "underfitting",
      "target": "overfitting"
    },
    {
      "source": "overfitting",
      "target": "ml"
    },
    {
      "source": "overfitting",
      "target": "erm"
    },
    {
      "source": "overfitting",
      "target": "hypothesis"
    },
    {
      "source": "overfitting",
      "target": "minimum"
    },
    {
      "source": "overfitting",
      "target": "emprisk"
    },
    {
      "source": "overfitting",
      "target": "trainset"
    },
    {
      "source": "overfitting",
      "target": "loss"
    },
    {
      "source": "overfitting",
      "target": "gengap"
    },
    {
      "source": "overfitting",
      "target": "generalization"
    },
    {
      "source": "overfitting",
      "target": "validation"
    },
    {
      "source": "gdpr",
      "target": "data"
    },
    {
      "source": "gdpr",
      "target": "ml"
    },
    {
      "source": "gdpr",
      "target": "dataminprinc"
    },
    {
      "source": "gdpr",
      "target": "transparency"
    },
    {
      "source": "gdpr",
      "target": "explainability"
    },
    {
      "source": "normaldist",
      "target": "gaussrv"
    },
    {
      "source": "gaussrv",
      "target": "rv"
    },
    {
      "source": "gaussrv",
      "target": "pdf"
    },
    {
      "source": "gaussrv",
      "target": "gaussian"
    },
    {
      "source": "gaussrv",
      "target": "mean"
    },
    {
      "source": "gaussrv",
      "target": "variance"
    },
    {
      "source": "gaussrv",
      "target": "probdist"
    },
    {
      "source": "gaussrv",
      "target": "normaldist"
    },
    {
      "source": "gaussrv",
      "target": "vector"
    },
    {
      "source": "gaussrv",
      "target": "covmtx"
    },
    {
      "source": "gaussrv",
      "target": "iid"
    },
    {
      "source": "gaussrv",
      "target": "matrix"
    },
    {
      "source": "gaussrv",
      "target": "mvndist"
    },
    {
      "source": "gaussrv",
      "target": "stochproc"
    },
    {
      "source": "gaussrv",
      "target": "GaussProc"
    },
    {
      "source": "gaussrv",
      "target": "probmodel"
    },
    {
      "source": "gaussrv",
      "target": "ml"
    },
    {
      "source": "gaussrv",
      "target": "clt"
    },
    {
      "source": "gaussrv",
      "target": "maximum"
    },
    {
      "source": "gaussrv",
      "target": "uncertainty"
    },
    {
      "source": "gaussrv",
      "target": "diffentropy"
    },
    {
      "source": "gaussian",
      "target": "gaussrv"
    },
    {
      "source": "clt",
      "target": "iid"
    },
    {
      "source": "clt",
      "target": "rv"
    },
    {
      "source": "clt",
      "target": "mean"
    },
    {
      "source": "clt",
      "target": "variance"
    },
    {
      "source": "clt",
      "target": "gaussrv"
    },
    {
      "source": "clt",
      "target": "characteristicfunc"
    },
    {
      "source": "clt",
      "target": "fixedpointiter"
    },
    {
      "source": "clt",
      "target": "convergence"
    },
    {
      "source": "clt",
      "target": "generalization"
    },
    {
      "source": "GaussProc",
      "target": "rv"
    },
    {
      "source": "GaussProc",
      "target": "mvndist"
    },
    {
      "source": "GaussProc",
      "target": "mean"
    },
    {
      "source": "GaussProc",
      "target": "function"
    },
    {
      "source": "GaussProc",
      "target": "covariance"
    },
    {
      "source": "GaussProc",
      "target": "realization"
    },
    {
      "source": "GaussProc",
      "target": "fmi"
    },
    {
      "source": "GaussProc",
      "target": "uncertainty"
    },
    {
      "source": "GaussProc",
      "target": "prediction"
    },
    {
      "source": "GaussProc",
      "target": "gaussrv"
    },
    {
      "source": "trustAI",
      "target": "compasp"
    },
    {
      "source": "trustAI",
      "target": "statasp"
    },
    {
      "source": "trustAI",
      "target": "ml"
    },
    {
      "source": "trustAI",
      "target": "ai"
    },
    {
      "source": "trustAI",
      "target": "robustness"
    },
    {
      "source": "trustAI",
      "target": "data"
    },
    {
      "source": "trustAI",
      "target": "transparency"
    },
    {
      "source": "sqerrloss",
      "target": "loss"
    },
    {
      "source": "sqerrloss",
      "target": "prediction"
    },
    {
      "source": "sqerrloss",
      "target": "hypothesis"
    },
    {
      "source": "sqerrloss",
      "target": "label"
    },
    {
      "source": "sqerrloss",
      "target": "feature"
    },
    {
      "source": "sqerrloss",
      "target": "datapoint"
    },
    {
      "source": "projection",
      "target": "euclidspace"
    },
    {
      "source": "projection",
      "target": "vector"
    },
    {
      "source": "projection",
      "target": "minimum"
    },
    {
      "source": "projgd",
      "target": "erm"
    },
    {
      "source": "projgd",
      "target": "model"
    },
    {
      "source": "projgd",
      "target": "paramspace"
    },
    {
      "source": "projgd",
      "target": "objfunc"
    },
    {
      "source": "projgd",
      "target": "smooth"
    },
    {
      "source": "projgd",
      "target": "gd"
    },
    {
      "source": "projgd",
      "target": "modelparam"
    },
    {
      "source": "projgd",
      "target": "gradstep"
    },
    {
      "source": "projgd",
      "target": "projection"
    },
    {
      "source": "diffpriv",
      "target": "ml"
    },
    {
      "source": "diffpriv",
      "target": "dataset"
    },
    {
      "source": "diffpriv",
      "target": "trainset"
    },
    {
      "source": "diffpriv",
      "target": "erm"
    },
    {
      "source": "diffpriv",
      "target": "modelparam"
    },
    {
      "source": "diffpriv",
      "target": "prediction"
    },
    {
      "source": "diffpriv",
      "target": "datapoint"
    },
    {
      "source": "diffpriv",
      "target": "privleakage"
    },
    {
      "source": "diffpriv",
      "target": "probdist"
    },
    {
      "source": "diffpriv",
      "target": "sensattr"
    },
    {
      "source": "diffpriv",
      "target": "probmodel"
    },
    {
      "source": "diffpriv",
      "target": "realization"
    },
    {
      "source": "diffpriv",
      "target": "rv"
    },
    {
      "source": "diffpriv",
      "target": "privattack"
    },
    {
      "source": "diffpriv",
      "target": "privfunnel"
    },
    {
      "source": "robustness",
      "target": "trustAI"
    },
    {
      "source": "robustness",
      "target": "ml"
    },
    {
      "source": "robustness",
      "target": "feature"
    },
    {
      "source": "robustness",
      "target": "datapoint"
    },
    {
      "source": "robustness",
      "target": "prediction"
    },
    {
      "source": "robustness",
      "target": "model"
    },
    {
      "source": "robustness",
      "target": "stability"
    },
    {
      "source": "robustness",
      "target": "erm"
    },
    {
      "source": "robustness",
      "target": "trainset"
    },
    {
      "source": "robustness",
      "target": "datapoisoning"
    },
    {
      "source": "robustness",
      "target": "attack"
    },
    {
      "source": "stability",
      "target": "ml"
    },
    {
      "source": "stability",
      "target": "dataset"
    },
    {
      "source": "stability",
      "target": "erm"
    },
    {
      "source": "stability",
      "target": "trainset"
    },
    {
      "source": "stability",
      "target": "modelparam"
    },
    {
      "source": "stability",
      "target": "loss"
    },
    {
      "source": "stability",
      "target": "prediction"
    },
    {
      "source": "stability",
      "target": "model"
    },
    {
      "source": "stability",
      "target": "generalization"
    },
    {
      "source": "stability",
      "target": "gengap"
    },
    {
      "source": "stability",
      "target": "data"
    },
    {
      "source": "stability",
      "target": "probdist"
    },
    {
      "source": "stability",
      "target": "sample"
    },
    {
      "source": "stability",
      "target": "realization"
    },
    {
      "source": "stability",
      "target": "robustness"
    },
    {
      "source": "privprot",
      "target": "ml"
    },
    {
      "source": "privprot",
      "target": "dataset"
    },
    {
      "source": "privprot",
      "target": "modelparam"
    },
    {
      "source": "privprot",
      "target": "prediction"
    },
    {
      "source": "privprot",
      "target": "datapoint"
    },
    {
      "source": "privprot",
      "target": "feature"
    },
    {
      "source": "privprot",
      "target": "label"
    },
    {
      "source": "privprot",
      "target": "sensattr"
    },
    {
      "source": "privprot",
      "target": "map"
    },
    {
      "source": "privleakage",
      "target": "ml"
    },
    {
      "source": "privleakage",
      "target": "dataset"
    },
    {
      "source": "privleakage",
      "target": "prediction"
    },
    {
      "source": "privleakage",
      "target": "datapoint"
    },
    {
      "source": "privleakage",
      "target": "feature"
    },
    {
      "source": "privleakage",
      "target": "probmodel"
    },
    {
      "source": "privleakage",
      "target": "data"
    },
    {
      "source": "privleakage",
      "target": "mutualinformation"
    },
    {
      "source": "privleakage",
      "target": "diffpriv"
    },
    {
      "source": "privleakage",
      "target": "privattack"
    },
    {
      "source": "privleakage",
      "target": "gdpr"
    },
    {
      "source": "probmodel",
      "target": "model"
    },
    {
      "source": "probmodel",
      "target": "datapoint"
    },
    {
      "source": "probmodel",
      "target": "rv"
    },
    {
      "source": "probmodel",
      "target": "probdist"
    },
    {
      "source": "probmodel",
      "target": "parameter"
    },
    {
      "source": "probmodel",
      "target": "maxlikelihood"
    },
    {
      "source": "probmodel",
      "target": "realization"
    },
    {
      "source": "mean",
      "target": "rv"
    },
    {
      "source": "mean",
      "target": "euclidspace"
    },
    {
      "source": "mean",
      "target": "expectation"
    },
    {
      "source": "mean",
      "target": "probdist"
    },
    {
      "source": "mean",
      "target": "dataset"
    },
    {
      "source": "mean",
      "target": "samplespace"
    },
    {
      "source": "mean",
      "target": "risk"
    },
    {
      "source": "mean",
      "target": "optproblem"
    },
    {
      "source": "mean",
      "target": "erm"
    },
    {
      "source": "mean",
      "target": "sqerrloss"
    },
    {
      "source": "median",
      "target": "rv"
    },
    {
      "source": "median",
      "target": "probability"
    },
    {
      "source": "median",
      "target": "dataset"
    },
    {
      "source": "median",
      "target": "samplespace"
    },
    {
      "source": "median",
      "target": "optproblem"
    },
    {
      "source": "median",
      "target": "erm"
    },
    {
      "source": "median",
      "target": "abserr"
    },
    {
      "source": "median",
      "target": "mean"
    },
    {
      "source": "median",
      "target": "parameter"
    },
    {
      "source": "median",
      "target": "probmodel"
    },
    {
      "source": "median",
      "target": "outlier"
    },
    {
      "source": "median",
      "target": "datapoint"
    },
    {
      "source": "median",
      "target": "robustness"
    },
    {
      "source": "median",
      "target": "ladregression"
    },
    {
      "source": "variance",
      "target": "rv"
    },
    {
      "source": "variance",
      "target": "expectation"
    },
    {
      "source": "variance",
      "target": "vector"
    },
    {
      "source": "nn",
      "target": "hypothesis"
    },
    {
      "source": "nn",
      "target": "function"
    },
    {
      "source": "nn",
      "target": "dataset"
    },
    {
      "source": "nn",
      "target": "metric"
    },
    {
      "source": "nn",
      "target": "datapoint"
    },
    {
      "source": "nn",
      "target": "featurevec"
    },
    {
      "source": "nn",
      "target": "neighbor"
    },
    {
      "source": "neighborhood",
      "target": "metric"
    },
    {
      "source": "neighborhood",
      "target": "graph"
    },
    {
      "source": "neighborhood",
      "target": "neighbor"
    },
    {
      "source": "neighbor",
      "target": "graph"
    },
    {
      "source": "bias",
      "target": "erm"
    },
    {
      "source": "bias",
      "target": "ml"
    },
    {
      "source": "bias",
      "target": "hypothesis"
    },
    {
      "source": "bias",
      "target": "trainset"
    },
    {
      "source": "bias",
      "target": "probmodel"
    },
    {
      "source": "bias",
      "target": "iidasspt"
    },
    {
      "source": "bias",
      "target": "data"
    },
    {
      "source": "bias",
      "target": "datapoint"
    },
    {
      "source": "bias",
      "target": "realization"
    },
    {
      "source": "bias",
      "target": "rv"
    },
    {
      "source": "bias",
      "target": "modelparam"
    },
    {
      "source": "bias",
      "target": "parammodel"
    },
    {
      "source": "bias",
      "target": "prediction"
    },
    {
      "source": "bias",
      "target": "featurevec"
    },
    {
      "source": "bias",
      "target": "label"
    },
    {
      "source": "bias",
      "target": "iid"
    },
    {
      "source": "bias",
      "target": "esterr"
    },
    {
      "source": "classification",
      "target": "label"
    },
    {
      "source": "classification",
      "target": "datapoint"
    },
    {
      "source": "classification",
      "target": "feature"
    },
    {
      "source": "privfunnel",
      "target": "featuremap"
    },
    {
      "source": "privfunnel",
      "target": "feature"
    },
    {
      "source": "privfunnel",
      "target": "datapoint"
    },
    {
      "source": "privfunnel",
      "target": "gdpr"
    },
    {
      "source": "privfunnel",
      "target": "diffpriv"
    },
    {
      "source": "condnr",
      "target": "matrix"
    },
    {
      "source": "condnr",
      "target": "eigenvalue"
    },
    {
      "source": "condnr",
      "target": "ml"
    },
    {
      "source": "condnr",
      "target": "gdmethod"
    },
    {
      "source": "condnr",
      "target": "linreg"
    },
    {
      "source": "condnr",
      "target": "featuremtx"
    },
    {
      "source": "condnr",
      "target": "trainset"
    },
    {
      "source": "condnr",
      "target": "feature"
    },
    {
      "source": "condnr",
      "target": "datapoint"
    },
    {
      "source": "classifier",
      "target": "hypothesis"
    },
    {
      "source": "classifier",
      "target": "map"
    },
    {
      "source": "classifier",
      "target": "label"
    },
    {
      "source": "classifier",
      "target": "labelspace"
    },
    {
      "source": "classifier",
      "target": "function"
    },
    {
      "source": "classifier",
      "target": "prediction"
    },
    {
      "source": "classifier",
      "target": "classification"
    },
    {
      "source": "classifier",
      "target": "decisionregion"
    },
    {
      "source": "emprisk",
      "target": "risk"
    },
    {
      "source": "emprisk",
      "target": "hypothesis"
    },
    {
      "source": "emprisk",
      "target": "dataset"
    },
    {
      "source": "emprisk",
      "target": "loss"
    },
    {
      "source": "emprisk",
      "target": "datapoint"
    },
    {
      "source": "nodedegree",
      "target": "graph"
    },
    {
      "source": "nodedegree",
      "target": "neighbor"
    },
    {
      "source": "token",
      "target": "nlp"
    },
    {
      "source": "token",
      "target": "feature"
    },
    {
      "source": "token",
      "target": "datapoint"
    },
    {
      "source": "token",
      "target": "featurevec"
    },
    {
      "source": "nlp",
      "target": "ml"
    },
    {
      "source": "nlp",
      "target": "classification"
    },
    {
      "source": "nlp",
      "target": "token"
    },
    {
      "source": "nlp",
      "target": "model"
    },
    {
      "source": "nlp",
      "target": "attention"
    },
    {
      "source": "directedcyble",
      "target": "directedgraph"
    },
    {
      "source": "directedcyble",
      "target": "dag"
    },
    {
      "source": "dag",
      "target": "directedgraph"
    },
    {
      "source": "dag",
      "target": "ml"
    },
    {
      "source": "dag",
      "target": "model"
    },
    {
      "source": "dag",
      "target": "ann"
    },
    {
      "source": "dag",
      "target": "decisiontree"
    },
    {
      "source": "directedgraph",
      "target": "graph"
    },
    {
      "source": "undirectedgraph",
      "target": "graph"
    },
    {
      "source": "simplefunction",
      "target": "function"
    },
    {
      "source": "simplefunction",
      "target": "measurable"
    },
    {
      "source": "simplefunction",
      "target": "LebesgueIntegral"
    },
    {
      "source": "measurespace",
      "target": "sigmaalgebra"
    },
    {
      "source": "measurespace",
      "target": "measurable"
    },
    {
      "source": "measurespace",
      "target": "euclidspace"
    },
    {
      "source": "measurespace",
      "target": "LebesgueIntegral"
    },
    {
      "source": "measurespace",
      "target": "rv"
    },
    {
      "source": "measurespace",
      "target": "probspace"
    },
    {
      "source": "measurespace",
      "target": "probdist"
    },
    {
      "source": "integrable",
      "target": "measurable"
    },
    {
      "source": "integrable",
      "target": "function"
    },
    {
      "source": "integrable",
      "target": "measurespace"
    },
    {
      "source": "integrable",
      "target": "LebesgueIntegral"
    },
    {
      "source": "integrable",
      "target": "rv"
    },
    {
      "source": "integrable",
      "target": "samplespace"
    },
    {
      "source": "integrable",
      "target": "probspace"
    },
    {
      "source": "integrable",
      "target": "expectation"
    },
    {
      "source": "integrable",
      "target": "measure"
    },
    {
      "source": "measure",
      "target": "sigmaalgebra"
    },
    {
      "source": "measure",
      "target": "function"
    },
    {
      "source": "measure",
      "target": "measurable"
    },
    {
      "source": "measure",
      "target": "countable"
    },
    {
      "source": "LebesgueIntegral",
      "target": "function"
    },
    {
      "source": "LebesgueIntegral",
      "target": "simplefunction"
    },
    {
      "source": "LebesgueIntegral",
      "target": "domain"
    },
    {
      "source": "cdf",
      "target": "rv"
    },
    {
      "source": "cdf",
      "target": "pdf"
    },
    {
      "source": "cdf",
      "target": "probdist"
    },
    {
      "source": "weightedgraph",
      "target": "graph"
    },
    {
      "source": "graph",
      "target": "map"
    },
    {
      "source": "graph",
      "target": "weights"
    },
    {
      "source": "uncertainty",
      "target": "ml"
    },
    {
      "source": "uncertainty",
      "target": "explanation"
    },
    {
      "source": "uncertainty",
      "target": "data"
    },
    {
      "source": "uncertainty",
      "target": "prediction"
    },
    {
      "source": "uncertainty",
      "target": "model"
    },
    {
      "source": "uncertainty",
      "target": "label"
    },
    {
      "source": "uncertainty",
      "target": "datapoint"
    },
    {
      "source": "uncertainty",
      "target": "probability"
    },
    {
      "source": "uncertainty",
      "target": "probmodel"
    },
    {
      "source": "uncertainty",
      "target": "risk"
    },
    {
      "source": "uncertainty",
      "target": "entropy"
    },
    {
      "source": "uncertainty",
      "target": "variance"
    },
    {
      "source": "ucb",
      "target": "ml"
    },
    {
      "source": "ucb",
      "target": "reward"
    },
    {
      "source": "ucb",
      "target": "probmodel"
    },
    {
      "source": "ucb",
      "target": "stochastic"
    },
    {
      "source": "ucb",
      "target": "mab"
    },
    {
      "source": "ucb",
      "target": "model"
    },
    {
      "source": "ucb",
      "target": "realization"
    },
    {
      "source": "ucb",
      "target": "rv"
    },
    {
      "source": "ucb",
      "target": "mean"
    },
    {
      "source": "ucb",
      "target": "data"
    },
    {
      "source": "ucb",
      "target": "uncertainty"
    },
    {
      "source": "ucb",
      "target": "regret"
    },
    {
      "source": "ucb",
      "target": "optimism in the face of uncertainty"
    },
    {
      "source": "mab",
      "target": "uncertainty"
    },
    {
      "source": "mab",
      "target": "reward"
    },
    {
      "source": "mab",
      "target": "probdist"
    },
    {
      "source": "mab",
      "target": "ml"
    },
    {
      "source": "mab",
      "target": "reinforcementlearning"
    },
    {
      "source": "mab",
      "target": "regret"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "ml"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "modelparam"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "erm"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "loss"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "dataset"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "trainset"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "risk"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "hypothesis"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "probmodel"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "probability"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "objfunc"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "srm"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "ucb"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "optmethod"
    },
    {
      "source": "optimism in the face of uncertainty",
      "target": "gdmethod"
    },
    {
      "source": "empgraph",
      "target": "fl"
    },
    {
      "source": "empgraph",
      "target": "graph"
    },
    {
      "source": "empgraph",
      "target": "device"
    },
    {
      "source": "empgraph",
      "target": "localdataset"
    },
    {
      "source": "empgraph",
      "target": "localmodel"
    },
    {
      "source": "empgraph",
      "target": "gtvmin"
    },
    {
      "source": "empgraph",
      "target": "modelparam"
    },
    {
      "source": "empgraph",
      "target": "loss"
    },
    {
      "source": "empgraph",
      "target": "discrepancy"
    },
    {
      "source": "norm",
      "target": "function"
    },
    {
      "source": "norm",
      "target": "vector"
    },
    {
      "source": "norm",
      "target": "vectorspace"
    },
    {
      "source": "dualnorm",
      "target": "norm"
    },
    {
      "source": "dualnorm",
      "target": "euclidspace"
    },
    {
      "source": "dualnorm",
      "target": "vector"
    },
    {
      "source": "geometricmedian",
      "target": "vector"
    },
    {
      "source": "geometricmedian",
      "target": "subgradient"
    },
    {
      "source": "explanation",
      "target": "transparency"
    },
    {
      "source": "explanation",
      "target": "ml"
    },
    {
      "source": "explanation",
      "target": "prediction"
    },
    {
      "source": "explanation",
      "target": "feature"
    },
    {
      "source": "explanation",
      "target": "datapoint"
    },
    {
      "source": "explanation",
      "target": "map"
    },
    {
      "source": "explanation",
      "target": "model"
    },
    {
      "source": "explanation",
      "target": "featurevec"
    },
    {
      "source": "explanation",
      "target": "lime"
    },
    {
      "source": "explanation",
      "target": "differentiable"
    },
    {
      "source": "explanation",
      "target": "gradient"
    },
    {
      "source": "explanation",
      "target": "function"
    },
    {
      "source": "explanation",
      "target": "classification"
    },
    {
      "source": "risk",
      "target": "hypothesis"
    },
    {
      "source": "risk",
      "target": "label"
    },
    {
      "source": "risk",
      "target": "datapoint"
    },
    {
      "source": "risk",
      "target": "feature"
    },
    {
      "source": "risk",
      "target": "prediction"
    },
    {
      "source": "risk",
      "target": "lossfunc"
    },
    {
      "source": "risk",
      "target": "realization"
    },
    {
      "source": "risk",
      "target": "iid"
    },
    {
      "source": "risk",
      "target": "rv"
    },
    {
      "source": "risk",
      "target": "iidasspt"
    },
    {
      "source": "risk",
      "target": "loss"
    },
    {
      "source": "risk",
      "target": "probdist"
    },
    {
      "source": "actfun",
      "target": "ann"
    },
    {
      "source": "actfun",
      "target": "activation"
    },
    {
      "source": "actfun",
      "target": "function"
    },
    {
      "source": "actfun",
      "target": "weights"
    },
    {
      "source": "actfun",
      "target": "relu"
    },
    {
      "source": "distributedalgorithm",
      "target": "algorithm"
    },
    {
      "source": "distributedalgorithm",
      "target": "device"
    },
    {
      "source": "distributedalgorithm",
      "target": "event"
    },
    {
      "source": "distributedalgorithm",
      "target": "fl"
    },
    {
      "source": "distributedalgorithm",
      "target": "model"
    },
    {
      "source": "algorithm",
      "target": "gdmethod"
    },
    {
      "source": "algorithm",
      "target": "linreg"
    },
    {
      "source": "algorithm",
      "target": "trainset"
    },
    {
      "source": "algorithm",
      "target": "modelparam"
    },
    {
      "source": "algorithm",
      "target": "gradstep"
    },
    {
      "source": "algorithm",
      "target": "inverse"
    },
    {
      "source": "algorithm",
      "target": "matrix"
    },
    {
      "source": "algorithm",
      "target": "normalequations"
    },
    {
      "source": "algorithm",
      "target": "linmodel"
    },
    {
      "source": "algorithm",
      "target": "model"
    },
    {
      "source": "algorithm",
      "target": "stochastic"
    },
    {
      "source": "stochalgorithm",
      "target": "stochastic"
    },
    {
      "source": "stochalgorithm",
      "target": "algorithm"
    },
    {
      "source": "stochalgorithm",
      "target": "stochGD"
    },
    {
      "source": "stochalgorithm",
      "target": "datapoint"
    },
    {
      "source": "stochalgorithm",
      "target": "gradient"
    },
    {
      "source": "stochalgorithm",
      "target": "objfunc"
    },
    {
      "source": "stochalgorithm",
      "target": "stochproc"
    },
    {
      "source": "stochalgorithm",
      "target": "randomexperiment"
    },
    {
      "source": "stochalgorithm",
      "target": "optmethod"
    },
    {
      "source": "stochalgorithm",
      "target": "gdmethod"
    },
    {
      "source": "batchlearning",
      "target": "batch"
    },
    {
      "source": "batchlearning",
      "target": "ml"
    },
    {
      "source": "batchlearning",
      "target": "model"
    },
    {
      "source": "batchlearning",
      "target": "dataset"
    },
    {
      "source": "batchlearning",
      "target": "data"
    },
    {
      "source": "batchlearning",
      "target": "algorithm"
    },
    {
      "source": "batchlearning",
      "target": "prediction"
    },
    {
      "source": "batchlearning",
      "target": "onlinelearning"
    },
    {
      "source": "onlinelearning",
      "target": "ml"
    },
    {
      "source": "onlinelearning",
      "target": "data"
    },
    {
      "source": "onlinelearning",
      "target": "modelparam"
    },
    {
      "source": "onlinelearning",
      "target": "datapoint"
    },
    {
      "source": "onlinelearning",
      "target": "minimum"
    },
    {
      "source": "onlinelearning",
      "target": "maximum"
    },
    {
      "source": "onlinelearning",
      "target": "fmi"
    },
    {
      "source": "onlinelearning",
      "target": "hypothesis"
    },
    {
      "source": "onlinelearning",
      "target": "onlineGD"
    },
    {
      "source": "onlinelearning",
      "target": "onlinealgorithm"
    },
    {
      "source": "onlinealgorithm",
      "target": "algorithm"
    },
    {
      "source": "onlinealgorithm",
      "target": "data"
    },
    {
      "source": "onlinealgorithm",
      "target": "datapoint"
    },
    {
      "source": "onlinealgorithm",
      "target": "uncertainty"
    },
    {
      "source": "onlinealgorithm",
      "target": "ml"
    },
    {
      "source": "onlinealgorithm",
      "target": "onlineGD"
    },
    {
      "source": "onlinealgorithm",
      "target": "modelparam"
    },
    {
      "source": "onlinealgorithm",
      "target": "onlinelearning"
    },
    {
      "source": "transparency",
      "target": "trustAI"
    },
    {
      "source": "transparency",
      "target": "ml"
    },
    {
      "source": "transparency",
      "target": "explainability"
    },
    {
      "source": "transparency",
      "target": "ai"
    },
    {
      "source": "transparency",
      "target": "prediction"
    },
    {
      "source": "transparency",
      "target": "model"
    },
    {
      "source": "transparency",
      "target": "logreg"
    },
    {
      "source": "transparency",
      "target": "classification"
    },
    {
      "source": "transparency",
      "target": "decisiontree"
    },
    {
      "source": "sensattr",
      "target": "ml"
    },
    {
      "source": "sensattr",
      "target": "hypothesis"
    },
    {
      "source": "sensattr",
      "target": "map"
    },
    {
      "source": "sensattr",
      "target": "label"
    },
    {
      "source": "sensattr",
      "target": "datapoint"
    },
    {
      "source": "sensattr",
      "target": "feature"
    },
    {
      "source": "sbm",
      "target": "model"
    },
    {
      "source": "sbm",
      "target": "graph"
    },
    {
      "source": "sbm",
      "target": "cluster"
    },
    {
      "source": "sbm",
      "target": "probability"
    },
    {
      "source": "sbm",
      "target": "label"
    },
    {
      "source": "deepnet",
      "target": "ann"
    },
    {
      "source": "deepnet",
      "target": "layer"
    },
    {
      "source": "deepnet",
      "target": "ml"
    },
    {
      "source": "deepnet",
      "target": "model"
    },
    {
      "source": "baseline",
      "target": "ml"
    },
    {
      "source": "baseline",
      "target": "hypothesis"
    },
    {
      "source": "baseline",
      "target": "model"
    },
    {
      "source": "baseline",
      "target": "loss"
    },
    {
      "source": "baseline",
      "target": "testset"
    },
    {
      "source": "baseline",
      "target": "data"
    },
    {
      "source": "baseline",
      "target": "probmodel"
    },
    {
      "source": "baseline",
      "target": "minimum"
    },
    {
      "source": "baseline",
      "target": "risk"
    },
    {
      "source": "baseline",
      "target": "hypospace"
    },
    {
      "source": "baseline",
      "target": "bayesrisk"
    },
    {
      "source": "baseline",
      "target": "bayesestimator"
    },
    {
      "source": "baseline",
      "target": "label"
    },
    {
      "source": "baseline",
      "target": "datapoint"
    },
    {
      "source": "baseline",
      "target": "feature"
    },
    {
      "source": "baseline",
      "target": "lossfunc"
    },
    {
      "source": "baseline",
      "target": "probdist"
    },
    {
      "source": "baseline",
      "target": "mvndist"
    },
    {
      "source": "baseline",
      "target": "sqerrloss"
    },
    {
      "source": "baseline",
      "target": "mean"
    },
    {
      "source": "baseline",
      "target": "variance"
    },
    {
      "source": "kfoldcv",
      "target": "validation"
    },
    {
      "source": "kfoldcv",
      "target": "gengap"
    },
    {
      "source": "kfoldcv",
      "target": "erm"
    },
    {
      "source": "kfoldcv",
      "target": "ml"
    },
    {
      "source": "kfoldcv",
      "target": "dataset"
    },
    {
      "source": "kfoldcv",
      "target": "valset"
    },
    {
      "source": "kfoldcv",
      "target": "trainset"
    },
    {
      "source": "kfoldcv",
      "target": "model"
    },
    {
      "source": "kfoldcv",
      "target": "valerr"
    },
    {
      "source": "spectrogram",
      "target": "classification"
    },
    {
      "source": "spectrogram",
      "target": "deepnet"
    },
    {
      "source": "graphclustering",
      "target": "graph"
    },
    {
      "source": "graphclustering",
      "target": "clustering"
    },
    {
      "source": "graphclustering",
      "target": "datapoint"
    },
    {
      "source": "graphclustering",
      "target": "edgeweight"
    },
    {
      "source": "specclustering",
      "target": "clustering"
    },
    {
      "source": "specclustering",
      "target": "graphclustering"
    },
    {
      "source": "specclustering",
      "target": "datapoint"
    },
    {
      "source": "specclustering",
      "target": "graph"
    },
    {
      "source": "specclustering",
      "target": "eigenvector"
    },
    {
      "source": "specclustering",
      "target": "LapMat"
    },
    {
      "source": "specclustering",
      "target": "featurevec"
    },
    {
      "source": "specclustering",
      "target": "euclidspace"
    },
    {
      "source": "specclustering",
      "target": "kmeans"
    },
    {
      "source": "specclustering",
      "target": "softclustering"
    },
    {
      "source": "specclustering",
      "target": "gmm"
    },
    {
      "source": "specclustering",
      "target": "cluster"
    },
    {
      "source": "specclustering",
      "target": "evd"
    },
    {
      "source": "specclustering",
      "target": "scatterplot"
    },
    {
      "source": "specclustering",
      "target": "eigenvalue"
    },
    {
      "source": "flowbasedclustering",
      "target": "clustering"
    },
    {
      "source": "flowbasedclustering",
      "target": "graph"
    },
    {
      "source": "flowbasedclustering",
      "target": "kmeans"
    },
    {
      "source": "flowbasedclustering",
      "target": "featurevec"
    },
    {
      "source": "esterr",
      "target": "datapoint"
    },
    {
      "source": "esterr",
      "target": "featurevec"
    },
    {
      "source": "esterr",
      "target": "label"
    },
    {
      "source": "esterr",
      "target": "hypothesis"
    },
    {
      "source": "esterr",
      "target": "ml"
    },
    {
      "source": "esterr",
      "target": "erm"
    },
    {
      "source": "esterr",
      "target": "hypospace"
    },
    {
      "source": "esterr",
      "target": "map"
    },
    {
      "source": "esterr",
      "target": "modelparam"
    },
    {
      "source": "dob",
      "target": "datapoint"
    },
    {
      "source": "dob",
      "target": "cluster"
    },
    {
      "source": "dob",
      "target": "softclustering"
    },
    {
      "source": "dob",
      "target": "hardclustering"
    },
    {
      "source": "msee",
      "target": "ml"
    },
    {
      "source": "msee",
      "target": "modelparam"
    },
    {
      "source": "msee",
      "target": "dataset"
    },
    {
      "source": "msee",
      "target": "datapoint"
    },
    {
      "source": "msee",
      "target": "iid"
    },
    {
      "source": "msee",
      "target": "realization"
    },
    {
      "source": "msee",
      "target": "rv"
    },
    {
      "source": "msee",
      "target": "esterr"
    },
    {
      "source": "msee",
      "target": "probdist"
    },
    {
      "source": "msee",
      "target": "expectation"
    },
    {
      "source": "msee",
      "target": "norm"
    },
    {
      "source": "msee",
      "target": "probmodel"
    },
    {
      "source": "msee",
      "target": "sqerrloss"
    },
    {
      "source": "gtvmin",
      "target": "rerm"
    },
    {
      "source": "gtvmin",
      "target": "gtv"
    },
    {
      "source": "gtvmin",
      "target": "modelparam"
    },
    {
      "source": "gtvmin",
      "target": "regularizer"
    },
    {
      "source": "regression",
      "target": "prediction"
    },
    {
      "source": "regression",
      "target": "label"
    },
    {
      "source": "regression",
      "target": "feature"
    },
    {
      "source": "regression",
      "target": "datapoint"
    },
    {
      "source": "acc",
      "target": "datapoint"
    },
    {
      "source": "acc",
      "target": "feature"
    },
    {
      "source": "acc",
      "target": "label"
    },
    {
      "source": "acc",
      "target": "labelspace"
    },
    {
      "source": "acc",
      "target": "hypothesis"
    },
    {
      "source": "acc",
      "target": "dataset"
    },
    {
      "source": "acc",
      "target": "zerooneloss"
    },
    {
      "source": "acc",
      "target": "loss"
    },
    {
      "source": "acc",
      "target": "metric"
    },
    {
      "source": "expert",
      "target": "ml"
    },
    {
      "source": "expert",
      "target": "hypothesis"
    },
    {
      "source": "expert",
      "target": "label"
    },
    {
      "source": "expert",
      "target": "datapoint"
    },
    {
      "source": "expert",
      "target": "feature"
    },
    {
      "source": "expert",
      "target": "prediction"
    },
    {
      "source": "expert",
      "target": "lossfunc"
    },
    {
      "source": "expert",
      "target": "loss"
    },
    {
      "source": "expert",
      "target": "iidasspt"
    },
    {
      "source": "expert",
      "target": "bayesrisk"
    },
    {
      "source": "expert",
      "target": "baseline"
    },
    {
      "source": "expert",
      "target": "regret"
    },
    {
      "source": "nfl",
      "target": "model"
    },
    {
      "source": "nfl",
      "target": "localdataset"
    },
    {
      "source": "nfl",
      "target": "fl"
    },
    {
      "source": "regret",
      "target": "hypothesis"
    },
    {
      "source": "regret",
      "target": "baseline"
    },
    {
      "source": "regret",
      "target": "loss"
    },
    {
      "source": "regret",
      "target": "expert"
    },
    {
      "source": "strcvx",
      "target": "differentiable"
    },
    {
      "source": "strcvx",
      "target": "function"
    },
    {
      "source": "strcvx",
      "target": "convex"
    },
    {
      "source": "differentiable",
      "target": "function"
    },
    {
      "source": "differentiable",
      "target": "gradient"
    },
    {
      "source": "gradient",
      "target": "function"
    },
    {
      "source": "gradient",
      "target": "vector"
    },
    {
      "source": "subgradient",
      "target": "function"
    },
    {
      "source": "subgradient",
      "target": "vector"
    },
    {
      "source": "fedprox",
      "target": "fl"
    },
    {
      "source": "fedprox",
      "target": "algorithm"
    },
    {
      "source": "fedprox",
      "target": "localmodel"
    },
    {
      "source": "fedprox",
      "target": "modelparam"
    },
    {
      "source": "fedprox",
      "target": "fedavg"
    },
    {
      "source": "fedprox",
      "target": "stochGD"
    },
    {
      "source": "fedprox",
      "target": "proxop"
    },
    {
      "source": "relu",
      "target": "actfun"
    },
    {
      "source": "relu",
      "target": "ann"
    },
    {
      "source": "hypothesis",
      "target": "map"
    },
    {
      "source": "hypothesis",
      "target": "function"
    },
    {
      "source": "hypothesis",
      "target": "featurespace"
    },
    {
      "source": "hypothesis",
      "target": "labelspace"
    },
    {
      "source": "hypothesis",
      "target": "datapoint"
    },
    {
      "source": "hypothesis",
      "target": "feature"
    },
    {
      "source": "hypothesis",
      "target": "label"
    },
    {
      "source": "hypothesis",
      "target": "prediction"
    },
    {
      "source": "hypothesis",
      "target": "ml"
    },
    {
      "source": "hypothesis",
      "target": "hypospace"
    },
    {
      "source": "hypothesis",
      "target": "model"
    },
    {
      "source": "effdim",
      "target": "hypospace"
    },
    {
      "source": "effdim",
      "target": "modelparam"
    },
    {
      "source": "effdim",
      "target": "parameter"
    },
    {
      "source": "effdim",
      "target": "linearmap"
    },
    {
      "source": "effdim",
      "target": "weights"
    },
    {
      "source": "effdim",
      "target": "bias"
    },
    {
      "source": "effdim",
      "target": "ann"
    },
    {
      "source": "labelspace",
      "target": "ml"
    },
    {
      "source": "labelspace",
      "target": "datapoint"
    },
    {
      "source": "labelspace",
      "target": "feature"
    },
    {
      "source": "labelspace",
      "target": "label"
    },
    {
      "source": "labelspace",
      "target": "regression"
    },
    {
      "source": "labelspace",
      "target": "classification"
    },
    {
      "source": "prediction",
      "target": "ml"
    },
    {
      "source": "prediction",
      "target": "hypothesis"
    },
    {
      "source": "prediction",
      "target": "map"
    },
    {
      "source": "prediction",
      "target": "feature"
    },
    {
      "source": "prediction",
      "target": "datapoint"
    },
    {
      "source": "prediction",
      "target": "label"
    },
    {
      "source": "empiricaldistribution",
      "target": "dataset"
    },
    {
      "source": "empiricaldistribution",
      "target": "datapoint"
    },
    {
      "source": "empiricaldistribution",
      "target": "featurevec"
    },
    {
      "source": "empiricaldistribution",
      "target": "sigmaalgebra"
    },
    {
      "source": "empiricaldistribution",
      "target": "featurespace"
    },
    {
      "source": "empiricaldistribution",
      "target": "probdist"
    },
    {
      "source": "empiricaldistribution",
      "target": "measurable"
    },
    {
      "source": "empiricaldistribution",
      "target": "cdf"
    },
    {
      "source": "empiricaldistribution",
      "target": "pmf"
    },
    {
      "source": "empiricaldistribution",
      "target": "feature"
    },
    {
      "source": "histogram",
      "target": "dataset"
    },
    {
      "source": "histogram",
      "target": "datapoint"
    },
    {
      "source": "histogram",
      "target": "sample"
    },
    {
      "source": "bootstrap",
      "target": "ml"
    },
    {
      "source": "bootstrap",
      "target": "dataset"
    },
    {
      "source": "bootstrap",
      "target": "realization"
    },
    {
      "source": "bootstrap",
      "target": "iid"
    },
    {
      "source": "bootstrap",
      "target": "rv"
    },
    {
      "source": "bootstrap",
      "target": "probdist"
    },
    {
      "source": "bootstrap",
      "target": "empiricaldistribution"
    },
    {
      "source": "bootstrap",
      "target": "datapoint"
    },
    {
      "source": "bootstrap",
      "target": "model"
    },
    {
      "source": "bootstrap",
      "target": "training"
    },
    {
      "source": "bootstrap",
      "target": "erm"
    },
    {
      "source": "bootstrap",
      "target": "hypothesis"
    },
    {
      "source": "bootstrap",
      "target": "bias"
    },
    {
      "source": "bootstrap",
      "target": "variance"
    },
    {
      "source": "bootstrap",
      "target": "gengap"
    },
    {
      "source": "bootstrap",
      "target": "histogram"
    },
    {
      "source": "featurespace",
      "target": "feature"
    },
    {
      "source": "featurespace",
      "target": "ml"
    },
    {
      "source": "featurespace",
      "target": "featurevec"
    },
    {
      "source": "featurespace",
      "target": "datapoint"
    },
    {
      "source": "featurespace",
      "target": "euclidspace"
    },
    {
      "source": "featurespace",
      "target": "featlearn"
    },
    {
      "source": "featurespace",
      "target": "convex"
    },
    {
      "source": "featurespace",
      "target": "graph"
    },
    {
      "source": "missingdata",
      "target": "dataset"
    },
    {
      "source": "missingdata",
      "target": "datapoint"
    },
    {
      "source": "missingdata",
      "target": "device"
    },
    {
      "source": "missingdata",
      "target": "feature"
    },
    {
      "source": "missingdata",
      "target": "label"
    },
    {
      "source": "missingdata",
      "target": "data"
    },
    {
      "source": "missingdata",
      "target": "ml"
    },
    {
      "source": "dataimputation",
      "target": "missingdata"
    },
    {
      "source": "psd",
      "target": "matrix"
    },
    {
      "source": "psd",
      "target": "vector"
    },
    {
      "source": "psd",
      "target": "kernel"
    },
    {
      "source": "psd",
      "target": "map"
    },
    {
      "source": "psd",
      "target": "featurevec"
    },
    {
      "source": "feature",
      "target": "datapoint"
    },
    {
      "source": "featurevec",
      "target": "feature"
    },
    {
      "source": "featurevec",
      "target": "vector"
    },
    {
      "source": "featurevec",
      "target": "ml"
    },
    {
      "source": "featurevec",
      "target": "euclidspace"
    },
    {
      "source": "featurevec",
      "target": "vectorspace"
    },
    {
      "source": "featurevec",
      "target": "kernelmethod"
    },
    {
      "source": "label",
      "target": "datapoint"
    },
    {
      "source": "label",
      "target": "labelspace"
    },
    {
      "source": "data",
      "target": "ml"
    },
    {
      "source": "data",
      "target": "dataset"
    },
    {
      "source": "data",
      "target": "datapoint"
    },
    {
      "source": "data",
      "target": "sample"
    },
    {
      "source": "dataset",
      "target": "datapoint"
    },
    {
      "source": "dataset",
      "target": "ml"
    },
    {
      "source": "dataset",
      "target": "sample"
    },
    {
      "source": "dataset",
      "target": "model"
    },
    {
      "source": "dataset",
      "target": "training"
    },
    {
      "source": "dataset",
      "target": "validation"
    },
    {
      "source": "dataset",
      "target": "data"
    },
    {
      "source": "dataset",
      "target": "feature"
    },
    {
      "source": "dataset",
      "target": "label"
    },
    {
      "source": "dataset",
      "target": "featurespace"
    },
    {
      "source": "dataset",
      "target": "labelspace"
    },
    {
      "source": "dataset",
      "target": "trustAI"
    },
    {
      "source": "predictor",
      "target": "hypothesis"
    },
    {
      "source": "predictor",
      "target": "map"
    },
    {
      "source": "predictor",
      "target": "datapoint"
    },
    {
      "source": "predictor",
      "target": "feature"
    },
    {
      "source": "predictor",
      "target": "prediction"
    },
    {
      "source": "predictor",
      "target": "label"
    },
    {
      "source": "labeled datapoint",
      "target": "datapoint"
    },
    {
      "source": "labeled datapoint",
      "target": "label"
    },
    {
      "source": "discreteRV",
      "target": "rv"
    },
    {
      "source": "discreteRV",
      "target": "function"
    },
    {
      "source": "discreteRV",
      "target": "randomexperiment"
    },
    {
      "source": "discreteRV",
      "target": "measurable"
    },
    {
      "source": "discreteRV",
      "target": "probability"
    },
    {
      "source": "discreteRV",
      "target": "probdist"
    },
    {
      "source": "rv",
      "target": "function"
    },
    {
      "source": "rv",
      "target": "randomexperiment"
    },
    {
      "source": "rv",
      "target": "measurable"
    },
    {
      "source": "rv",
      "target": "samplespace"
    },
    {
      "source": "rv",
      "target": "probspace"
    },
    {
      "source": "rv",
      "target": "vector"
    },
    {
      "source": "rv",
      "target": "euclidspace"
    },
    {
      "source": "rv",
      "target": "probability"
    },
    {
      "source": "probspace",
      "target": "probability"
    },
    {
      "source": "probspace",
      "target": "randomexperiment"
    },
    {
      "source": "probspace",
      "target": "samplespace"
    },
    {
      "source": "probspace",
      "target": "sigmaalgebra"
    },
    {
      "source": "probspace",
      "target": "event"
    },
    {
      "source": "probspace",
      "target": "probdist"
    },
    {
      "source": "probspace",
      "target": "function"
    },
    {
      "source": "probspace",
      "target": "countable"
    },
    {
      "source": "probspace",
      "target": "sequence"
    },
    {
      "source": "probspace",
      "target": "probmodel"
    },
    {
      "source": "probspace",
      "target": "ml"
    },
    {
      "source": "samplespace",
      "target": "sample"
    },
    {
      "source": "samplespace",
      "target": "randomexperiment"
    },
    {
      "source": "samplespace",
      "target": "probspace"
    },
    {
      "source": "realization",
      "target": "rv"
    },
    {
      "source": "realization",
      "target": "probspace"
    },
    {
      "source": "realization",
      "target": "measurable"
    },
    {
      "source": "trainset",
      "target": "dataset"
    },
    {
      "source": "trainset",
      "target": "datapoint"
    },
    {
      "source": "trainset",
      "target": "erm"
    },
    {
      "source": "trainset",
      "target": "hypothesis"
    },
    {
      "source": "trainset",
      "target": "loss"
    },
    {
      "source": "trainset",
      "target": "trainerr"
    },
    {
      "source": "trainset",
      "target": "valerr"
    },
    {
      "source": "trainset",
      "target": "ml"
    },
    {
      "source": "trainset",
      "target": "hypospace"
    },
    {
      "source": "netmodel",
      "target": "model"
    },
    {
      "source": "netmodel",
      "target": "empgraph"
    },
    {
      "source": "netmodel",
      "target": "localmodel"
    },
    {
      "source": "netmodel",
      "target": "hypospace"
    },
    {
      "source": "batch",
      "target": "stochGD"
    },
    {
      "source": "batch",
      "target": "trainset"
    },
    {
      "source": "batch",
      "target": "datapoint"
    },
    {
      "source": "batch",
      "target": "gradient"
    },
    {
      "source": "batch",
      "target": "trainerr"
    },
    {
      "source": "batch",
      "target": "modelparam"
    },
    {
      "source": "epoch",
      "target": "trainset"
    },
    {
      "source": "epoch",
      "target": "algorithm"
    },
    {
      "source": "epoch",
      "target": "model"
    },
    {
      "source": "epoch",
      "target": "datapoint"
    },
    {
      "source": "epoch",
      "target": "parameter"
    },
    {
      "source": "epoch",
      "target": "prediction"
    },
    {
      "source": "epoch",
      "target": "data"
    },
    {
      "source": "epoch",
      "target": "underfitting"
    },
    {
      "source": "epoch",
      "target": "overfitting"
    },
    {
      "source": "netdata",
      "target": "data"
    },
    {
      "source": "netdata",
      "target": "localdataset"
    },
    {
      "source": "netdata",
      "target": "graph"
    },
    {
      "source": "netdata",
      "target": "fl"
    },
    {
      "source": "netdata",
      "target": "device"
    },
    {
      "source": "trainerr",
      "target": "loss"
    },
    {
      "source": "trainerr",
      "target": "hypothesis"
    },
    {
      "source": "trainerr",
      "target": "label"
    },
    {
      "source": "trainerr",
      "target": "datapoint"
    },
    {
      "source": "trainerr",
      "target": "trainset"
    },
    {
      "source": "trainerr",
      "target": "erm"
    },
    {
      "source": "datapoint",
      "target": "data"
    },
    {
      "source": "datapoint",
      "target": "rv"
    },
    {
      "source": "datapoint",
      "target": "feature"
    },
    {
      "source": "datapoint",
      "target": "measurable"
    },
    {
      "source": "datapoint",
      "target": "label"
    },
    {
      "source": "datapoint",
      "target": "ml"
    },
    {
      "source": "datapoint",
      "target": "dataset"
    },
    {
      "source": "valerr",
      "target": "hypothesis"
    },
    {
      "source": "valerr",
      "target": "ml"
    },
    {
      "source": "valerr",
      "target": "erm"
    },
    {
      "source": "valerr",
      "target": "trainset"
    },
    {
      "source": "valerr",
      "target": "loss"
    },
    {
      "source": "valerr",
      "target": "valset"
    },
    {
      "source": "valerr",
      "target": "validation"
    },
    {
      "source": "validation",
      "target": "hypothesis"
    },
    {
      "source": "validation",
      "target": "ml"
    },
    {
      "source": "validation",
      "target": "erm"
    },
    {
      "source": "validation",
      "target": "trainset"
    },
    {
      "source": "validation",
      "target": "valset"
    },
    {
      "source": "validation",
      "target": "datapoint"
    },
    {
      "source": "validation",
      "target": "loss"
    },
    {
      "source": "validation",
      "target": "valerr"
    },
    {
      "source": "validation",
      "target": "overfitting"
    },
    {
      "source": "validation",
      "target": "generalization"
    },
    {
      "source": "quadfunc",
      "target": "function"
    },
    {
      "source": "quadfunc",
      "target": "matrix"
    },
    {
      "source": "quadfunc",
      "target": "vector"
    },
    {
      "source": "valset",
      "target": "datapoint"
    },
    {
      "source": "valset",
      "target": "risk"
    },
    {
      "source": "valset",
      "target": "hypothesis"
    },
    {
      "source": "valset",
      "target": "ml"
    },
    {
      "source": "valset",
      "target": "erm"
    },
    {
      "source": "valset",
      "target": "loss"
    },
    {
      "source": "valset",
      "target": "validation"
    },
    {
      "source": "valset",
      "target": "valerr"
    },
    {
      "source": "valset",
      "target": "trainerr"
    },
    {
      "source": "valset",
      "target": "hypospace"
    },
    {
      "source": "testset",
      "target": "datapoint"
    },
    {
      "source": "testset",
      "target": "model"
    },
    {
      "source": "testset",
      "target": "erm"
    },
    {
      "source": "testset",
      "target": "valset"
    },
    {
      "source": "modelsel",
      "target": "ml"
    },
    {
      "source": "modelsel",
      "target": "model"
    },
    {
      "source": "modelsel",
      "target": "valerr"
    },
    {
      "source": "linclass",
      "target": "datapoint"
    },
    {
      "source": "linclass",
      "target": "feature"
    },
    {
      "source": "linclass",
      "target": "label"
    },
    {
      "source": "linclass",
      "target": "labelspace"
    },
    {
      "source": "linclass",
      "target": "classifier"
    },
    {
      "source": "linclass",
      "target": "decisionregion"
    },
    {
      "source": "erm",
      "target": "optproblem"
    },
    {
      "source": "erm",
      "target": "hypothesis"
    },
    {
      "source": "erm",
      "target": "loss"
    },
    {
      "source": "erm",
      "target": "emprisk"
    },
    {
      "source": "erm",
      "target": "trainset"
    },
    {
      "source": "erm",
      "target": "hypospace"
    },
    {
      "source": "erm",
      "target": "model"
    },
    {
      "source": "erm",
      "target": "dataset"
    },
    {
      "source": "erm",
      "target": "ml"
    },
    {
      "source": "erm",
      "target": "linmodel"
    },
    {
      "source": "erm",
      "target": "datapoint"
    },
    {
      "source": "erm",
      "target": "feature"
    },
    {
      "source": "erm",
      "target": "label"
    },
    {
      "source": "erm",
      "target": "linearmap"
    },
    {
      "source": "erm",
      "target": "function"
    },
    {
      "source": "erm",
      "target": "modelparam"
    },
    {
      "source": "erm",
      "target": "optmethod"
    },
    {
      "source": "sampleweighting",
      "target": "erm"
    },
    {
      "source": "sampleweighting",
      "target": "hypothesis"
    },
    {
      "source": "sampleweighting",
      "target": "loss"
    },
    {
      "source": "sampleweighting",
      "target": "trainset"
    },
    {
      "source": "sampleweighting",
      "target": "datapoint"
    },
    {
      "source": "sampleweighting",
      "target": "prediction"
    },
    {
      "source": "sampleweighting",
      "target": "outlier"
    },
    {
      "source": "sampleweighting",
      "target": "emprisk"
    },
    {
      "source": "sampleweighting",
      "target": "adaboost"
    },
    {
      "source": "multilabelclass",
      "target": "label"
    },
    {
      "source": "multilabelclass",
      "target": "classification"
    },
    {
      "source": "multilabelclass",
      "target": "datapoint"
    },
    {
      "source": "training",
      "target": "ml"
    },
    {
      "source": "training",
      "target": "hypothesis"
    },
    {
      "source": "training",
      "target": "model"
    },
    {
      "source": "training",
      "target": "loss"
    },
    {
      "source": "training",
      "target": "datapoint"
    },
    {
      "source": "training",
      "target": "trainset"
    },
    {
      "source": "training",
      "target": "parammodel"
    },
    {
      "source": "training",
      "target": "modelparam"
    },
    {
      "source": "training",
      "target": "erm"
    },
    {
      "source": "ssl",
      "target": "datapoint"
    },
    {
      "source": "ssl",
      "target": "hypothesis"
    },
    {
      "source": "ssl",
      "target": "labeled datapoint"
    },
    {
      "source": "ssl",
      "target": "ml"
    },
    {
      "source": "objfunc",
      "target": "function"
    },
    {
      "source": "objfunc",
      "target": "map"
    },
    {
      "source": "objfunc",
      "target": "ml"
    },
    {
      "source": "objfunc",
      "target": "modelparam"
    },
    {
      "source": "objfunc",
      "target": "hypothesis"
    },
    {
      "source": "objfunc",
      "target": "risk"
    },
    {
      "source": "objfunc",
      "target": "loss"
    },
    {
      "source": "objfunc",
      "target": "emprisk"
    },
    {
      "source": "objfunc",
      "target": "trainset"
    },
    {
      "source": "objfunc",
      "target": "gdmethod"
    },
    {
      "source": "objfunc",
      "target": "minimum"
    },
    {
      "source": "objfunc",
      "target": "maximum"
    },
    {
      "source": "objfunc",
      "target": "model"
    },
    {
      "source": "objfunc",
      "target": "erm"
    },
    {
      "source": "objfunc",
      "target": "optproblem"
    },
    {
      "source": "regularizer",
      "target": "hypothesis"
    },
    {
      "source": "regularizer",
      "target": "hypospace"
    },
    {
      "source": "regularizer",
      "target": "prediction"
    },
    {
      "source": "regularizer",
      "target": "datapoint"
    },
    {
      "source": "regularizer",
      "target": "trainset"
    },
    {
      "source": "regularizer",
      "target": "ridgeregression"
    },
    {
      "source": "regularizer",
      "target": "map"
    },
    {
      "source": "regularizer",
      "target": "lasso"
    },
    {
      "source": "regularizer",
      "target": "loss"
    },
    {
      "source": "regularizer",
      "target": "objfunc"
    },
    {
      "source": "regularization",
      "target": "ml"
    },
    {
      "source": "regularization",
      "target": "model"
    },
    {
      "source": "regularization",
      "target": "effdim"
    },
    {
      "source": "regularization",
      "target": "erm"
    },
    {
      "source": "regularization",
      "target": "overfitting"
    },
    {
      "source": "regularization",
      "target": "hypothesis"
    },
    {
      "source": "regularization",
      "target": "trainset"
    },
    {
      "source": "regularization",
      "target": "modelparam"
    },
    {
      "source": "regularization",
      "target": "feature"
    },
    {
      "source": "regularization",
      "target": "linreg"
    },
    {
      "source": "regularization",
      "target": "loss"
    },
    {
      "source": "regularization",
      "target": "objfunc"
    },
    {
      "source": "regularization",
      "target": "trainerr"
    },
    {
      "source": "regularization",
      "target": "risk"
    },
    {
      "source": "regularization",
      "target": "dataaug"
    },
    {
      "source": "regularization",
      "target": "datapoint"
    },
    {
      "source": "regularization",
      "target": "realization"
    },
    {
      "source": "regularization",
      "target": "rv"
    },
    {
      "source": "regularization",
      "target": "featurevec"
    },
    {
      "source": "regularization",
      "target": "gaussrv"
    },
    {
      "source": "regularization",
      "target": "ridgeregression"
    },
    {
      "source": "regularization",
      "target": "label"
    },
    {
      "source": "regularization",
      "target": "validation"
    },
    {
      "source": "regularization",
      "target": "lasso"
    },
    {
      "source": "regularization",
      "target": "modelsel"
    },
    {
      "source": "rerm",
      "target": "erm"
    },
    {
      "source": "rerm",
      "target": "hypothesis"
    },
    {
      "source": "rerm",
      "target": "model"
    },
    {
      "source": "rerm",
      "target": "emprisk"
    },
    {
      "source": "rerm",
      "target": "trainset"
    },
    {
      "source": "rerm",
      "target": "overfitting"
    },
    {
      "source": "rerm",
      "target": "regularization"
    },
    {
      "source": "rerm",
      "target": "regularizer"
    },
    {
      "source": "rerm",
      "target": "parameter"
    },
    {
      "source": "rerm",
      "target": "objfunc"
    },
    {
      "source": "rerm",
      "target": "loss"
    },
    {
      "source": "rerm",
      "target": "label"
    },
    {
      "source": "rerm",
      "target": "datapoint"
    },
    {
      "source": "rerm",
      "target": "linmodel"
    },
    {
      "source": "rerm",
      "target": "sqerrloss"
    },
    {
      "source": "rerm",
      "target": "gaussrv"
    },
    {
      "source": "rerm",
      "target": "featurevec"
    },
    {
      "source": "rerm",
      "target": "generalization"
    },
    {
      "source": "rerm",
      "target": "srm"
    },
    {
      "source": "generalization",
      "target": "model"
    },
    {
      "source": "generalization",
      "target": "trainset"
    },
    {
      "source": "generalization",
      "target": "prediction"
    },
    {
      "source": "generalization",
      "target": "datapoint"
    },
    {
      "source": "generalization",
      "target": "ml"
    },
    {
      "source": "generalization",
      "target": "ai"
    },
    {
      "source": "generalization",
      "target": "erm"
    },
    {
      "source": "generalization",
      "target": "hypothesis"
    },
    {
      "source": "generalization",
      "target": "loss"
    },
    {
      "source": "generalization",
      "target": "data"
    },
    {
      "source": "generalization",
      "target": "probmodel"
    },
    {
      "source": "generalization",
      "target": "iidasspt"
    },
    {
      "source": "generalization",
      "target": "rv"
    },
    {
      "source": "generalization",
      "target": "probdist"
    },
    {
      "source": "generalization",
      "target": "risk"
    },
    {
      "source": "generalization",
      "target": "emprisk"
    },
    {
      "source": "generalization",
      "target": "gengap"
    },
    {
      "source": "generalization",
      "target": "probability"
    },
    {
      "source": "generalization",
      "target": "concentrationinequ"
    },
    {
      "source": "generalization",
      "target": "convergence"
    },
    {
      "source": "generalization",
      "target": "feature"
    },
    {
      "source": "generalization",
      "target": "overfitting"
    },
    {
      "source": "generalization",
      "target": "validation"
    },
    {
      "source": "gengap",
      "target": "generalization"
    },
    {
      "source": "gengap",
      "target": "hypothesis"
    },
    {
      "source": "gengap",
      "target": "trainset"
    },
    {
      "source": "gengap",
      "target": "datapoint"
    },
    {
      "source": "gengap",
      "target": "probmodel"
    },
    {
      "source": "gengap",
      "target": "risk"
    },
    {
      "source": "gengap",
      "target": "loss"
    },
    {
      "source": "gengap",
      "target": "emprisk"
    },
    {
      "source": "gengap",
      "target": "probdist"
    },
    {
      "source": "gengap",
      "target": "expectation"
    },
    {
      "source": "gengap",
      "target": "validation"
    },
    {
      "source": "gengap",
      "target": "valset"
    },
    {
      "source": "gengap",
      "target": "erm"
    },
    {
      "source": "gengap",
      "target": "lossfunc"
    },
    {
      "source": "concentrationinequ",
      "target": "probability"
    },
    {
      "source": "concentrationinequ",
      "target": "rv"
    },
    {
      "source": "concentrationinequ",
      "target": "expectation"
    },
    {
      "source": "randomprojection",
      "target": "matrix"
    },
    {
      "source": "randomprojection",
      "target": "featurevec"
    },
    {
      "source": "randomprojection",
      "target": "featlearn"
    },
    {
      "source": "randomprojection",
      "target": "dimred"
    },
    {
      "source": "randomprojection",
      "target": "iid"
    },
    {
      "source": "randomprojection",
      "target": "rv"
    },
    {
      "source": "randomprojection",
      "target": "probdist"
    },
    {
      "source": "randomprojection",
      "target": "projection"
    },
    {
      "source": "randomprojection",
      "target": "eucliddist"
    },
    {
      "source": "randomprojection",
      "target": "dataset"
    },
    {
      "source": "randomprojection",
      "target": "johnsonlindenstrausslemma"
    },
    {
      "source": "randomprojection",
      "target": "map"
    },
    {
      "source": "randomprojection",
      "target": "probability"
    },
    {
      "source": "boosting",
      "target": "optmethod"
    },
    {
      "source": "boosting",
      "target": "hypothesis"
    },
    {
      "source": "boosting",
      "target": "map"
    },
    {
      "source": "boosting",
      "target": "baselearner"
    },
    {
      "source": "boosting",
      "target": "generalization"
    },
    {
      "source": "boosting",
      "target": "gdmethod"
    },
    {
      "source": "boosting",
      "target": "erm"
    },
    {
      "source": "boosting",
      "target": "model"
    },
    {
      "source": "boosting",
      "target": "smooth"
    },
    {
      "source": "boosting",
      "target": "lossfunc"
    },
    {
      "source": "boosting",
      "target": "gradstep"
    },
    {
      "source": "boosting",
      "target": "learnrate"
    },
    {
      "source": "boosting",
      "target": "gradient"
    },
    {
      "source": "boosting",
      "target": "sequence"
    },
    {
      "source": "boosting",
      "target": "ensemble"
    },
    {
      "source": "boosting",
      "target": "adaboost"
    },
    {
      "source": "boosting",
      "target": "gradientboosting"
    },
    {
      "source": "mse",
      "target": "hypothesis"
    },
    {
      "source": "mse",
      "target": "sqerrloss"
    },
    {
      "source": "mse",
      "target": "dataset"
    },
    {
      "source": "mse",
      "target": "risk"
    },
    {
      "source": "mae",
      "target": "hypothesis"
    },
    {
      "source": "mae",
      "target": "abserr"
    },
    {
      "source": "mae",
      "target": "dataset"
    },
    {
      "source": "mae",
      "target": "risk"
    },
    {
      "source": "adaboost",
      "target": "boosting"
    },
    {
      "source": "adaboost",
      "target": "algorithm"
    },
    {
      "source": "adaboost",
      "target": "baselearner"
    },
    {
      "source": "adaboost",
      "target": "prediction"
    },
    {
      "source": "adaboost",
      "target": "sampleweighting"
    },
    {
      "source": "adaboost",
      "target": "hypothesis"
    },
    {
      "source": "adaboost",
      "target": "erm"
    },
    {
      "source": "adaboost",
      "target": "datapoint"
    },
    {
      "source": "adaboost",
      "target": "loss"
    },
    {
      "source": "adaboost",
      "target": "iteration"
    },
    {
      "source": "adaboost",
      "target": "gradstep"
    },
    {
      "source": "adaboost",
      "target": "learnrate"
    },
    {
      "source": "derivative",
      "target": "partialderivative"
    },
    {
      "source": "partialderivative",
      "target": "function"
    },
    {
      "source": "partialderivative",
      "target": "differentiable"
    },
    {
      "source": "partialderivative",
      "target": "gradient"
    },
    {
      "source": "gradientboosting",
      "target": "boosting"
    },
    {
      "source": "gradientboosting",
      "target": "algorithm"
    },
    {
      "source": "gradientboosting",
      "target": "hypothesis"
    },
    {
      "source": "gradientboosting",
      "target": "adaboost"
    },
    {
      "source": "gradientboosting",
      "target": "gradstep"
    },
    {
      "source": "gradientboosting",
      "target": "baselearner"
    },
    {
      "source": "gradientboosting",
      "target": "erm"
    },
    {
      "source": "gradientboosting",
      "target": "trainset"
    },
    {
      "source": "gradientboosting",
      "target": "featurevec"
    },
    {
      "source": "gradientboosting",
      "target": "label"
    },
    {
      "source": "gradientboosting",
      "target": "partialderivative"
    },
    {
      "source": "gradientboosting",
      "target": "lossfunc"
    },
    {
      "source": "gradientboosting",
      "target": "prediction"
    },
    {
      "source": "gradientboosting",
      "target": "gd"
    },
    {
      "source": "gtv",
      "target": "localmodel"
    },
    {
      "source": "gtv",
      "target": "modelparam"
    },
    {
      "source": "gtv",
      "target": "graph"
    },
    {
      "source": "gtv",
      "target": "discrepancy"
    },
    {
      "source": "gtv",
      "target": "hypothesis"
    },
    {
      "source": "gtv",
      "target": "map"
    },
    {
      "source": "srm",
      "target": "rerm"
    },
    {
      "source": "srm",
      "target": "model"
    },
    {
      "source": "srm",
      "target": "generalization"
    },
    {
      "source": "srm",
      "target": "erm"
    },
    {
      "source": "srm",
      "target": "regularizer"
    },
    {
      "source": "srm",
      "target": "risk"
    },
    {
      "source": "rlm",
      "target": "rerm"
    },
    {
      "source": "datapoisoning",
      "target": "data"
    },
    {
      "source": "datapoisoning",
      "target": "datapoint"
    },
    {
      "source": "datapoisoning",
      "target": "ml"
    },
    {
      "source": "datapoisoning",
      "target": "model"
    },
    {
      "source": "datapoisoning",
      "target": "attack"
    },
    {
      "source": "datapoisoning",
      "target": "backdoor"
    },
    {
      "source": "datapoisoning",
      "target": "dosattack"
    },
    {
      "source": "datapoisoning",
      "target": "featurevec"
    },
    {
      "source": "datapoisoning",
      "target": "fl"
    },
    {
      "source": "datapoisoning",
      "target": "trustAI"
    },
    {
      "source": "backdoor",
      "target": "ml"
    },
    {
      "source": "backdoor",
      "target": "training"
    },
    {
      "source": "backdoor",
      "target": "trainset"
    },
    {
      "source": "backdoor",
      "target": "datapoisoning"
    },
    {
      "source": "backdoor",
      "target": "optmethod"
    },
    {
      "source": "backdoor",
      "target": "erm"
    },
    {
      "source": "backdoor",
      "target": "hypothesis"
    },
    {
      "source": "backdoor",
      "target": "prediction"
    },
    {
      "source": "backdoor",
      "target": "featurespace"
    },
    {
      "source": "backdoor",
      "target": "featurevec"
    },
    {
      "source": "backdoor",
      "target": "attack"
    },
    {
      "source": "clustasspt",
      "target": "clustering"
    },
    {
      "source": "clustasspt",
      "target": "datapoint"
    },
    {
      "source": "clustasspt",
      "target": "dataset"
    },
    {
      "source": "clustasspt",
      "target": "cluster"
    },
    {
      "source": "dosattack",
      "target": "attack"
    },
    {
      "source": "dosattack",
      "target": "datapoisoning"
    },
    {
      "source": "dosattack",
      "target": "model"
    },
    {
      "source": "dosattack",
      "target": "datapoint"
    },
    {
      "source": "netexpfam",
      "target": "empgraph"
    },
    {
      "source": "netexpfam",
      "target": "modelparam"
    },
    {
      "source": "netexpfam",
      "target": "gtv"
    },
    {
      "source": "scatterplot",
      "target": "datapoint"
    },
    {
      "source": "scatterplot",
      "target": "minimum"
    },
    {
      "source": "scatterplot",
      "target": "feature"
    },
    {
      "source": "scatterplot",
      "target": "maximum"
    },
    {
      "source": "scatterplot",
      "target": "label"
    },
    {
      "source": "scatterplot",
      "target": "fmi"
    },
    {
      "source": "scatterplot",
      "target": "featurevec"
    },
    {
      "source": "scatterplot",
      "target": "dimred"
    },
    {
      "source": "stepsize",
      "target": "learnrate"
    },
    {
      "source": "learnrate",
      "target": "ml"
    },
    {
      "source": "learnrate",
      "target": "hypothesis"
    },
    {
      "source": "learnrate",
      "target": "parameter"
    },
    {
      "source": "learnrate",
      "target": "gradstep"
    },
    {
      "source": "learnrate",
      "target": "gdmethod"
    },
    {
      "source": "learnrate",
      "target": "erm"
    },
    {
      "source": "learnrate",
      "target": "objfunc"
    },
    {
      "source": "learnrate",
      "target": "emprisk"
    },
    {
      "source": "learnrate",
      "target": "trainset"
    },
    {
      "source": "learnrate",
      "target": "modelparam"
    },
    {
      "source": "learnrate",
      "target": "gradient"
    },
    {
      "source": "learnrate",
      "target": "gd"
    },
    {
      "source": "learnrate",
      "target": "stochGD"
    },
    {
      "source": "learnrate",
      "target": "projgd"
    },
    {
      "source": "learnrate",
      "target": "stepsize"
    },
    {
      "source": "featuremap",
      "target": "feature"
    },
    {
      "source": "featuremap",
      "target": "map"
    },
    {
      "source": "featuremap",
      "target": "function"
    },
    {
      "source": "featuremap",
      "target": "featurevec"
    },
    {
      "source": "featuremap",
      "target": "datapoint"
    },
    {
      "source": "featuremap",
      "target": "linmodel"
    },
    {
      "source": "featuremap",
      "target": "kernelmethod"
    },
    {
      "source": "featuremap",
      "target": "overfitting"
    },
    {
      "source": "featuremap",
      "target": "interpretability"
    },
    {
      "source": "featuremap",
      "target": "data"
    },
    {
      "source": "featuremap",
      "target": "scatterplot"
    },
    {
      "source": "featuremap",
      "target": "ml"
    },
    {
      "source": "featuremap",
      "target": "parameter"
    },
    {
      "source": "featuremap",
      "target": "layer"
    },
    {
      "source": "featuremap",
      "target": "deepnet"
    },
    {
      "source": "featuremap",
      "target": "erm"
    },
    {
      "source": "featuremap",
      "target": "lossfunc"
    },
    {
      "source": "featuremap",
      "target": "featlearn"
    },
    {
      "source": "featuremap",
      "target": "pca"
    },
    {
      "source": "lasso",
      "target": "srm"
    },
    {
      "source": "lasso",
      "target": "weights"
    },
    {
      "source": "lasso",
      "target": "linearmap"
    },
    {
      "source": "lasso",
      "target": "trainset"
    },
    {
      "source": "lasso",
      "target": "linreg"
    },
    {
      "source": "lasso",
      "target": "norm"
    },
    {
      "source": "lasso",
      "target": "sqerrloss"
    },
    {
      "source": "simgraph",
      "target": "ml"
    },
    {
      "source": "simgraph",
      "target": "datapoint"
    },
    {
      "source": "simgraph",
      "target": "graph"
    },
    {
      "source": "kld",
      "target": "probdist"
    },
    {
      "source": "LapMat",
      "target": "graph"
    },
    {
      "source": "LapMat",
      "target": "matrix"
    },
    {
      "source": "LapMat",
      "target": "edgeweight"
    },
    {
      "source": "algconn",
      "target": "undirectedgraph"
    },
    {
      "source": "algconn",
      "target": "eigenvalue"
    },
    {
      "source": "algconn",
      "target": "LapMat"
    },
    {
      "source": "algconn",
      "target": "graph"
    },
    {
      "source": "cfwmaxmin",
      "target": "psd"
    },
    {
      "source": "cfwmaxmin",
      "target": "matrix"
    },
    {
      "source": "cfwmaxmin",
      "target": "evd"
    },
    {
      "source": "cfwmaxmin",
      "target": "eigenvalue"
    },
    {
      "source": "cfwmaxmin",
      "target": "optproblem"
    },
    {
      "source": "kernel",
      "target": "datapoint"
    },
    {
      "source": "kernel",
      "target": "featurevec"
    },
    {
      "source": "kernel",
      "target": "featurespace"
    },
    {
      "source": "kernel",
      "target": "function"
    },
    {
      "source": "kernel",
      "target": "matrix"
    },
    {
      "source": "kernel",
      "target": "psd"
    },
    {
      "source": "kernel",
      "target": "hilbertspace"
    },
    {
      "source": "kernel",
      "target": "vectorspace"
    },
    {
      "source": "kernel",
      "target": "kernelmethod"
    },
    {
      "source": "kernelmethod",
      "target": "kernel"
    },
    {
      "source": "kernelmethod",
      "target": "ml"
    },
    {
      "source": "kernelmethod",
      "target": "featurevec"
    },
    {
      "source": "kernelmethod",
      "target": "datapoint"
    },
    {
      "source": "kernelmethod",
      "target": "featurespace"
    },
    {
      "source": "kernelmethod",
      "target": "classification"
    },
    {
      "source": "kernelmethod",
      "target": "linmodel"
    },
    {
      "source": "kernelmethod",
      "target": "label"
    },
    {
      "source": "kernelmethod",
      "target": "decisionboundary"
    },
    {
      "source": "kernelmethod",
      "target": "linclass"
    },
    {
      "source": "cm",
      "target": "datapoint"
    },
    {
      "source": "cm",
      "target": "feature"
    },
    {
      "source": "cm",
      "target": "label"
    },
    {
      "source": "cm",
      "target": "labelspace"
    },
    {
      "source": "cm",
      "target": "hypothesis"
    },
    {
      "source": "cm",
      "target": "matrix"
    },
    {
      "source": "cm",
      "target": "prediction"
    },
    {
      "source": "cm",
      "target": "classification"
    },
    {
      "source": "transferlearning",
      "target": "learningtask"
    },
    {
      "source": "transferlearning",
      "target": "multitask learning"
    },
    {
      "source": "featuremtx",
      "target": "dataset"
    },
    {
      "source": "featuremtx",
      "target": "datapoint"
    },
    {
      "source": "featuremtx",
      "target": "featurevec"
    },
    {
      "source": "featuremtx",
      "target": "feature"
    },
    {
      "source": "featuremtx",
      "target": "matrix"
    },
    {
      "source": "dbscan",
      "target": "clustering"
    },
    {
      "source": "dbscan",
      "target": "algorithm"
    },
    {
      "source": "dbscan",
      "target": "datapoint"
    },
    {
      "source": "dbscan",
      "target": "featurevec"
    },
    {
      "source": "dbscan",
      "target": "kmeans"
    },
    {
      "source": "dbscan",
      "target": "softclustering"
    },
    {
      "source": "dbscan",
      "target": "gmm"
    },
    {
      "source": "dbscan",
      "target": "cluster"
    },
    {
      "source": "dbscan",
      "target": "graph"
    },
    {
      "source": "fl",
      "target": "ml"
    },
    {
      "source": "fl",
      "target": "model"
    },
    {
      "source": "fl",
      "target": "data"
    },
    {
      "source": "cfl",
      "target": "localmodel"
    },
    {
      "source": "cfl",
      "target": "device"
    },
    {
      "source": "cfl",
      "target": "fl"
    },
    {
      "source": "cfl",
      "target": "clustasspt"
    },
    {
      "source": "cfl",
      "target": "empgraph"
    },
    {
      "source": "cfl",
      "target": "cluster"
    },
    {
      "source": "cfl",
      "target": "localdataset"
    },
    {
      "source": "cfl",
      "target": "trainset"
    },
    {
      "source": "cfl",
      "target": "model"
    },
    {
      "source": "cfl",
      "target": "gtvmin"
    },
    {
      "source": "cfl",
      "target": "modelparam"
    },
    {
      "source": "cfl",
      "target": "graphclustering"
    },
    {
      "source": "iid",
      "target": "rv"
    },
    {
      "source": "iid",
      "target": "probdist"
    },
    {
      "source": "iid",
      "target": "event"
    },
    {
      "source": "iid",
      "target": "datapoint"
    },
    {
      "source": "iid",
      "target": "iidasspt"
    },
    {
      "source": "preimage",
      "target": "function"
    },
    {
      "source": "measurable",
      "target": "randomexperiment"
    },
    {
      "source": "measurable",
      "target": "fmi"
    },
    {
      "source": "measurable",
      "target": "samplespace"
    },
    {
      "source": "measurable",
      "target": "ml"
    },
    {
      "source": "measurable",
      "target": "sigmaalgebra"
    },
    {
      "source": "measurable",
      "target": "probability"
    },
    {
      "source": "sigmaalgebra",
      "target": "randomexperiment"
    },
    {
      "source": "sigmaalgebra",
      "target": "samplespace"
    },
    {
      "source": "sigmaalgebra",
      "target": "rv"
    },
    {
      "source": "sigmaalgebra",
      "target": "probspace"
    },
    {
      "source": "sigmafield",
      "target": "sigmaalgebra"
    },
    {
      "source": "injective",
      "target": "function"
    },
    {
      "source": "injective",
      "target": "domain"
    },
    {
      "source": "injective",
      "target": "co-domain"
    },
    {
      "source": "event",
      "target": "rv"
    },
    {
      "source": "event",
      "target": "probspace"
    },
    {
      "source": "event",
      "target": "measurable"
    },
    {
      "source": "event",
      "target": "probability"
    },
    {
      "source": "event",
      "target": "preimage"
    },
    {
      "source": "event",
      "target": "sigmaalgebra"
    },
    {
      "source": "event",
      "target": "datapoint"
    },
    {
      "source": "event",
      "target": "iidasspt"
    },
    {
      "source": "event",
      "target": "probmodel"
    },
    {
      "source": "countable",
      "target": "injective"
    },
    {
      "source": "countable",
      "target": "function"
    },
    {
      "source": "pmf",
      "target": "rv"
    },
    {
      "source": "pmf",
      "target": "function"
    },
    {
      "source": "pmf",
      "target": "probability"
    },
    {
      "source": "pmf",
      "target": "dataset"
    },
    {
      "source": "pmf",
      "target": "datapoint"
    },
    {
      "source": "pmf",
      "target": "realization"
    },
    {
      "source": "pmf",
      "target": "iid"
    },
    {
      "source": "pmf",
      "target": "probdist"
    },
    {
      "source": "pmf",
      "target": "probmodel"
    },
    {
      "source": "coreset",
      "target": "dataset"
    },
    {
      "source": "coreset",
      "target": "datapoint"
    },
    {
      "source": "coreset",
      "target": "ml"
    },
    {
      "source": "coreset",
      "target": "clustering"
    },
    {
      "source": "coreset",
      "target": "data"
    },
    {
      "source": "outlier",
      "target": "ml"
    },
    {
      "source": "outlier",
      "target": "iidasspt"
    },
    {
      "source": "outlier",
      "target": "datapoint"
    },
    {
      "source": "outlier",
      "target": "realization"
    },
    {
      "source": "outlier",
      "target": "iid"
    },
    {
      "source": "outlier",
      "target": "rv"
    },
    {
      "source": "outlier",
      "target": "probdist"
    },
    {
      "source": "outlier",
      "target": "data"
    },
    {
      "source": "outlier",
      "target": "robustness"
    },
    {
      "source": "outlier",
      "target": "stability"
    },
    {
      "source": "outlier",
      "target": "huberreg"
    },
    {
      "source": "outlier",
      "target": "probmodel"
    },
    {
      "source": "membershipinferenceattack",
      "target": "ml"
    },
    {
      "source": "membershipinferenceattack",
      "target": "hypothesis"
    },
    {
      "source": "membershipinferenceattack",
      "target": "erm"
    },
    {
      "source": "membershipinferenceattack",
      "target": "trainset"
    },
    {
      "source": "membershipinferenceattack",
      "target": "attack"
    },
    {
      "source": "membershipinferenceattack",
      "target": "privattack"
    },
    {
      "source": "membershipinferenceattack",
      "target": "datapoint"
    },
    {
      "source": "membershipinferenceattack",
      "target": "featurevec"
    },
    {
      "source": "membershipinferenceattack",
      "target": "prediction"
    },
    {
      "source": "machineunlearning",
      "target": "ml"
    },
    {
      "source": "machineunlearning",
      "target": "hypothesis"
    },
    {
      "source": "machineunlearning",
      "target": "erm"
    },
    {
      "source": "machineunlearning",
      "target": "trainset"
    },
    {
      "source": "machineunlearning",
      "target": "privattack"
    },
    {
      "source": "machineunlearning",
      "target": "modelinversion"
    },
    {
      "source": "machineunlearning",
      "target": "datapoint"
    },
    {
      "source": "machineunlearning",
      "target": "privprot"
    },
    {
      "source": "machineunlearning",
      "target": "ai"
    },
    {
      "source": "machineunlearning",
      "target": "gdpr"
    },
    {
      "source": "ensemble",
      "target": "ml"
    },
    {
      "source": "ensemble",
      "target": "baselearner"
    },
    {
      "source": "ensemble",
      "target": "erm"
    },
    {
      "source": "ensemble",
      "target": "loss"
    },
    {
      "source": "ensemble",
      "target": "model"
    },
    {
      "source": "ensemble",
      "target": "trainset"
    },
    {
      "source": "ensemble",
      "target": "prediction"
    },
    {
      "source": "ensemble",
      "target": "regression"
    },
    {
      "source": "ensemble",
      "target": "classification"
    },
    {
      "source": "ensemble",
      "target": "hypothesis"
    },
    {
      "source": "ensemble",
      "target": "bagging"
    },
    {
      "source": "ensemble",
      "target": "randomforest"
    },
    {
      "source": "ensemble",
      "target": "boosting"
    },
    {
      "source": "ensemble",
      "target": "stacking"
    },
    {
      "source": "stacking",
      "target": "ensemble"
    },
    {
      "source": "stacking",
      "target": "baselearner"
    },
    {
      "source": "stacking",
      "target": "dataset"
    },
    {
      "source": "stacking",
      "target": "model"
    },
    {
      "source": "stacking",
      "target": "lossfunc"
    },
    {
      "source": "stacking",
      "target": "hypothesis"
    },
    {
      "source": "stacking",
      "target": "prediction"
    },
    {
      "source": "stacking",
      "target": "datapoint"
    },
    {
      "source": "stacking",
      "target": "classification"
    },
    {
      "source": "stacking",
      "target": "regression"
    },
    {
      "source": "stacking",
      "target": "featlearn"
    },
    {
      "source": "stacking",
      "target": "feature"
    },
    {
      "source": "stacking",
      "target": "erm"
    },
    {
      "source": "stacking",
      "target": "featurevec"
    },
    {
      "source": "stacking",
      "target": "bagging"
    },
    {
      "source": "sample",
      "target": "ml"
    },
    {
      "source": "sample",
      "target": "sequence"
    },
    {
      "source": "sample",
      "target": "datapoint"
    },
    {
      "source": "sample",
      "target": "samplesize"
    },
    {
      "source": "sample",
      "target": "erm"
    },
    {
      "source": "sample",
      "target": "model"
    },
    {
      "source": "sample",
      "target": "hypothesis"
    },
    {
      "source": "sample",
      "target": "loss"
    },
    {
      "source": "sample",
      "target": "emprisk"
    },
    {
      "source": "sample",
      "target": "feature"
    },
    {
      "source": "sample",
      "target": "label"
    },
    {
      "source": "sample",
      "target": "featurevec"
    },
    {
      "source": "sample",
      "target": "realization"
    },
    {
      "source": "sample",
      "target": "stochproc"
    },
    {
      "source": "sample",
      "target": "iidasspt"
    },
    {
      "source": "sample",
      "target": "iid"
    },
    {
      "source": "sample",
      "target": "rv"
    },
    {
      "source": "sample",
      "target": "probdist"
    },
    {
      "source": "sample",
      "target": "dataset"
    },
    {
      "source": "condtionalexpect",
      "target": "rv"
    },
    {
      "source": "condtionalexpect",
      "target": "probspace"
    },
    {
      "source": "condtionalexpect",
      "target": "sigmaalgebra"
    },
    {
      "source": "auc",
      "target": "classifier"
    },
    {
      "source": "auc",
      "target": "euclidspace"
    },
    {
      "source": "auc",
      "target": "roc"
    },
    {
      "source": "roc",
      "target": "labelspace"
    },
    {
      "source": "roc",
      "target": "classifier"
    },
    {
      "source": "roc",
      "target": "hypothesis"
    },
    {
      "source": "roc",
      "target": "prediction"
    },
    {
      "source": "roc",
      "target": "testset"
    },
    {
      "source": "roc",
      "target": "function"
    },
    {
      "source": "roc",
      "target": "auc"
    },
    {
      "source": "condprobdist",
      "target": "stochproc"
    },
    {
      "source": "condprobdist",
      "target": "rv"
    },
    {
      "source": "condprobdist",
      "target": "probdist"
    },
    {
      "source": "condprobdist",
      "target": "expectation"
    },
    {
      "source": "condprobdist",
      "target": "measurable"
    },
    {
      "source": "condprobdist",
      "target": "sigmaalgebra"
    },
    {
      "source": "posterior",
      "target": "ml"
    },
    {
      "source": "posterior",
      "target": "probmodel"
    },
    {
      "source": "posterior",
      "target": "data"
    },
    {
      "source": "posterior",
      "target": "datapoint"
    },
    {
      "source": "posterior",
      "target": "feature"
    },
    {
      "source": "posterior",
      "target": "label"
    },
    {
      "source": "posterior",
      "target": "rv"
    },
    {
      "source": "posterior",
      "target": "probdist"
    },
    {
      "source": "posterior",
      "target": "prediction"
    },
    {
      "source": "posterior",
      "target": "featurevec"
    },
    {
      "source": "bagging",
      "target": "ensemble"
    },
    {
      "source": "bagging",
      "target": "baselearner"
    },
    {
      "source": "bagging",
      "target": "trainset"
    },
    {
      "source": "bagging",
      "target": "hypothesis"
    },
    {
      "source": "bagging",
      "target": "classification"
    },
    {
      "source": "bagging",
      "target": "regression"
    },
    {
      "source": "bagging",
      "target": "robustness"
    },
    {
      "source": "bagging",
      "target": "bootstrap"
    },
    {
      "source": "bootstrap aggregation",
      "target": "bagging"
    },
    {
      "source": "decisionregion",
      "target": "hypothesis"
    },
    {
      "source": "decisionregion",
      "target": "map"
    },
    {
      "source": "decisionregion",
      "target": "label"
    },
    {
      "source": "decisionregion",
      "target": "feature"
    },
    {
      "source": "baselearner",
      "target": "ml"
    },
    {
      "source": "baselearner",
      "target": "ensemble"
    },
    {
      "source": "baselearner",
      "target": "bagging"
    },
    {
      "source": "baselearner",
      "target": "stacking"
    },
    {
      "source": "baselearner",
      "target": "boosting"
    },
    {
      "source": "decisionboundary",
      "target": "hypothesis"
    },
    {
      "source": "decisionboundary",
      "target": "map"
    },
    {
      "source": "decisionboundary",
      "target": "featurevec"
    },
    {
      "source": "decisionboundary",
      "target": "vector"
    },
    {
      "source": "decisionboundary",
      "target": "decisionregion"
    },
    {
      "source": "decisionboundary",
      "target": "neighborhood"
    },
    {
      "source": "decisionboundary",
      "target": "function"
    },
    {
      "source": "euclidnorm",
      "target": "vector"
    },
    {
      "source": "euclidnorm",
      "target": "euclidspace"
    },
    {
      "source": "eucliddist",
      "target": "euclidnorm"
    },
    {
      "source": "eucliddist",
      "target": "vector"
    },
    {
      "source": "eucliddist",
      "target": "euclidspace"
    },
    {
      "source": "normalequations",
      "target": "modelparam"
    },
    {
      "source": "normalequations",
      "target": "linleastsquares"
    },
    {
      "source": "euclidspace",
      "target": "vector"
    },
    {
      "source": "eerm",
      "target": "srm"
    },
    {
      "source": "eerm",
      "target": "regularization"
    },
    {
      "source": "eerm",
      "target": "loss"
    },
    {
      "source": "eerm",
      "target": "objfunc"
    },
    {
      "source": "eerm",
      "target": "erm"
    },
    {
      "source": "eerm",
      "target": "hypothesis"
    },
    {
      "source": "eerm",
      "target": "map"
    },
    {
      "source": "eerm",
      "target": "prediction"
    },
    {
      "source": "eerm",
      "target": "datapoint"
    },
    {
      "source": "eerm",
      "target": "trainset"
    },
    {
      "source": "kmeans",
      "target": "clustering"
    },
    {
      "source": "kmeans",
      "target": "datapoint"
    },
    {
      "source": "kmeans",
      "target": "featurevec"
    },
    {
      "source": "kmeans",
      "target": "hardclustering"
    },
    {
      "source": "kmeans",
      "target": "dataset"
    },
    {
      "source": "kmeans",
      "target": "cluster"
    },
    {
      "source": "kmeans",
      "target": "mean"
    },
    {
      "source": "kmeans",
      "target": "clustercentroid"
    },
    {
      "source": "kmeans",
      "target": "scatterplot"
    },
    {
      "source": "kmeans",
      "target": "optproblem"
    },
    {
      "source": "kmeans",
      "target": "lloydalgorithm"
    },
    {
      "source": "lloydalgorithm",
      "target": "algorithm"
    },
    {
      "source": "lloydalgorithm",
      "target": "optmethod"
    },
    {
      "source": "lloydalgorithm",
      "target": "clustercentroid"
    },
    {
      "source": "lloydalgorithm",
      "target": "kmeans"
    },
    {
      "source": "lloydalgorithm",
      "target": "objfunc"
    },
    {
      "source": "lloydalgorithm",
      "target": "cluster"
    },
    {
      "source": "lloydalgorithm",
      "target": "datapoint"
    },
    {
      "source": "lloydalgorithm",
      "target": "clustering"
    },
    {
      "source": "qlearning",
      "target": "reinforcementlearning"
    },
    {
      "source": "qlearning",
      "target": "algorithm"
    },
    {
      "source": "qlearning",
      "target": "fixedpointiter"
    },
    {
      "source": "iteration",
      "target": "algorithm"
    },
    {
      "source": "iteration",
      "target": "gdmethod"
    },
    {
      "source": "iteration",
      "target": "gradstep"
    },
    {
      "source": "iteration",
      "target": "fixedpointiter"
    },
    {
      "source": "iteration",
      "target": "ml"
    },
    {
      "source": "iteration",
      "target": "lloydalgorithm"
    },
    {
      "source": "iteration",
      "target": "gd"
    },
    {
      "source": "clustercentroid",
      "target": "clustering"
    },
    {
      "source": "clustercentroid",
      "target": "dataset"
    },
    {
      "source": "clustercentroid",
      "target": "cluster"
    },
    {
      "source": "clustercentroid",
      "target": "datapoint"
    },
    {
      "source": "clustercentroid",
      "target": "featurevec"
    },
    {
      "source": "clustercentroid",
      "target": "kmeans"
    },
    {
      "source": "xml",
      "target": "prediction"
    },
    {
      "source": "xml",
      "target": "explanation"
    },
    {
      "source": "xml",
      "target": "ml"
    },
    {
      "source": "xml",
      "target": "model"
    },
    {
      "source": "fmi",
      "target": "data"
    },
    {
      "source": "samplemean",
      "target": "sample"
    },
    {
      "source": "samplemean",
      "target": "mean"
    },
    {
      "source": "samplemean",
      "target": "dataset"
    },
    {
      "source": "samplemean",
      "target": "featurevec"
    },
    {
      "source": "samplecovmtx",
      "target": "sample"
    },
    {
      "source": "samplecovmtx",
      "target": "covmtx"
    },
    {
      "source": "samplecovmtx",
      "target": "featurevec"
    },
    {
      "source": "samplecovmtx",
      "target": "samplemean"
    },
    {
      "source": "covmtx",
      "target": "covariance"
    },
    {
      "source": "covmtx",
      "target": "matrix"
    },
    {
      "source": "covmtx",
      "target": "rv"
    },
    {
      "source": "highdimregime",
      "target": "erm"
    },
    {
      "source": "highdimregime",
      "target": "effdim"
    },
    {
      "source": "highdimregime",
      "target": "model"
    },
    {
      "source": "highdimregime",
      "target": "samplesize"
    },
    {
      "source": "highdimregime",
      "target": "datapoint"
    },
    {
      "source": "highdimregime",
      "target": "trainset"
    },
    {
      "source": "highdimregime",
      "target": "linreg"
    },
    {
      "source": "highdimregime",
      "target": "feature"
    },
    {
      "source": "highdimregime",
      "target": "ml"
    },
    {
      "source": "highdimregime",
      "target": "ann"
    },
    {
      "source": "highdimregime",
      "target": "weights"
    },
    {
      "source": "highdimregime",
      "target": "probability"
    },
    {
      "source": "highdimregime",
      "target": "overfitting"
    },
    {
      "source": "highdimregime",
      "target": "regularization"
    },
    {
      "source": "covariance",
      "target": "rv"
    },
    {
      "source": "covariance",
      "target": "probspace"
    },
    {
      "source": "covariance",
      "target": "scatterplot"
    },
    {
      "source": "covariance",
      "target": "realization"
    },
    {
      "source": "covariance",
      "target": "probmodel"
    },
    {
      "source": "covariance",
      "target": "expectation"
    },
    {
      "source": "gmm",
      "target": "probmodel"
    },
    {
      "source": "gmm",
      "target": "datapoint"
    },
    {
      "source": "gmm",
      "target": "featurevec"
    },
    {
      "source": "gmm",
      "target": "mvndist"
    },
    {
      "source": "gmm",
      "target": "rv"
    },
    {
      "source": "gmm",
      "target": "probability"
    },
    {
      "source": "gmm",
      "target": "mean"
    },
    {
      "source": "gmm",
      "target": "vector"
    },
    {
      "source": "gmm",
      "target": "covmtx"
    },
    {
      "source": "gmm",
      "target": "clustering"
    },
    {
      "source": "maxlikelihood",
      "target": "datapoint"
    },
    {
      "source": "maxlikelihood",
      "target": "realization"
    },
    {
      "source": "maxlikelihood",
      "target": "iid"
    },
    {
      "source": "maxlikelihood",
      "target": "rv"
    },
    {
      "source": "maxlikelihood",
      "target": "probdist"
    },
    {
      "source": "maxlikelihood",
      "target": "modelparam"
    },
    {
      "source": "maxlikelihood",
      "target": "maximum"
    },
    {
      "source": "maxlikelihood",
      "target": "dataset"
    },
    {
      "source": "maxlikelihood",
      "target": "optproblem"
    },
    {
      "source": "maxlikelihood",
      "target": "probmodel"
    },
    {
      "source": "em",
      "target": "probmodel"
    },
    {
      "source": "em",
      "target": "datapoint"
    },
    {
      "source": "em",
      "target": "ml"
    },
    {
      "source": "em",
      "target": "maxlikelihood"
    },
    {
      "source": "em",
      "target": "modelparam"
    },
    {
      "source": "em",
      "target": "optproblem"
    },
    {
      "source": "em",
      "target": "rv"
    },
    {
      "source": "em",
      "target": "dataset"
    },
    {
      "source": "em",
      "target": "expectation"
    },
    {
      "source": "em",
      "target": "stopcrit"
    },
    {
      "source": "ppca",
      "target": "pca"
    },
    {
      "source": "ppca",
      "target": "probmodel"
    },
    {
      "source": "ppca",
      "target": "datapoint"
    },
    {
      "source": "ppca",
      "target": "dimred"
    },
    {
      "source": "ppca",
      "target": "em"
    },
    {
      "source": "polyreg",
      "target": "regression"
    },
    {
      "source": "polyreg",
      "target": "erm"
    },
    {
      "source": "polyreg",
      "target": "hypothesis"
    },
    {
      "source": "polyreg",
      "target": "map"
    },
    {
      "source": "polyreg",
      "target": "label"
    },
    {
      "source": "polyreg",
      "target": "feature"
    },
    {
      "source": "polyreg",
      "target": "datapoint"
    },
    {
      "source": "polyreg",
      "target": "hypospace"
    },
    {
      "source": "polyreg",
      "target": "sqerrloss"
    },
    {
      "source": "polyreg",
      "target": "labeled datapoint"
    },
    {
      "source": "polyreg",
      "target": "trainset"
    },
    {
      "source": "leastsquares",
      "target": "erm"
    },
    {
      "source": "leastsquares",
      "target": "sqerrloss"
    },
    {
      "source": "leastsquares",
      "target": "trainset"
    },
    {
      "source": "leastsquares",
      "target": "hypothesis"
    },
    {
      "source": "leastsquares",
      "target": "map"
    },
    {
      "source": "leastsquares",
      "target": "model"
    },
    {
      "source": "leastsquares",
      "target": "linmodel"
    },
    {
      "source": "leastsquares",
      "target": "linreg"
    },
    {
      "source": "columnspace",
      "target": "matrix"
    },
    {
      "source": "columnspace",
      "target": "subspace"
    },
    {
      "source": "columnspace",
      "target": "euclidspace"
    },
    {
      "source": "columnspace",
      "target": "vectorspace"
    },
    {
      "source": "subspace",
      "target": "vectorspace"
    },
    {
      "source": "designmatrix",
      "target": "featuremtx"
    },
    {
      "source": "designmatrix",
      "target": "featurevec"
    },
    {
      "source": "designmatrix",
      "target": "datapoint"
    },
    {
      "source": "designmatrix",
      "target": "dataset"
    },
    {
      "source": "designmatrix",
      "target": "model"
    },
    {
      "source": "designmatrix",
      "target": "training"
    },
    {
      "source": "designmatrix",
      "target": "validation"
    },
    {
      "source": "datamatrix",
      "target": "data"
    },
    {
      "source": "datamatrix",
      "target": "matrix"
    },
    {
      "source": "datamatrix",
      "target": "featuremtx"
    },
    {
      "source": "datamatrix",
      "target": "dataset"
    },
    {
      "source": "datamatrix",
      "target": "datapoint"
    },
    {
      "source": "datamatrix",
      "target": "featurevec"
    },
    {
      "source": "datamatrix",
      "target": "label"
    },
    {
      "source": "labelvec",
      "target": "dataset"
    },
    {
      "source": "labelvec",
      "target": "labeled datapoint"
    },
    {
      "source": "labelvec",
      "target": "label"
    },
    {
      "source": "labelvec",
      "target": "vector"
    },
    {
      "source": "labelvec",
      "target": "datapoint"
    },
    {
      "source": "inputvec",
      "target": "vector"
    },
    {
      "source": "inputvec",
      "target": "featurevec"
    },
    {
      "source": "inputvec",
      "target": "datapoint"
    },
    {
      "source": "inputvec",
      "target": "feature"
    },
    {
      "source": "inputvec",
      "target": "ml"
    },
    {
      "source": "inputvec",
      "target": "label"
    },
    {
      "source": "outputvec",
      "target": "vector"
    },
    {
      "source": "outputvec",
      "target": "labelvec"
    },
    {
      "source": "outputvec",
      "target": "dataset"
    },
    {
      "source": "output",
      "target": "label"
    },
    {
      "source": "output",
      "target": "datapoint"
    },
    {
      "source": "targetvec",
      "target": "vector"
    },
    {
      "source": "targetvec",
      "target": "labelvec"
    },
    {
      "source": "targetvec",
      "target": "dataset"
    },
    {
      "source": "target",
      "target": "label"
    },
    {
      "source": "target",
      "target": "datapoint"
    },
    {
      "source": "responsevec",
      "target": "vector"
    },
    {
      "source": "responsevec",
      "target": "labelvec"
    },
    {
      "source": "responsevec",
      "target": "dataset"
    },
    {
      "source": "response",
      "target": "label"
    },
    {
      "source": "response",
      "target": "datapoint"
    },
    {
      "source": "linleastsquares",
      "target": "linreg"
    },
    {
      "source": "linleastsquares",
      "target": "sqerrloss"
    },
    {
      "source": "linleastsquares",
      "target": "hypothesis"
    },
    {
      "source": "linleastsquares",
      "target": "map"
    },
    {
      "source": "linleastsquares",
      "target": "leastsquares"
    },
    {
      "source": "linleastsquares",
      "target": "linmodel"
    },
    {
      "source": "linleastsquares",
      "target": "label"
    },
    {
      "source": "linleastsquares",
      "target": "vector"
    },
    {
      "source": "linleastsquares",
      "target": "columnspace"
    },
    {
      "source": "linleastsquares",
      "target": "featuremtx"
    },
    {
      "source": "linleastsquares",
      "target": "normalequations"
    },
    {
      "source": "linleastsquares",
      "target": "parameter"
    },
    {
      "source": "linleastsquares",
      "target": "trainset"
    },
    {
      "source": "linleastsquares",
      "target": "erm"
    },
    {
      "source": "weightedleastsquares",
      "target": "erm"
    },
    {
      "source": "weightedleastsquares",
      "target": "sqerrloss"
    },
    {
      "source": "weightedleastsquares",
      "target": "trainset"
    },
    {
      "source": "weightedleastsquares",
      "target": "hypothesis"
    },
    {
      "source": "weightedleastsquares",
      "target": "map"
    },
    {
      "source": "weightedleastsquares",
      "target": "outlier"
    },
    {
      "source": "weightedleastsquares",
      "target": "datapoint"
    },
    {
      "source": "weightedleastsquares",
      "target": "model"
    },
    {
      "source": "weightedleastsquares",
      "target": "linreg"
    },
    {
      "source": "weightedleastsquares",
      "target": "linmodel"
    },
    {
      "source": "linreg",
      "target": "regression"
    },
    {
      "source": "linreg",
      "target": "hypothesis"
    },
    {
      "source": "linreg",
      "target": "map"
    },
    {
      "source": "linreg",
      "target": "label"
    },
    {
      "source": "linreg",
      "target": "datapoint"
    },
    {
      "source": "linreg",
      "target": "featurevec"
    },
    {
      "source": "linreg",
      "target": "sqerrloss"
    },
    {
      "source": "linreg",
      "target": "trainset"
    },
    {
      "source": "linreg",
      "target": "erm"
    },
    {
      "source": "linreg",
      "target": "modelparam"
    },
    {
      "source": "linreg",
      "target": "optproblem"
    },
    {
      "source": "linreg",
      "target": "outlier"
    },
    {
      "source": "linreg",
      "target": "linmodel"
    },
    {
      "source": "linreg",
      "target": "feature"
    },
    {
      "source": "linreg",
      "target": "parameter"
    },
    {
      "source": "linreg",
      "target": "dataset"
    },
    {
      "source": "linreg",
      "target": "featuremtx"
    },
    {
      "source": "linreg",
      "target": "vector"
    },
    {
      "source": "linreg",
      "target": "zerogradientcondition"
    },
    {
      "source": "linreg",
      "target": "inverse"
    },
    {
      "source": "linreg",
      "target": "pseudoinverse"
    },
    {
      "source": "linreg",
      "target": "ml"
    },
    {
      "source": "linreg",
      "target": "gd"
    },
    {
      "source": "linreg",
      "target": "gdmethod"
    },
    {
      "source": "linreg",
      "target": "fixedpointiter"
    },
    {
      "source": "linreg",
      "target": "matrix"
    },
    {
      "source": "linreg",
      "target": "stability"
    },
    {
      "source": "ridgeregression",
      "target": "regression"
    },
    {
      "source": "ridgeregression",
      "target": "hypothesis"
    },
    {
      "source": "ridgeregression",
      "target": "label"
    },
    {
      "source": "ridgeregression",
      "target": "datapoint"
    },
    {
      "source": "ridgeregression",
      "target": "featurevec"
    },
    {
      "source": "ridgeregression",
      "target": "parameter"
    },
    {
      "source": "ridgeregression",
      "target": "sqerrloss"
    },
    {
      "source": "ridgeregression",
      "target": "labeled datapoint"
    },
    {
      "source": "ridgeregression",
      "target": "trainset"
    },
    {
      "source": "ridgeregression",
      "target": "norm"
    },
    {
      "source": "ridgeregression",
      "target": "regularization"
    },
    {
      "source": "ridgeregression",
      "target": "overfitting"
    },
    {
      "source": "ridgeregression",
      "target": "highdimregime"
    },
    {
      "source": "ridgeregression",
      "target": "feature"
    },
    {
      "source": "ridgeregression",
      "target": "training"
    },
    {
      "source": "ridgeregression",
      "target": "linmodel"
    },
    {
      "source": "ridgeregression",
      "target": "objfunc"
    },
    {
      "source": "ridgeregression",
      "target": "erm"
    },
    {
      "source": "ridgeregression",
      "target": "dataset"
    },
    {
      "source": "ridgeregression",
      "target": "realization"
    },
    {
      "source": "ridgeregression",
      "target": "iid"
    },
    {
      "source": "ridgeregression",
      "target": "rv"
    },
    {
      "source": "ridgeregression",
      "target": "probdist"
    },
    {
      "source": "ridgeregression",
      "target": "map"
    },
    {
      "source": "ridgeregression",
      "target": "dataaug"
    },
    {
      "source": "expectation",
      "target": "featurevec"
    },
    {
      "source": "expectation",
      "target": "realization"
    },
    {
      "source": "expectation",
      "target": "rv"
    },
    {
      "source": "expectation",
      "target": "probdist"
    },
    {
      "source": "expectation",
      "target": "probability"
    },
    {
      "source": "logreg",
      "target": "regression"
    },
    {
      "source": "logreg",
      "target": "hypothesis"
    },
    {
      "source": "logreg",
      "target": "map"
    },
    {
      "source": "logreg",
      "target": "classifier"
    },
    {
      "source": "logreg",
      "target": "label"
    },
    {
      "source": "logreg",
      "target": "featurevec"
    },
    {
      "source": "logreg",
      "target": "datapoint"
    },
    {
      "source": "logreg",
      "target": "logloss"
    },
    {
      "source": "logreg",
      "target": "labeled datapoint"
    },
    {
      "source": "logreg",
      "target": "trainset"
    },
    {
      "source": "logloss",
      "target": "datapoint"
    },
    {
      "source": "logloss",
      "target": "feature"
    },
    {
      "source": "logloss",
      "target": "label"
    },
    {
      "source": "logloss",
      "target": "hypothesis"
    },
    {
      "source": "logloss",
      "target": "loss"
    },
    {
      "source": "logloss",
      "target": "prediction"
    },
    {
      "source": "logloss",
      "target": "labelspace"
    },
    {
      "source": "hingeloss",
      "target": "datapoint"
    },
    {
      "source": "hingeloss",
      "target": "featurevec"
    },
    {
      "source": "hingeloss",
      "target": "label"
    },
    {
      "source": "hingeloss",
      "target": "loss"
    },
    {
      "source": "hingeloss",
      "target": "hypothesis"
    },
    {
      "source": "hingeloss",
      "target": "map"
    },
    {
      "source": "hingeloss",
      "target": "prediction"
    },
    {
      "source": "hingeloss",
      "target": "svm"
    },
    {
      "source": "hingeloss",
      "target": "classification"
    },
    {
      "source": "hingeloss",
      "target": "classifier"
    },
    {
      "source": "iidasspt",
      "target": "iid"
    },
    {
      "source": "iidasspt",
      "target": "datapoint"
    },
    {
      "source": "iidasspt",
      "target": "dataset"
    },
    {
      "source": "iidasspt",
      "target": "realization"
    },
    {
      "source": "iidasspt",
      "target": "rv"
    },
    {
      "source": "hypospace",
      "target": "hypothesis"
    },
    {
      "source": "hypospace",
      "target": "model"
    },
    {
      "source": "hypospace",
      "target": "ml"
    },
    {
      "source": "hypospace",
      "target": "map"
    },
    {
      "source": "hypospace",
      "target": "feature"
    },
    {
      "source": "hypospace",
      "target": "datapoint"
    },
    {
      "source": "hypospace",
      "target": "prediction"
    },
    {
      "source": "hypospace",
      "target": "label"
    },
    {
      "source": "hypospace",
      "target": "featurespace"
    },
    {
      "source": "hypospace",
      "target": "labelspace"
    },
    {
      "source": "hypospace",
      "target": "erm"
    },
    {
      "source": "hypospace",
      "target": "statasp"
    },
    {
      "source": "hypospace",
      "target": "matrix"
    },
    {
      "source": "hypospace",
      "target": "linmodel"
    },
    {
      "source": "model",
      "target": "ml"
    },
    {
      "source": "model",
      "target": "hypospace"
    },
    {
      "source": "model",
      "target": "hypothesis"
    },
    {
      "source": "model",
      "target": "map"
    },
    {
      "source": "model",
      "target": "label"
    },
    {
      "source": "model",
      "target": "feature"
    },
    {
      "source": "model",
      "target": "datapoint"
    },
    {
      "source": "model",
      "target": "probmodel"
    },
    {
      "source": "model",
      "target": "probdist"
    },
    {
      "source": "model",
      "target": "linearmap"
    },
    {
      "source": "modelparam",
      "target": "parammodel"
    },
    {
      "source": "modelparam",
      "target": "model"
    },
    {
      "source": "modelparam",
      "target": "parameter"
    },
    {
      "source": "modelparam",
      "target": "ml"
    },
    {
      "source": "modelparam",
      "target": "hypothesis"
    },
    {
      "source": "modelparam",
      "target": "vector"
    },
    {
      "source": "modelparam",
      "target": "paramspace"
    },
    {
      "source": "modelparam",
      "target": "map"
    },
    {
      "source": "ai",
      "target": "reward"
    },
    {
      "source": "ai",
      "target": "ml"
    },
    {
      "source": "ai",
      "target": "model"
    },
    {
      "source": "ai",
      "target": "prediction"
    },
    {
      "source": "ai",
      "target": "lossfunc"
    },
    {
      "source": "ai",
      "target": "trainset"
    },
    {
      "source": "ai",
      "target": "loss"
    },
    {
      "source": "ai",
      "target": "modelparam"
    },
    {
      "source": "ai",
      "target": "reinforcementlearning"
    },
    {
      "source": "mdp",
      "target": "reinforcementlearning"
    },
    {
      "source": "mdp",
      "target": "reward"
    },
    {
      "source": "mdp",
      "target": "prediction"
    },
    {
      "source": "mdp",
      "target": "stochproc"
    },
    {
      "source": "mdp",
      "target": "function"
    },
    {
      "source": "mdp",
      "target": "probdist"
    },
    {
      "source": "reward",
      "target": "loss"
    },
    {
      "source": "reward",
      "target": "prediction"
    },
    {
      "source": "reward",
      "target": "hypothesis"
    },
    {
      "source": "reward",
      "target": "ml"
    },
    {
      "source": "reward",
      "target": "mab"
    },
    {
      "source": "reward",
      "target": "reinforcementlearning"
    },
    {
      "source": "clusteringerror",
      "target": "clustering"
    },
    {
      "source": "clusteringerror",
      "target": "dataset"
    },
    {
      "source": "clusteringerror",
      "target": "cluster"
    },
    {
      "source": "clusteringerror",
      "target": "datapoint"
    },
    {
      "source": "clusteringerror",
      "target": "featurevec"
    },
    {
      "source": "clusteringerror",
      "target": "eucliddist"
    },
    {
      "source": "clusteringerror",
      "target": "clustercentroid"
    },
    {
      "source": "clusteringerror",
      "target": "hardclustering"
    },
    {
      "source": "clusteringerror",
      "target": "kmeans"
    },
    {
      "source": "hardclustering",
      "target": "clustering"
    },
    {
      "source": "hardclustering",
      "target": "datapoint"
    },
    {
      "source": "hardclustering",
      "target": "cluster"
    },
    {
      "source": "hardclustering",
      "target": "softclustering"
    },
    {
      "source": "hardclustering",
      "target": "dob"
    },
    {
      "source": "hardclustering",
      "target": "featurevec"
    },
    {
      "source": "hardclustering",
      "target": "kmeans"
    },
    {
      "source": "hardclustering",
      "target": "data"
    },
    {
      "source": "hardclustering",
      "target": "featlearn"
    },
    {
      "source": "hardclustering",
      "target": "specclustering"
    },
    {
      "source": "hardclustering",
      "target": "graph"
    },
    {
      "source": "hardclustering",
      "target": "eigenvector"
    },
    {
      "source": "hardclustering",
      "target": "LapMat"
    },
    {
      "source": "hardclustering",
      "target": "feature"
    },
    {
      "source": "softclustering",
      "target": "clustering"
    },
    {
      "source": "softclustering",
      "target": "datapoint"
    },
    {
      "source": "softclustering",
      "target": "cluster"
    },
    {
      "source": "softclustering",
      "target": "dob"
    },
    {
      "source": "softclustering",
      "target": "featurevec"
    },
    {
      "source": "softclustering",
      "target": "probmodel"
    },
    {
      "source": "softclustering",
      "target": "gmm"
    },
    {
      "source": "softclustering",
      "target": "probability"
    },
    {
      "source": "softclustering",
      "target": "data"
    },
    {
      "source": "softclustering",
      "target": "featlearn"
    },
    {
      "source": "softclustering",
      "target": "feature"
    },
    {
      "source": "softclustering",
      "target": "specclustering"
    },
    {
      "source": "kroneckerproduct",
      "target": "matrix"
    },
    {
      "source": "kroneckerproduct",
      "target": "ml"
    },
    {
      "source": "kroneckerproduct",
      "target": "model"
    },
    {
      "source": "kroneckerproduct",
      "target": "vector"
    },
    {
      "source": "clustering",
      "target": "datapoint"
    },
    {
      "source": "clustering",
      "target": "cluster"
    },
    {
      "source": "clustering",
      "target": "kmeans"
    },
    {
      "source": "clustering",
      "target": "featurevec"
    },
    {
      "source": "clustering",
      "target": "mean"
    },
    {
      "source": "clustering",
      "target": "softclustering"
    },
    {
      "source": "clustering",
      "target": "gmm"
    },
    {
      "source": "clustering",
      "target": "mvndist"
    },
    {
      "source": "cluster",
      "target": "datapoint"
    },
    {
      "source": "cluster",
      "target": "featurevec"
    },
    {
      "source": "cluster",
      "target": "featurespace"
    },
    {
      "source": "huberloss",
      "target": "loss"
    },
    {
      "source": "huberloss",
      "target": "sqerrloss"
    },
    {
      "source": "huberloss",
      "target": "abserr"
    },
    {
      "source": "svm",
      "target": "classification"
    },
    {
      "source": "svm",
      "target": "hypothesis"
    },
    {
      "source": "svm",
      "target": "map"
    },
    {
      "source": "svm",
      "target": "linreg"
    },
    {
      "source": "svm",
      "target": "logreg"
    },
    {
      "source": "svm",
      "target": "erm"
    },
    {
      "source": "svm",
      "target": "linmodel"
    },
    {
      "source": "svm",
      "target": "lossfunc"
    },
    {
      "source": "svm",
      "target": "datapoint"
    },
    {
      "source": "svm",
      "target": "featurespace"
    },
    {
      "source": "svm",
      "target": "maximum"
    },
    {
      "source": "svm",
      "target": "hingeloss"
    },
    {
      "source": "svm",
      "target": "vector"
    },
    {
      "source": "svm",
      "target": "classifier"
    },
    {
      "source": "svm",
      "target": "loss"
    },
    {
      "source": "svm",
      "target": "decisionboundary"
    },
    {
      "source": "svm",
      "target": "trainset"
    },
    {
      "source": "svm",
      "target": "ml"
    },
    {
      "source": "svm",
      "target": "kernel"
    },
    {
      "source": "eigenvalue",
      "target": "matrix"
    },
    {
      "source": "eigenvalue",
      "target": "vector"
    },
    {
      "source": "eigenvector",
      "target": "matrix"
    },
    {
      "source": "eigenvector",
      "target": "vector"
    },
    {
      "source": "eigenvector",
      "target": "eigenvalue"
    },
    {
      "source": "evd",
      "target": "matrix"
    },
    {
      "source": "evd",
      "target": "eigenvector"
    },
    {
      "source": "evd",
      "target": "eigenvalue"
    },
    {
      "source": "svd",
      "target": "matrix"
    },
    {
      "source": "tv",
      "target": "gtv"
    },
    {
      "source": "cvxclustering",
      "target": "dataset"
    },
    {
      "source": "cvxclustering",
      "target": "convex"
    },
    {
      "source": "cvxclustering",
      "target": "clustering"
    },
    {
      "source": "cvxclustering",
      "target": "vector"
    },
    {
      "source": "cvxclustering",
      "target": "norm"
    },
    {
      "source": "cvxclustering",
      "target": "cluster"
    },
    {
      "source": "cvxclustering",
      "target": "datapoint"
    },
    {
      "source": "gdmethod",
      "target": "gradient"
    },
    {
      "source": "gdmethod",
      "target": "minimum"
    },
    {
      "source": "gdmethod",
      "target": "maximum"
    },
    {
      "source": "gdmethod",
      "target": "differentiable"
    },
    {
      "source": "gdmethod",
      "target": "objfunc"
    },
    {
      "source": "gdmethod",
      "target": "modelparam"
    },
    {
      "source": "gdmethod",
      "target": "gd"
    },
    {
      "source": "gdmethod",
      "target": "optmethod"
    },
    {
      "source": "sgd",
      "target": "subgradient"
    },
    {
      "source": "sgd",
      "target": "generalization"
    },
    {
      "source": "sgd",
      "target": "gd"
    },
    {
      "source": "sgd",
      "target": "function"
    },
    {
      "source": "sgd",
      "target": "gradient"
    },
    {
      "source": "sgd",
      "target": "objfunc"
    },
    {
      "source": "sgd",
      "target": "emprisk"
    },
    {
      "source": "sgd",
      "target": "modelparam"
    },
    {
      "source": "sgd",
      "target": "hypothesis"
    },
    {
      "source": "stochGD",
      "target": "gd"
    },
    {
      "source": "stochGD",
      "target": "gradient"
    },
    {
      "source": "stochGD",
      "target": "objfunc"
    },
    {
      "source": "stochGD",
      "target": "stochastic"
    },
    {
      "source": "stochGD",
      "target": "model"
    },
    {
      "source": "stochGD",
      "target": "erm"
    },
    {
      "source": "stochGD",
      "target": "trainset"
    },
    {
      "source": "stochGD",
      "target": "datapoint"
    },
    {
      "source": "stochGD",
      "target": "emprisk"
    },
    {
      "source": "stochGD",
      "target": "function"
    },
    {
      "source": "stochGD",
      "target": "modelparam"
    },
    {
      "source": "stochGD",
      "target": "batch"
    },
    {
      "source": "stochGD",
      "target": "parameter"
    },
    {
      "source": "onlineGD",
      "target": "ml"
    },
    {
      "source": "onlineGD",
      "target": "modelparam"
    },
    {
      "source": "onlineGD",
      "target": "paramspace"
    },
    {
      "source": "onlineGD",
      "target": "datapoint"
    },
    {
      "source": "onlineGD",
      "target": "iid"
    },
    {
      "source": "onlineGD",
      "target": "rv"
    },
    {
      "source": "onlineGD",
      "target": "risk"
    },
    {
      "source": "onlineGD",
      "target": "hypothesis"
    },
    {
      "source": "onlineGD",
      "target": "objfunc"
    },
    {
      "source": "onlineGD",
      "target": "gd"
    },
    {
      "source": "onlineGD",
      "target": "gradstep"
    },
    {
      "source": "onlineGD",
      "target": "loss"
    },
    {
      "source": "onlineGD",
      "target": "learnrate"
    },
    {
      "source": "onlineGD",
      "target": "sqerrloss"
    },
    {
      "source": "onlineGD",
      "target": "onlinelearning"
    },
    {
      "source": "pca",
      "target": "featuremap"
    },
    {
      "source": "pca",
      "target": "feature"
    },
    {
      "source": "pca",
      "target": "minimum"
    },
    {
      "source": "pca",
      "target": "johnsonlindenstrausslemma"
    },
    {
      "source": "loss",
      "target": "ml"
    },
    {
      "source": "loss",
      "target": "lossfunc"
    },
    {
      "source": "loss",
      "target": "hypothesis"
    },
    {
      "source": "loss",
      "target": "datapoint"
    },
    {
      "source": "loss",
      "target": "emprisk"
    },
    {
      "source": "lossfunc",
      "target": "loss"
    },
    {
      "source": "lossfunc",
      "target": "function"
    },
    {
      "source": "lossfunc",
      "target": "map"
    },
    {
      "source": "lossfunc",
      "target": "datapoint"
    },
    {
      "source": "lossfunc",
      "target": "feature"
    },
    {
      "source": "lossfunc",
      "target": "label"
    },
    {
      "source": "lossfunc",
      "target": "hypothesis"
    },
    {
      "source": "lossfunc",
      "target": "prediction"
    },
    {
      "source": "lossfunc",
      "target": "featurevec"
    },
    {
      "source": "lossfunc",
      "target": "ml"
    },
    {
      "source": "lossfunc",
      "target": "erm"
    },
    {
      "source": "decisiontree",
      "target": "hypothesis"
    },
    {
      "source": "decisiontree",
      "target": "map"
    },
    {
      "source": "decisiontree",
      "target": "graph"
    },
    {
      "source": "decisiontree",
      "target": "featurevec"
    },
    {
      "source": "decisiontree",
      "target": "datapoint"
    },
    {
      "source": "decisiontree",
      "target": "feature"
    },
    {
      "source": "decisiontree",
      "target": "decisionregion"
    },
    {
      "source": "decisiontree",
      "target": "vector"
    },
    {
      "source": "decisiontree",
      "target": "featurespace"
    },
    {
      "source": "API",
      "target": "ml"
    },
    {
      "source": "API",
      "target": "model"
    },
    {
      "source": "API",
      "target": "featurevec"
    },
    {
      "source": "API",
      "target": "datapoint"
    },
    {
      "source": "API",
      "target": "prediction"
    },
    {
      "source": "API",
      "target": "feature"
    },
    {
      "source": "API",
      "target": "risk"
    },
    {
      "source": "API",
      "target": "modelinversion"
    },
    {
      "source": "modelinversion",
      "target": "model"
    },
    {
      "source": "modelinversion",
      "target": "privattack"
    },
    {
      "source": "modelinversion",
      "target": "ml"
    },
    {
      "source": "modelinversion",
      "target": "sensattr"
    },
    {
      "source": "modelinversion",
      "target": "datapoint"
    },
    {
      "source": "modelinversion",
      "target": "prediction"
    },
    {
      "source": "modelinversion",
      "target": "classification"
    },
    {
      "source": "modelinversion",
      "target": "gradient"
    },
    {
      "source": "modelinversion",
      "target": "trustAI"
    },
    {
      "source": "modelinversion",
      "target": "privprot"
    },
    {
      "source": "samplesize",
      "target": "datapoint"
    },
    {
      "source": "samplesize",
      "target": "sample"
    },
    {
      "source": "samplesize",
      "target": "dataset"
    },
    {
      "source": "samplesize",
      "target": "erm"
    },
    {
      "source": "samplesize",
      "target": "trainset"
    },
    {
      "source": "samplesize",
      "target": "model"
    },
    {
      "source": "samplesize",
      "target": "effdim"
    },
    {
      "source": "samplesize",
      "target": "iidasspt"
    },
    {
      "source": "samplesize",
      "target": "overfitting"
    },
    {
      "source": "skipconnection",
      "target": "deepnet"
    },
    {
      "source": "skipconnection",
      "target": "layer"
    },
    {
      "source": "skipconnection",
      "target": "dag"
    },
    {
      "source": "ann",
      "target": "hypothesis"
    },
    {
      "source": "ann",
      "target": "feature"
    },
    {
      "source": "ann",
      "target": "datapoint"
    },
    {
      "source": "ann",
      "target": "prediction"
    },
    {
      "source": "ann",
      "target": "label"
    },
    {
      "source": "ann",
      "target": "actfun"
    },
    {
      "source": "ann",
      "target": "dag"
    },
    {
      "source": "ann",
      "target": "deepnet"
    },
    {
      "source": "ann",
      "target": "layer"
    },
    {
      "source": "ann",
      "target": "modelparam"
    },
    {
      "source": "randomforest",
      "target": "decisiontree"
    },
    {
      "source": "randomforest",
      "target": "dataset"
    },
    {
      "source": "gd",
      "target": "minimum"
    },
    {
      "source": "gd",
      "target": "differentiable"
    },
    {
      "source": "gd",
      "target": "function"
    },
    {
      "source": "gd",
      "target": "gradient"
    },
    {
      "source": "gd",
      "target": "stepsize"
    },
    {
      "source": "gd",
      "target": "gradstep"
    },
    {
      "source": "abserr",
      "target": "datapoint"
    },
    {
      "source": "abserr",
      "target": "feature"
    },
    {
      "source": "abserr",
      "target": "label"
    },
    {
      "source": "abserr",
      "target": "loss"
    },
    {
      "source": "abserr",
      "target": "hypothesis"
    },
    {
      "source": "abserr",
      "target": "featurevec"
    },
    {
      "source": "abserr",
      "target": "sqerrloss"
    },
    {
      "source": "abserr",
      "target": "convex"
    },
    {
      "source": "abserr",
      "target": "function"
    },
    {
      "source": "abserr",
      "target": "prediction"
    },
    {
      "source": "abserr",
      "target": "nonsmooth"
    },
    {
      "source": "abserr",
      "target": "differentiable"
    },
    {
      "source": "abserr",
      "target": "erm"
    },
    {
      "source": "abserr",
      "target": "optmethod"
    },
    {
      "source": "abserr",
      "target": "lossfunc"
    },
    {
      "source": "abserr",
      "target": "sgd"
    },
    {
      "source": "abserr",
      "target": "learnrate"
    },
    {
      "source": "abserr",
      "target": "convergence"
    },
    {
      "source": "abserr",
      "target": "outlier"
    },
    {
      "source": "abserr",
      "target": "trainset"
    },
    {
      "source": "abserr",
      "target": "ladregression"
    },
    {
      "source": "device",
      "target": "data"
    },
    {
      "source": "device",
      "target": "ml"
    },
    {
      "source": "device",
      "target": "datapoint"
    },
    {
      "source": "device",
      "target": "model"
    },
    {
      "source": "huberreg",
      "target": "regression"
    },
    {
      "source": "huberreg",
      "target": "erm"
    },
    {
      "source": "huberreg",
      "target": "huberloss"
    },
    {
      "source": "huberreg",
      "target": "prediction"
    },
    {
      "source": "huberreg",
      "target": "ladregression"
    },
    {
      "source": "huberreg",
      "target": "linreg"
    },
    {
      "source": "huberreg",
      "target": "parameter"
    },
    {
      "source": "huberreg",
      "target": "robustness"
    },
    {
      "source": "huberreg",
      "target": "abserr"
    },
    {
      "source": "huberreg",
      "target": "smooth"
    },
    {
      "source": "huberreg",
      "target": "sqerrloss"
    },
    {
      "source": "ladregression",
      "target": "erm"
    },
    {
      "source": "ladregression",
      "target": "abserr"
    },
    {
      "source": "ladregression",
      "target": "huberreg"
    },
    {
      "source": "ladregression",
      "target": "parammodel"
    },
    {
      "source": "ladregression",
      "target": "median"
    },
    {
      "source": "ladregression",
      "target": "dataset"
    },
    {
      "source": "ladregression",
      "target": "outlier"
    },
    {
      "source": "ladregression",
      "target": "sqerrloss"
    },
    {
      "source": "ladregression",
      "target": "mean"
    },
    {
      "source": "metric",
      "target": "ml"
    },
    {
      "source": "metric",
      "target": "model"
    },
    {
      "source": "metric",
      "target": "lossfunc"
    },
    {
      "source": "metric",
      "target": "acc"
    },
    {
      "source": "metric",
      "target": "zerooneloss"
    },
    {
      "source": "metric",
      "target": "testset"
    },
    {
      "source": "metric",
      "target": "training"
    },
    {
      "source": "metric",
      "target": "validation"
    },
    {
      "source": "metric",
      "target": "loss"
    },
    {
      "source": "bayesrisk",
      "target": "probmodel"
    },
    {
      "source": "bayesrisk",
      "target": "ml"
    },
    {
      "source": "bayesrisk",
      "target": "datapoint"
    },
    {
      "source": "bayesrisk",
      "target": "rv"
    },
    {
      "source": "bayesrisk",
      "target": "probdist"
    },
    {
      "source": "bayesrisk",
      "target": "feature"
    },
    {
      "source": "bayesrisk",
      "target": "label"
    },
    {
      "source": "bayesrisk",
      "target": "risk"
    },
    {
      "source": "bayesrisk",
      "target": "minimum"
    },
    {
      "source": "bayesrisk",
      "target": "hypothesis"
    },
    {
      "source": "bayesrisk",
      "target": "bayesestimator"
    },
    {
      "source": "bayesestimator",
      "target": "probmodel"
    },
    {
      "source": "bayesestimator",
      "target": "probdist"
    },
    {
      "source": "bayesestimator",
      "target": "feature"
    },
    {
      "source": "bayesestimator",
      "target": "label"
    },
    {
      "source": "bayesestimator",
      "target": "datapoint"
    },
    {
      "source": "bayesestimator",
      "target": "lossfunc"
    },
    {
      "source": "bayesestimator",
      "target": "hypothesis"
    },
    {
      "source": "bayesestimator",
      "target": "risk"
    },
    {
      "source": "bayesestimator",
      "target": "minimum"
    },
    {
      "source": "weights",
      "target": "hypospace"
    },
    {
      "source": "weights",
      "target": "modelparam"
    },
    {
      "source": "weights",
      "target": "feature"
    },
    {
      "source": "weights",
      "target": "linmodel"
    },
    {
      "source": "weights",
      "target": "ann"
    },
    {
      "source": "weights",
      "target": "layer"
    },
    {
      "source": "weights",
      "target": "activation"
    },
    {
      "source": "probdist",
      "target": "ml"
    },
    {
      "source": "probdist",
      "target": "datapoint"
    },
    {
      "source": "probdist",
      "target": "iid"
    },
    {
      "source": "probdist",
      "target": "realization"
    },
    {
      "source": "probdist",
      "target": "rv"
    },
    {
      "source": "probdist",
      "target": "probability"
    },
    {
      "source": "probdist",
      "target": "pdf"
    },
    {
      "source": "pdf",
      "target": "rv"
    },
    {
      "source": "pdf",
      "target": "probability"
    },
    {
      "source": "pdf",
      "target": "event"
    },
    {
      "source": "pdf",
      "target": "LebesgueIntegral"
    },
    {
      "source": "pdf",
      "target": "dimension"
    },
    {
      "source": "pdf",
      "target": "probdist"
    },
    {
      "source": "pdf",
      "target": "measurable"
    },
    {
      "source": "pdf",
      "target": "vector"
    },
    {
      "source": "parameter",
      "target": "ml"
    },
    {
      "source": "parameter",
      "target": "model"
    },
    {
      "source": "parameter",
      "target": "hypothesis"
    },
    {
      "source": "parameter",
      "target": "map"
    },
    {
      "source": "parameter",
      "target": "linmodel"
    },
    {
      "source": "parameter",
      "target": "weights"
    },
    {
      "source": "parameter",
      "target": "ann"
    },
    {
      "source": "lln",
      "target": "convergence"
    },
    {
      "source": "lln",
      "target": "iid"
    },
    {
      "source": "lln",
      "target": "rv"
    },
    {
      "source": "lln",
      "target": "mean"
    },
    {
      "source": "lln",
      "target": "probdist"
    },
    {
      "source": "stopcrit",
      "target": "ml"
    },
    {
      "source": "stopcrit",
      "target": "algorithm"
    },
    {
      "source": "stopcrit",
      "target": "modelparam"
    },
    {
      "source": "stopcrit",
      "target": "trainerr"
    },
    {
      "source": "stopcrit",
      "target": "gdmethod"
    },
    {
      "source": "stopcrit",
      "target": "parameter"
    },
    {
      "source": "stopcrit",
      "target": "model"
    },
    {
      "source": "stopcrit",
      "target": "linmodel"
    },
    {
      "source": "stopcrit",
      "target": "deepnet"
    },
    {
      "source": "jacobimethod",
      "target": "algorithm"
    },
    {
      "source": "jacobimethod",
      "target": "matrix"
    },
    {
      "source": "jacobimethod",
      "target": "fixedpointiter"
    },
    {
      "source": "jacobimethod",
      "target": "optmethod"
    },
    {
      "source": "renyidiv",
      "target": "probdist"
    },
    {
      "source": "nonsmooth",
      "target": "function"
    },
    {
      "source": "nonsmooth",
      "target": "smooth"
    },
    {
      "source": "convex",
      "target": "euclidspace"
    },
    {
      "source": "convex",
      "target": "function"
    },
    {
      "source": "convex",
      "target": "epigraph"
    },
    {
      "source": "smooth",
      "target": "function"
    },
    {
      "source": "smooth",
      "target": "differentiable"
    },
    {
      "source": "smooth",
      "target": "gradient"
    },
    {
      "source": "smooth",
      "target": "optproblem"
    },
    {
      "source": "smooth",
      "target": "objfunc"
    },
    {
      "source": "smooth",
      "target": "gdmethod"
    },
    {
      "source": "smooth",
      "target": "gradstep"
    },
    {
      "source": "smooth",
      "target": "stepsize"
    },
    {
      "source": "parammodel",
      "target": "model"
    },
    {
      "source": "parammodel",
      "target": "parameter"
    },
    {
      "source": "parammodel",
      "target": "probmodel"
    },
    {
      "source": "parammodel",
      "target": "dimension"
    },
    {
      "source": "parammodel",
      "target": "mvndist"
    },
    {
      "source": "parammodel",
      "target": "samplespace"
    },
    {
      "source": "parammodel",
      "target": "mean"
    },
    {
      "source": "parammodel",
      "target": "vector"
    },
    {
      "source": "parammodel",
      "target": "covmtx"
    },
    {
      "source": "parammodel",
      "target": "ml"
    },
    {
      "source": "parammodel",
      "target": "hypospace"
    },
    {
      "source": "parammodel",
      "target": "modelparam"
    },
    {
      "source": "parammodel",
      "target": "hypothesis"
    },
    {
      "source": "parammodel",
      "target": "linmodel"
    },
    {
      "source": "parammodel",
      "target": "ann"
    },
    {
      "source": "parammodel",
      "target": "paramspace"
    },
    {
      "source": "parammodel",
      "target": "map"
    },
    {
      "source": "paramspace",
      "target": "parameter"
    },
    {
      "source": "paramspace",
      "target": "ml"
    },
    {
      "source": "paramspace",
      "target": "model"
    },
    {
      "source": "paramspace",
      "target": "modelparam"
    },
    {
      "source": "paramspace",
      "target": "vector"
    },
    {
      "source": "paramspace",
      "target": "euclidspace"
    },
    {
      "source": "paramspace",
      "target": "linmodel"
    },
    {
      "source": "paramspace",
      "target": "deepnet"
    },
    {
      "source": "paramspace",
      "target": "norm"
    },
    {
      "source": "paramspace",
      "target": "hypothesis"
    },
    {
      "source": "paramspace",
      "target": "map"
    },
    {
      "source": "datanorm",
      "target": "data"
    },
    {
      "source": "datanorm",
      "target": "featurevec"
    },
    {
      "source": "datanorm",
      "target": "datapoint"
    },
    {
      "source": "datanorm",
      "target": "ml"
    },
    {
      "source": "datanorm",
      "target": "statasp"
    },
    {
      "source": "datanorm",
      "target": "compasp"
    },
    {
      "source": "datanorm",
      "target": "linreg"
    },
    {
      "source": "datanorm",
      "target": "gdmethod"
    },
    {
      "source": "datanorm",
      "target": "learnrate"
    },
    {
      "source": "datanorm",
      "target": "convergence"
    },
    {
      "source": "datanorm",
      "target": "norm"
    },
    {
      "source": "datanorm",
      "target": "trainset"
    },
    {
      "source": "datanorm",
      "target": "featuremap"
    },
    {
      "source": "dataaug",
      "target": "data"
    },
    {
      "source": "dataaug",
      "target": "datapoint"
    },
    {
      "source": "dataaug",
      "target": "label"
    },
    {
      "source": "dataaug",
      "target": "featurevec"
    },
    {
      "source": "dataaug",
      "target": "regularization"
    },
    {
      "source": "dataaug",
      "target": "featurespace"
    },
    {
      "source": "localdataset",
      "target": "dataset"
    },
    {
      "source": "localdataset",
      "target": "datapoint"
    },
    {
      "source": "localdataset",
      "target": "feature"
    },
    {
      "source": "localdataset",
      "target": "label"
    },
    {
      "source": "localdataset",
      "target": "ml"
    },
    {
      "source": "localdataset",
      "target": "probmodel"
    },
    {
      "source": "localdataset",
      "target": "empgraph"
    },
    {
      "source": "localmodel",
      "target": "device"
    },
    {
      "source": "localmodel",
      "target": "empgraph"
    },
    {
      "source": "localmodel",
      "target": "model"
    },
    {
      "source": "localmodel",
      "target": "hypospace"
    },
    {
      "source": "mutualinformation",
      "target": "rv"
    },
    {
      "source": "mutualinformation",
      "target": "probspace"
    },
    {
      "source": "mutualinformation",
      "target": "prediction"
    },
    {
      "source": "mutualinformation",
      "target": "hypothesis"
    },
    {
      "source": "mutualinformation",
      "target": "erm"
    },
    {
      "source": "mutualinformation",
      "target": "ml"
    },
    {
      "source": "zerogradientcondition",
      "target": "optproblem"
    },
    {
      "source": "zerogradientcondition",
      "target": "smooth"
    },
    {
      "source": "zerogradientcondition",
      "target": "convex"
    },
    {
      "source": "zerogradientcondition",
      "target": "objfunc"
    },
    {
      "source": "zerogradientcondition",
      "target": "vector"
    },
    {
      "source": "zerogradientcondition",
      "target": "gradient"
    },
    {
      "source": "edgeweight",
      "target": "empgraph"
    },
    {
      "source": "dataminprinc",
      "target": "data"
    },
    {
      "source": "layer",
      "target": "deepnet"
    },
    {
      "source": "layer",
      "target": "ann"
    },
    {
      "source": "layer",
      "target": "actfun"
    },
    {
      "source": "layer",
      "target": "activation"
    },
    {
      "source": "layer",
      "target": "feature"
    },
    {
      "source": "layer",
      "target": "datapoint"
    },
    {
      "source": "layer",
      "target": "prediction"
    },
    {
      "source": "activation",
      "target": "ann"
    },
    {
      "source": "activation",
      "target": "actfun"
    },
    {
      "source": "activation",
      "target": "deepnet"
    },
    {
      "source": "cav",
      "target": "deepnet"
    },
    {
      "source": "cav",
      "target": "layer"
    },
    {
      "source": "cav",
      "target": "label"
    },
    {
      "source": "cav",
      "target": "datapoint"
    },
    {
      "source": "cav",
      "target": "featurevec"
    },
    {
      "source": "cav",
      "target": "activation"
    },
    {
      "source": "cav",
      "target": "featurespace"
    },
    {
      "source": "cav",
      "target": "linclass"
    },
    {
      "source": "cav",
      "target": "decisionboundary"
    },
    {
      "source": "cav",
      "target": "vector"
    },
    {
      "source": "cav",
      "target": "linmodel"
    },
    {
      "source": "cav",
      "target": "trustAI"
    },
    {
      "source": "cav",
      "target": "interpretability"
    },
    {
      "source": "cav",
      "target": "transparency"
    },
    {
      "source": "backpropagation",
      "target": "algorithm"
    },
    {
      "source": "backpropagation",
      "target": "gradient"
    },
    {
      "source": "backpropagation",
      "target": "objfunc"
    },
    {
      "source": "backpropagation",
      "target": "modelparam"
    },
    {
      "source": "backpropagation",
      "target": "ann"
    },
    {
      "source": "backpropagation",
      "target": "loss"
    },
    {
      "source": "backpropagation",
      "target": "batch"
    },
    {
      "source": "backpropagation",
      "target": "datapoint"
    },
    {
      "source": "backpropagation",
      "target": "lossfunc"
    },
    {
      "source": "backpropagation",
      "target": "layer"
    },
    {
      "source": "backpropagation",
      "target": "weights"
    },
    {
      "source": "backpropagation",
      "target": "prediction"
    },
    {
      "source": "backpropagation",
      "target": "label"
    },
    {
      "source": "backpropagation",
      "target": "parameter"
    },
    {
      "source": "backpropagation",
      "target": "gradstep"
    },
    {
      "source": "backpropagation",
      "target": "data"
    },
    {
      "source": "backpropagation",
      "target": "gd"
    },
    {
      "source": "backpropagation",
      "target": "optmethod"
    },
    {
      "source": "vcdim",
      "target": "erm"
    },
    {
      "source": "vcdim",
      "target": "hypospace"
    },
    {
      "source": "vcdim",
      "target": "model"
    },
    {
      "source": "vcdim",
      "target": "dataset"
    },
    {
      "source": "vcdim",
      "target": "label"
    },
    {
      "source": "vcdim",
      "target": "featurevec"
    },
    {
      "source": "vcdim",
      "target": "hypothesis"
    },
    {
      "source": "vcdim",
      "target": "gengap"
    },
    {
      "source": "vcdim",
      "target": "linmodel"
    },
    {
      "source": "vcdim",
      "target": "feature"
    },
    {
      "source": "vcdim",
      "target": "datapoint"
    },
    {
      "source": "vcdim",
      "target": "linclass"
    },
    {
      "source": "vcdim",
      "target": "featurespace"
    },
    {
      "source": "vcdim",
      "target": "paramspace"
    },
    {
      "source": "vcdim",
      "target": "decisiontree"
    },
    {
      "source": "vcdim",
      "target": "ann"
    },
    {
      "source": "vcdim",
      "target": "rademachercomplexity"
    },
    {
      "source": "vcdim",
      "target": "generalization"
    },
    {
      "source": "vcdim",
      "target": "ml"
    },
    {
      "source": "vcdim",
      "target": "effdim"
    },
    {
      "source": "metricspace",
      "target": "euclidspace"
    },
    {
      "source": "metricspace",
      "target": "undirectedgraph"
    },
    {
      "source": "metricspace",
      "target": "eucliddist"
    },
    {
      "source": "metricspace",
      "target": "featurespace"
    },
    {
      "source": "rademachercomplexity",
      "target": "vcdim"
    },
    {
      "source": "rademachercomplexity",
      "target": "hypospace"
    },
    {
      "source": "rademachercomplexity",
      "target": "dataset"
    },
    {
      "source": "rademachercomplexity",
      "target": "expectation"
    },
    {
      "source": "rademachercomplexity",
      "target": "rv"
    },
    {
      "source": "rademachercomplexity",
      "target": "iid"
    },
    {
      "source": "rademachercomplexity",
      "target": "probability"
    },
    {
      "source": "rademachercomplexity",
      "target": "generalization"
    },
    {
      "source": "rademachercomplexity",
      "target": "ml"
    },
    {
      "source": "rademachercomplexity",
      "target": "effdim"
    },
    {
      "source": "penaltyterm",
      "target": "erm"
    },
    {
      "source": "penaltyterm",
      "target": "ml"
    },
    {
      "source": "penaltyterm",
      "target": "modelparam"
    },
    {
      "source": "penaltyterm",
      "target": "loss"
    },
    {
      "source": "penaltyterm",
      "target": "emprisk"
    },
    {
      "source": "penaltyterm",
      "target": "trainset"
    },
    {
      "source": "penaltyterm",
      "target": "overfitting"
    },
    {
      "source": "penaltyterm",
      "target": "gengap"
    },
    {
      "source": "penaltyterm",
      "target": "objfunc"
    },
    {
      "source": "penaltyterm",
      "target": "rerm"
    },
    {
      "source": "penaltyterm",
      "target": "feature"
    },
    {
      "source": "penaltyterm",
      "target": "label"
    },
    {
      "source": "penaltyterm",
      "target": "training"
    },
    {
      "source": "penaltyterm",
      "target": "regularization"
    },
    {
      "source": "penaltyterm",
      "target": "datapoint"
    },
    {
      "source": "penaltyterm",
      "target": "model"
    },
    {
      "source": "penaltyterm",
      "target": "lossfunc"
    },
    {
      "source": "penaltyterm",
      "target": "dataaug"
    },
    {
      "source": "sequence",
      "target": "function"
    },
    {
      "source": "sequence",
      "target": "ml"
    },
    {
      "source": "sequence",
      "target": "algorithm"
    },
    {
      "source": "sequence",
      "target": "dataset"
    },
    {
      "source": "convergence",
      "target": "sequence"
    },
    {
      "source": "convergence",
      "target": "metricspace"
    },
    {
      "source": "convergence",
      "target": "metric"
    },
    {
      "source": "convergence",
      "target": "cauchysequence"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "featuremap"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "eucliddist"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "featurevec"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "dataset"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "datapoint"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "featurespace"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "matrix"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "iid"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "rv"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "probability"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "norm"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "vectorspace"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "euclidspace"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "dimred"
    },
    {
      "source": "johnsonlindenstrausslemma",
      "target": "pca"
    },
    {
      "source": "majmin",
      "target": "optproblem"
    },
    {
      "source": "majmin",
      "target": "convex"
    },
    {
      "source": "majmin",
      "target": "nonsmooth"
    },
    {
      "source": "majmin",
      "target": "objfunc"
    },
    {
      "source": "majmin",
      "target": "erm"
    },
    {
      "source": "majmin",
      "target": "modelparam"
    },
    {
      "source": "majmin",
      "target": "model"
    },
    {
      "source": "majmin",
      "target": "optmethod"
    },
    {
      "source": "majmin",
      "target": "sequence"
    },
    {
      "source": "majmin",
      "target": "iteration"
    },
    {
      "source": "majmin",
      "target": "function"
    },
    {
      "source": "majmin",
      "target": "gdmethod"
    },
    {
      "source": "majmin",
      "target": "em"
    },
    {
      "source": "markovsinequality",
      "target": "rv"
    },
    {
      "source": "markovsinequality",
      "target": "expectation"
    },
    {
      "source": "markovsinequality",
      "target": "probability"
    },
    {
      "source": "markovsinequality",
      "target": "function"
    },
    {
      "source": "markovsinequality",
      "target": "LebesgueIntegral"
    },
    {
      "source": "markovsinequality",
      "target": "probdist"
    },
    {
      "source": "markovsinequality",
      "target": "concentrationinequ"
    },
    {
      "source": "chebyshevsinequality",
      "target": "rv"
    },
    {
      "source": "chebyshevsinequality",
      "target": "expectation"
    },
    {
      "source": "chebyshevsinequality",
      "target": "variance"
    },
    {
      "source": "chebyshevsinequality",
      "target": "probability"
    },
    {
      "source": "chebyshevsinequality",
      "target": "markovsinequality"
    },
    {
      "source": "chebyshevsinequality",
      "target": "concentrationinequ"
    }
  ]
}